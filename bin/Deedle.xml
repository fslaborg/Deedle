<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Deedle</name></assembly>
<members>
<member name="M:Deedle.Aggregation.WindowWhile``1(System.Func{``0,``0,System.Boolean})">
<summary>
 Aggregate data into floating windows where each window ends as soon
 as the specified function returns `false` when called with the 
 first key and the current key as arguments.

 ## Parameters

  - `condition` - A delegate that specifies when to end the current window
    (e.g. `(k1, k2) =&gt; k2 - k1 &lt; 10` means that the difference between keys
    in each window will be less than 10.
</summary>
</member>
<member name="M:Deedle.Aggregation.WindowSize``1(System.Int32,Deedle.Boundary)">
<summary>
 Aggregate data into floating windows of a specified size 
 and the provided handling of boundary elements.

 ## Parameters

  - `size` - Specifies the size of the floating window. Depending on the
    boundary behavior, the actual created windows may be smaller.
  - `boundary` - Specifies how to handle boundaries (when there is not
    enough data to create an entire window). 
</summary>
</member>
<member name="M:Deedle.Aggregation.ChunkWhile``1(System.Func{``0,``0,System.Boolean})">
<summary>
 Aggregate data into non-overlapping chunks where each chunk ends as soon
 as the specified function returns `false` when called with the 
 first key and the current key as arguments.

 ## Parameters

  - `condition` - A delegate that specifies when to end the current chunk
    (e.g. `(k1, k2) =&gt; k2 - k1 &lt; 10` means that the difference between keys
    in each chunk will be less than 10.
</summary>
</member>
<member name="M:Deedle.Aggregation.ChunkSize``1(System.Int32,Deedle.Boundary)">
<summary>
 Aggregate data into non-overlapping chunks of a specified size 
 and the provided handling of boundary elements.

 ## Parameters

  - `size` - Specifies the size of the floating window. Depending on the
    boundary behavior, the actual created windows may be smaller.
  - `boundary` - Specifies how to handle boundaries (when there is not
    enough data to create an entire window). 
</summary>
</member>
<member name="T:Deedle.Aggregation">
<summary>
 A non-generic type that simplifies the construction of `Aggregation&lt;K&gt;` values
 from C#. It provides methods for constructing different kinds of aggregation
 strategies for ordered series.

 [category:Parameters and results of various operations]
</summary>
</member>
<member name="T:Deedle.Aggregation`1.ChunkWhile">
<summary>
 Aggregate data into non-overlapping chunks where each chunk ends as soon
 as the specified function returns `false` when called with the 
 first key and the current key as arguments.
</summary>
</member>
<member name="T:Deedle.Aggregation`1.WindowWhile">
<summary>
 Aggregate data into floating windows where each window ends as soon
 as the specified function returns `false` when called with the 
 first key and the current key as arguments.
</summary>
</member>
<member name="T:Deedle.Aggregation`1.ChunkSize">
<summary>
 Aggregate data into non-overlapping chunks of a specified size 
 and the provided handling of boundary elements.
</summary>
</member>
<member name="T:Deedle.Aggregation`1.WindowSize">
<summary>
 Aggregate data into floating windows of a specified size 
 and the provided handling of boundary elements.
</summary>
</member>
<member name="T:Deedle.Aggregation`1">
<summary>
 Represents a strategy for aggregating data in an ordered series into data segments.
 To create a value of this type from C#, use the non-generic `Aggregation` type.
 Data can be aggregate using floating windows or chunks of a specified size or 
 by specifying a condition on two keys (i.e. end a window/chunk when the condition
 no longer holds).

 [category:Parameters and results of various operations]
</summary>
</member>
<member name="T:Deedle.Boundary">
<summary>
 Represents boundary behaviour for operations such as floating window. The type
 specifies whether incomplete windows (of smaller than required length) should be
 produced at the beginning (`AtBeginning`) or at the end (`AtEnding`) or
 skipped (`Skip`). For chunking, combinations are allowed too - to skip incomplete
 chunk at the beginning, use `Boundary.Skip ||| Boundary.AtBeginning`.

 [category:Parameters and results of various operations]
</summary>
</member>
<member name="T:Deedle.ColumnSeries`2">
<summary>
 Represents a series of columns from a frame. The type inherits from a series of 
 series representing individual columns (`Series&lt;&apos;TColumnKey, ObjectSeries&lt;&apos;TRowKey&gt;&gt;`) but
 hides slicing operations with new versions that return frames.

 [category:Specialized frame and series types]
</summary>
</member>
<member name="F:Deedle.ConversionKind.Flexible">
<summary>
 Allows the use of arbitrary .NET conversions. This uses `Convert.ChangeType`, which
 performs numerical conversions, parsing of strings, uses `IConvertable` and more.
</summary>
</member>
<member name="F:Deedle.ConversionKind.Safe">
<summary>
 Allows conversions that widen numeric types, but nothing else. This includes
 conversions on decimals `decimal -&gt; float32 -&gt; float` and also from integers 
 to floating points (`int -&gt; decimal` etc.)
</summary>
</member>
<member name="F:Deedle.ConversionKind.Exact">
<summary>
 Specifies that the type has to match exactly and no conversions are performed.
</summary>
</member>
<member name="T:Deedle.ConversionKind">
<summary>
 Represents different kinds of type conversions that can be used by Deedle internally.
 This is used, for example, when converting `ObjectSeries&lt;&apos;K&gt;` to `Series&lt;&apos;K, &apos;T&gt;` - 
 The conversion kind can be specified as an argument to allow certain conversions.

 [category:Parameters and results of various operations]
</summary>
</member>
<member name="T:Deedle.DataSegmentKind">
<summary>
 Represents a kind of `DataSegment&lt;T&gt;`. See that type for more information.

 [category:Parameters and results of various operations]
</summary>
</member>
<member name="P:Deedle.DataSegment`1.Kind">
<summary>
 Return the kind of this segment
</summary>
</member>
<member name="P:Deedle.DataSegment`1.Data">
<summary>
 Returns the data associated with the segment
 (for boundary segment, this may be smaller than the required window size)
</summary>
</member>
<member name="M:Deedle.DataSegment`1.ToString">
<summary>
 Format data segment nicely
</summary>
</member>
<member name="T:Deedle.DataSegment`1">
<summary>
 Represents a segment of a series or sequence. The value is returned from 
 various functions that aggregate data into chunks or floating windows. The 
 `Complete` case represents complete segment (e.g. of the specified size) and
 `Boundary` represents segment at the boundary (e.g. smaller than the required
 size). 

 ## Example

 For example (using internal `windowed` function):

     open Deedle.Internal

     Seq.windowedWithBounds 3 Boundary.AtBeginning [ 1; 2; 3; 4 ]
     [fsi:  [| DataSegment(Incomplete, [| 1 |])         ]
     [fsi:       DataSegment(Incomplete, [| 1; 2 |])    ]
     [fsi:       DataSegment(Complete [| 1; 2; 3 |])    ]
     [fsi:       DataSegment(Complete [| 2; 3; 4 |]) |] ]

 If you do not need to distinguish the two cases, you can use the `Data` property
 to get the array representing the segment data.

 [category:Parameters and results of various operations]
</summary>
</member>
<member name="M:Deedle.DelayedSeries.FromValueLoader``2(``0,``0,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,Deedle.Indices.BoundaryBehavior},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,Deedle.Indices.BoundaryBehavior},Microsoft.FSharp.Control.FSharpAsync{System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}}}}})">
<summary>
 An F#-friendly function that creates lazily loaded series. The method requires
 the overall range of the series (smallest and greatest key) and a function that
 loads the data. The function is called with two tuples that specify lower and upper
 boundary. It returns an asynchronous workflow that produces the data.

 ## Parameters
 
  - `min` - The smallest key that should be present in the created series.
  - `min` - The greatests key that should be present in the created series.
  - `loader` - A function which returns an asynchronous workflow that loads the data in a 
    specified range. The function is called with two tuples consisting of key and 
    `BoundaryBehavior` values. The keys specify lower and upper boundary and 
    `BoundaryBehavior` values can be either `Inclusive` or `Exclusive`.

 ## Remarks

 For more information see the [lazy data loading tutorial](../lazysource.html).
</summary>
</member>
<member name="M:Deedle.DelayedSeries.FromValueLoader``2(``0,``0,System.Func{``0,Deedle.Indices.BoundaryBehavior,``0,Deedle.Indices.BoundaryBehavior,System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}}}})">
<summary>
 A C#-friendly function that creates lazily loaded series. The method requires
 the overall range of the series (smallest and greatest key) and a function that
 loads the data. In this overload, the function is a `Func` delegate taking 
 information about the requested range and returning `Task&lt;T&gt;` that produces the data.

 ## Parameters
 
  - `min` - The smallest key that should be present in the created series.
  - `min` - The greatests key that should be present in the created series.
  - `loader` - A delegate which returns a task that loads the data in a specified 
    range. The delegate is called with four arguments specifying the minimal and
    maximal key and two `BoundaryBehavior` values specifying whether the low and
    high ranges are inclusive or exclusive.

 ## Remarks

 For more information see the [lazy data loading tutorial](../lazysource.html).
 The operation calls `loader` (and so creates the tasks) on the thread that is
 requesting the result.
</summary>
</member>
<member name="T:Deedle.DelayedSeries">
<summary>
 This type exposes a single static method `DelayedSeries.Create` that can be used for
 constructing data series (of type `Series&lt;K, V&gt;`) with lazily loaded data. You can
 use this functionality to create series that represents e.g. an entire price history
 in a database, but only loads data that are actually needed. For more information
 see the [lazy data loading tutorial](../lazysource.html).
 
 ## Example
 
 Assuming we have a function `generate lo hi` that generates data in the specified
 `DateTime` range, we can create lazy series as follows:

     let ls = DelayedSeries.Create(min, max, fun (lo, lob) (hi, hib) -&gt; 
       async { 
         printfn &quot;Query: %A - %A&quot; (lo, lob) (hi, hib)
         return generate lo hi })

 The arguments `min` and `max` specfify the complete range of the series. The 
 function passed to `Create` is called with minimal and maximal required key
 (`lo` and `hi`) and with two values that specify boundary behaviour.

 [category:Specialized frame and series types]
</summary>
</member>
<member name="T:Deedle.Direction">
<summary>
 Specifies in which direction should we look when performing operations such as
 `Series.Pairwise`. 

 ## Example

     let abc = 
       [ 1 =&gt; &quot;a&quot;; 2 =&gt; &quot;b&quot;; 3 =&gt; &quot;c&quot; ]
       |&gt; Series.ofObservations

     // Using &apos;Forward&apos; the key of the first element is used
     abc.Pairwise(direction=Direction.Forward)
     [fsi:[ 1 =&gt; (&quot;a&quot;, &quot;b&quot;); 2 =&gt; (&quot;b&quot;, &quot;c&quot;) ]]

     // Using &apos;Backward&apos; the key of the second element is used
     abc.Pairwise(direction=Direction.Backward)
     [fsi:[ 2 =&gt; (&quot;a&quot;, &quot;b&quot;); 3 =&gt; (&quot;b&quot;, &quot;c&quot;) ]]


 [category:Parameters and results of various operations]
</summary>
</member>
<member name="M:Deedle.EnumerableExtensions.ToSparseSeries``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,Deedle.OptionalValue{``1}}})">
<summary>
 Convert the `IEnumerable` to a  `Series`, using the keys and values of
 the `KeyValuePair` as keys and values of the resulting series.
 `OptionalValue.Missing` can be used to denote missing values.
</summary>
</member>
<member name="M:Deedle.EnumerableExtensions.ToSeries``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
<summary>
 Convert the `IEnumerable` to a `Series`, using the keys and values of
 the `KeyValuePair` as keys and values of the resulting series.
</summary>
</member>
<member name="M:Deedle.EnumerableExtensions.ToOrdinalSeries``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Convert the `IEnumerable` to a `Series`, using the seuqence as the values
 of the resulting series. The keys are generated ordinarilly, starting from 0.
</summary>
</member>
<member name="T:Deedle.EnumerableExtensions">
<summary>
 Contains C#-friendly extension methods for various instances of `IEnumerable` 
 that can be used for creating `Series&lt;&apos;K, &apos;V&gt;` from the `IEnumerable` value.
 You can create an ordinal series from `IEnumerable&lt;&apos;T&gt;` or an indexed series from
 `IEnumerable&lt;KeyValuePair&lt;&apos;K, &apos;V&gt;&gt;` or from `IEnumerable&lt;KeyValuePair&lt;&apos;K, OptionalValue&lt;&apos;V&gt;&gt;&gt;`.

 [category:Frame and series operations]
</summary>
</member>
<member name="P:Deedle.Frame.NonExpandableTypes">
<summary>
 Configures how reflection-based expansion behaves - see also `df.ExpandColumns`.
 This (mutable, non-thread-safe) collection specifies additional primitive (but reference)
 types that should not be expaneded. By default, this includes DateTime, string, etc.

 [category:Configuration]
</summary>
</member>
<member name="P:Deedle.Frame.NonExpandableInterfaces">
<summary>
 Configures how reflection-based expansion behaves - see also `df.ExpandColumns`.
 This (mutable, non-thread-safe) collection specifies interfaces whose implementations
 should not be expanded. By default, this includes collections such as IList.

 [category:Configuration]
</summary>
</member>
<member name="P:Deedle.Frame.CustomExpanders">
<summary>
 Configures how reflection-based expansion behaves - see also `df.ExpandColumns`.
 This (mutable, non-thread-safe) collection lets you specify custom expansion behavior
 for any type. This is a dictionary with types as keys and functions that implement the
 expansion as values.

 ## Example
 For example, say you have a type `MyPair` with propreties `Item1` of type `int` and
 `Item2` of type `string` (and perhaps other properties which makes the default behavior
 inappropriate). You can register custom expander as:

     Frame.CustomExpanders.Add(typeof&lt;MyPair&gt;, fun v -&gt; 
       let a = v :?&gt; MyPair
       [ &quot;First&quot;, typeof&lt;int&gt;, box a.Item1; 
         &quot;Second&quot;, typeof&lt;string&gt;, box a.Item2 ] :&gt; seq&lt;_&gt; )

 [category:Configuration]
</summary>
</member>
<member name="M:Deedle.Frame.ReadReader(System.Data.IDataReader)">
<summary>
 Read data from `IDataReader`. The method reads all rows from the data reader
 and for each row, gets all the columns. When a value is `DBNull`, it is treated
 as missing. The types of created vectors are determined by the field types reported
 by the data reader.
 
 [category:Input and output]
</summary>
</member>
<member name="M:Deedle.Frame.ReadCsv(System.IO.Stream,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.String,System.String,System.String,System.Nullable{System.Int32},System.String[])">
<summary>
 Load data frame from a CSV file. The operation automatically reads column names from the 
 CSV file (if they are present) and infers the type of values for each column. Columns
 of primitive types (`int`, `float`, etc.) are converted to the right type. Columns of other
 types (such as dates) are not converted automatically.

 ## Parameters

  * `stream` - Specifies the input stream, opened at the beginning of CSV data
  * `hasHeaders` - Specifies whether the input CSV file has header row
     (when not set, the default value is `true`)
  * `inferTypes` - Specifies whether the method should attempt to infer types
    of columns automatically (set this to `false` if you want to specify schema)
  * `inferRows` - If `inferTypes=true`, this parameter specifies the number of
    rows to use for type inference. The default value is 100.
  * `schema` - A string that specifies CSV schema. See the documentation for 
    information about the schema format.
  * `separators` - A string that specifies one or more (single character) separators
    that are used to separate columns in the CSV file. Use for example `&quot;;&quot;` to 
    parse semicolon separated files.
  * `culture` - Specifies the name of the culture that is used when parsing 
    values in the CSV file (such as `&quot;en-US&quot;`). The default is invariant culture. 
  * `maxRows` - The maximal number of rows that should be read from the CSV file.
  * `missingValues` - An array of strings that contains values which should be treated
    as missing when reading the file. The default value is: &quot;NaN&quot;; &quot;NA&quot;; &quot;#N/A&quot;; &quot;:&quot;; &quot;-&quot;; &quot;TBA&quot;; &quot;TBD&quot;.

 [category:Input and output]
</summary>
</member>
<member name="M:Deedle.Frame.ReadCsv(System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.String,System.String,System.String,System.Nullable{System.Int32},System.String[])">
<summary>
 Load data frame from a CSV file. The operation automatically reads column names from the 
 CSV file (if they are present) and infers the type of values for each column. Columns
 of primitive types (`int`, `float`, etc.) are converted to the right type. Columns of other
 types (such as dates) are not converted automatically.

 ## Parameters

  * `location` - Specifies a file name or an web location of the resource.
  * `hasHeaders` - Specifies whether the input CSV file has header row
     (when not set, the default value is `true`)
  * `inferTypes` - Specifies whether the method should attempt to infer types
    of columns automatically (set this to `false` if you want to specify schema)
  * `inferRows` - If `inferTypes=true`, this parameter specifies the number of
    rows to use for type inference. The default value is 100.
  * `schema` - A string that specifies CSV schema. See the documentation for 
    information about the schema format.
  * `separators` - A string that specifies one or more (single character) separators
    that are used to separate columns in the CSV file. Use for example `&quot;;&quot;` to 
    parse semicolon separated files.
  * `culture` - Specifies the name of the culture that is used when parsing 
    values in the CSV file (such as `&quot;en-US&quot;`). The default is invariant culture. 
  * `maxRows` - Specifies the maximum number of rows that will be read from the CSV file

 [category:Input and output]
</summary>
</member>
<member name="M:Deedle.Frame.FromValues``3(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1,``2}})">
<summary>
 Create a data frame from a sequence of tuples containing row key, column key and a value
</summary>
</member>
<member name="M:Deedle.Frame.FromValues``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``0,``3})">
<summary>
 Create a data frame from a sequence of objects and functions that return
 row key, column key and value for each object in the input sequence.

 ## Parameters
  - `values` - Input sequence of objects 
  - `colSel` - A function that returns the column key of an object
  - `rowSel` - A function that returns the row key of an object
  - `valSel` - A function that returns the value of an object

</summary>
</member>
<member name="M:Deedle.Frame.FromRecords``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a data frame from a sequence of any .NET objects. The method uses reflection
 over the specified type parameter `&apos;T` and turns its properties to columns. The
 rows of the resulting frame are automatically indexed by `int`.

 ## Example
 The method can be nicely used to create a data frame using C# anonymous types
 (the result is a data frame with columns &quot;A&quot; and &quot;B&quot; containing two rows).

    [lang=csharp]
    var df = Frame.FromRecords(new[] {
      new { A = 1, B = &quot;Test&quot; },
       new { A = 2, B = &quot;Another&quot;}
    });
</summary>
</member>
<member name="M:Deedle.Frame.FromRecords``2(Deedle.Series{``0,``1})">
<summary>
 Creates a data frame from a sequence of any .NET objects. The method uses reflection
 over the specified type parameter `&apos;T` and turns its properties to columns.
</summary>
</member>
<member name="M:Deedle.Frame.FromArray2D``1(``0[0:,0:])">
<summary>
 Create data frame from a 2D array of values. The first dimension of the array
 is used as rows and the second dimension is treated as columns. Rows and columns
 of the returned frame are indexed with the element&apos;s offset in the array.

 ## Parameters
  - `array` - A two-dimensional array to be converted into a data frame
</summary>
</member>
<member name="T:Deedle.Frame">
<summary>
 Provides static methods for creating frames, reading frame data
 from CSV files and database (via IDataReader). The type also provides
 global configuration for reflection-based expansion.

 [category:Frame and series operations]
</summary>
</member>
<member name="P:Deedle.FrameData.Columns">
<summary>
 Represents the data of the frame as a sequence of columns containing
 type and array with column values. `OptionalValue.Missing` is used to
 represent missing data.
</summary>
</member>
<member name="P:Deedle.FrameData.RowKeys">
<summary>
 A sequence of keys for all rows. Individual key is an array
 which contains multiple values for hierarchical indices
</summary>
</member>
<member name="P:Deedle.FrameData.ColumnKeys">
<summary>
 A sequence of keys for all column. Individual key is an array
 which contains multiple values for hierarchical indices
</summary>
</member>
<member name="T:Deedle.FrameData">
<summary>
 Represents the underlying (raw) data of the frame in a format that can
 be used for exporting data frame to other formats etc. (DataTable, CSV, Excel)

 [category:Core frame and series types]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.Where``2(Deedle.Frame{``0,``1},System.Func{System.Collections.Generic.KeyValuePair{``0,Deedle.ObjectSeries{``1}},System.Int32,System.Boolean})">
<summary>
 Filters frame rows using the specified condtion. Returns a new data frame
 that contains rows for which the provided function returned false. The function
 is called with `KeyValuePair` containing the row key as the `Key` and `Value`
 gives access to the row series and a row index.

 ## Parameters

  * `frame` - A data frame to invoke the filtering function on.
  * `condition` - A delegate that specifies the filtering condition.
</summary>
</member>
<member name="M:Deedle.FrameExtensions.Where``2(Deedle.Frame{``0,``1},System.Func{System.Collections.Generic.KeyValuePair{``0,Deedle.ObjectSeries{``1}},System.Boolean})">
<summary>
 Filters frame rows using the specified condition. Returns a new data frame
 that contains rows for which the provided function returned false. The function
 is called with `KeyValuePair` containing the row key as the `Key` and `Value`
 gives access to the row series.

 ## Parameters

  * `frame` - A data frame to invoke the filtering function on.
  * `condition` - A delegate that specifies the filtering condition.
</summary>
</member>
<member name="M:Deedle.FrameExtensions.Unnest``3(Deedle.Series{``0,Deedle.Frame{``1,``2}})">
<summary>
 Given a series whose values are frames, create a frame resulting
 from the concatenation of all the frames&apos; rows, with the resulting 
 keys having two levels. This is the inverse operation to nest.

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.Transpose``2(Deedle.Frame{``0,``1})">
<summary>
 Returns a transposed data frame. The rows of the original data frame are used as the
 columns of the new one (and vice versa). Use this operation if you have a data frame
 and you mostly need to access its rows as a series (because accessing columns as a 
 series is more efficient).
 
 ## Parameters
  - `frame` - Source data frame to be transposed.
 
 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.ToDataTable``2(Deedle.Frame{``0,``1},System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Returns the data of the frame as a .NET `DataTable` object. The column keys are
 automatically converted to strings that are used as column names. The row index is
 turned into an additional column with the specified name (the function takes the name
 as a sequence to support hierarchical keys, but typically you can write just
 `frame.ToDataTable([&quot;KeyName&quot;])`.

 ## Parameters
  - `rowKeyNames` - Specifies the names of the row key components (or just a single
    row key name if the row index is not hierarchical).

 [category:Input and output]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.SortRowsWith``3(Deedle.Frame{``0,``1},``1,System.Collections.Generic.Comparer{``2})">
<summary>
 Returns a data frame that contains the same data as the input, 
 but whose rows are sorted by some column.

 ## Parameters
  - `frame` - Source data frame to be ordered.
 
 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.SortRowsByKey``2(Deedle.Frame{``0,``1})">
<summary>
 Returns a data frame that contains the same data as the input, 
 but whose rows are an ordered series. This allows using operations that are
 only available on indexed series such as alignment and inexact lookup.

 ## Parameters
  - `frame` - Source data frame to be ordered.
 
 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.SortRowsBy``4(Deedle.Frame{``0,``1},``1,System.Func{``2,``3})">
<summary>
 Returns a data frame that contains the same data as the input, 
 but whose rows are sorted by some column.

 ## Parameters
  - `frame` - Source data frame to be ordered.
 
 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.SortRows``2(Deedle.Frame{``0,``1},``1)">
<summary>
 Returns a data frame that contains the same data as the input, 
 but whose rows are sorted by some column.

 ## Parameters
  - `frame` - Source data frame to be ordered.
 
 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.SortColumnsByKey``2(Deedle.Frame{``0,``1})">
<summary>
 Returns a data frame that contains the same data as the input, 
 but whose columns are an ordered series. This allows using operations that are
 only available on indexed series such as alignment and inexact lookup.

 ## Parameters
  - `frame` - Source data frame to be ordered.
 
 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.SortByRowKey``2(Deedle.Frame{``0,``1})">
<summary>
 [omit]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.SortByColKey``2(Deedle.Frame{``0,``1})">
<summary>
 [omit]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.Shift``2(Deedle.Frame{``0,``1},System.Int32)">
<summary>
 Returns a frame with columns shifted by the specified offset. When the offset is 
 positive, the values are shifted forward and first `offset` keys are dropped. When the
 offset is negative, the values are shifted backwards and the last `offset` keys are dropped.
 Expressed in pseudo-code:

     result[k] = series[k - offset]

 ## Parameters
  - `offset` - Can be both positive and negative number.
  - `frame` - The input frame whose columns are to be shifted.

 ## Remarks
 If you want to calculate the difference, e.g. `df - (Frame.shift 1 df)`, you can
 use `Frame.diff` which will be a little bit faster.
</summary>
</member>
<member name="M:Deedle.FrameExtensions.SaveCsv``2(Deedle.Frame{``0,``1},System.IO.Stream,System.Boolean,System.Collections.Generic.IEnumerable{System.String},System.Char,System.Globalization.CultureInfo)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.SaveCsv``2(Deedle.Frame{``0,``1},System.String,System.Collections.Generic.IEnumerable{System.String},System.Char,System.Globalization.CultureInfo)">
<summary>
 Save data frame to a CSV file or to a `Stream`. When calling the operation,
 you can specify whether you want to save the row keys or not (and headers for the keys)
 and you can also specify the separator (use `\t` for writing TSV files). When specifying
 file name ending with `.tsv`, the `\t` separator is used automatically.

 ## Parameters
  - `path` - Specifies the output file name where the CSV data should be written
  - `keyNames` - Specifies the CSV headers for row key (or keys, for multi-level index)
  - `separator` - Specify the column separator in the file (the default is `\t` for 
    TSV files and `,` for CSV files)
  - `culture` - Specify the `CultureInfo` object used for formatting numerical data

 [category:Input and output]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.SaveCsv``2(Deedle.Frame{``0,``1},System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.String},System.Char,System.Globalization.CultureInfo)">
<summary>
 Save data frame to a CSV file or to a `Stream`. When calling the operation,
 you can specify whether you want to save the row keys or not (and headers for the keys)
 and you can also specify the separator (use `\t` for writing TSV files). When specifying
 file name ending with `.tsv`, the `\t` separator is used automatically.

 ## Parameters
  - `path` - Specifies the output file name where the CSV data should be written
  - `includeRowKeys` - When set to `true`, the row key is also written to the output file
  - `keyNames` - Can be used to specify the CSV headers for row key (or keys, for multi-level index)
  - `separator` - Specify the column separator in the file (the default is `\t` for 
    TSV files and `,` for CSV files)
  - `culture` - Specify the `CultureInfo` object used for formatting numerical data

 [category:Input and output]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.SaveCsv``2(Deedle.Frame{``0,``1},System.IO.TextWriter,System.Boolean,System.Collections.Generic.IEnumerable{System.String},System.Char,System.Globalization.CultureInfo)">
<summary>
 Save data frame to a CSV file or to a `Stream`. When calling the operation,
 you can specify whether you want to save the row keys or not (and headers for the keys)
 and you can also specify the separator (use `\t` for writing TSV files). When specifying
 file name ending with `.tsv`, the `\t` separator is used automatically.

 ## Parameters
  - `writer` - Specifies the text writer to which the CSV data should be written
  - `includeRowKeys` - When set to `true`, the row key is also written to the output file
  - `keyNames` - Can be used to specify the CSV headers for row key (or keys, for multi-level index)
  - `separator` - Specify the column separator in the file (the default is `\t` for 
    TSV files and `,` for CSV files)
  - `culture` - Specify the `CultureInfo` object used for formatting numerical data

 [category:Input and output]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.RealignRows``2(Deedle.Frame{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Align the existing data to a specified collection of row keys. Values in the data frame
 that do not match any new key are dropped, new keys (that were not in the original data 
 frame) are assigned missing values.

 ## Parameters
  - `frame` - Source data frame that is to be realigned.
  - `keys` - A sequence of new row keys. The keys must have the same type as the original
    frame keys (because the rows are realigned).

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.PivotTable``5(Deedle.Frame{``0,``1},``1,``1,System.Func{Deedle.Frame{``0,``1},``4})">
<summary>
 Creates a new data frame resulting from a &apos;pivot&apos; operation. Consider a denormalized data 
 frame representing a table: column labels are field names &amp; table values are observations
 of those fields. pivotTable buckets the rows along two axes, according to the values of 
 the columns `r` and `c`; and then computes a value for the frame of rows that land in each 
 bucket.

 ## Parameters
  - `r` - A column key to group on for the resulting row index
  - `c` - A column key to group on for the resulting col index
  - `op` - A function computing a value from the corresponding bucket frame 

 [category:Frame operations]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.OrderRows``2(Deedle.Frame{``0,``1})">
<summary>
 [omit]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.OrderColumns``2(Deedle.Frame{``0,``1})">
<summary>
 [omit]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.NestBy``3(Deedle.Frame{``0,``1},System.Func{``0,``2})">
<summary>
 Given a data frame whose row index has two levels, create a series
 whose keys are the unique results of the keyselector projection, and 
 whose values are those corresponding frames selected from the original 
 data.  

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.Nest``3(Deedle.Frame{System.Tuple{``0,``1},``2})">
<summary>
 Given a data frame whose row index has two levels, create a series
 whose keys are the unique first level keys, and whose values are 
 those corresponding frames selected from the original data.  

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.IndexRowsWith``3(Deedle.Frame{``0,``1},System.Collections.Generic.IEnumerable{``2})">
<summary>
 Replace the row index of the frame with the provided sequence of row keys.
 The rows of the frame are assigned keys according to the current order, or in a
 non-deterministic way, if the current row index is not ordered.

 ## Parameters
  - `frame` - Source data frame whose row index are to be replaced.
  - `keys` - A collection of new row keys.

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.IndexRowsUsing``3(Deedle.Frame{``0,``1},System.Func{Deedle.ObjectSeries{``1},``2})">
<summary>
 Replace the row index of the frame with a sequence of row keys generated using
 a function invoked on each row.

 ## Parameters
  - `frame` - Source data frame whose row index are to be replaced.
  - `f` - A function from row (as object series) to new row key value

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.IndexRowsOrdinally``2(Deedle.Frame{``0,``1})">
<summary>
 Replace the row index of the frame with ordinarilly generated integers starting from zero.
 The rows of the frame are assigned index according to the current order, or in a
 non-deterministic way, if the current row index is not ordered.

 ## Parameters
  - `frame` - Source data frame whose row index are to be replaced.

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.IndexColumnsWith``3(Deedle.Frame{``0,``1},System.Collections.Generic.IEnumerable{``2})">
<summary>
 Replace the column index of the frame with the provided sequence of column keys.
 The columns of the frame are assigned keys according to the current order, or in a
 non-deterministic way, if the current column index is not ordered.

 ## Parameters
  - `frame` - Source data frame whose column index are to be replaced.
  - `keys` - A collection of new column keys.

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.GetRows``2(Deedle.Frame{``0,``1},``0[])">
<summary>
 [category:Fancy accessors]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.FillMissing``3(Deedle.Frame{``0,``1},System.Func{Deedle.Series{``0,``2},``0,``2})">
<summary>
 Fill missing values in the frame using the specified function. The specified
 function is called with all series and keys for which the frame does not 
 contain value and the result of the call is used in place of the missing value.

 The operation is only applied to columns (series) that contain values of the
 same type as the return type of the provided filling function. The operation 
 does not attempt to convert between numeric values (so a series containing 
 `float` will not be converted to a series of `int`).

 ## Parameters
  - `frame` - An input data frame that is to be filled
  - `f` - A function that takes a series `Series&lt;R, T&gt;` together with a key `K` 
    in the series and generates a value to be used in a place where the original 
    series contains a missing value.

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.FillMissing``2(Deedle.Frame{``0,``1},Deedle.Direction)">
<summary>
 Fill missing values in the data frame with the nearest available value
 (using the specified direction). Note that the frame may still contain
 missing values after call to this function (e.g. if the first value is not available
 and we attempt to fill series with previous values). This operation can only be
 used on ordered frames.

 ## Parameters
  - `frame` - An input data frame that is to be filled
  - `direction` - Specifies the direction used when searching for 
    the nearest available value. `Backward` means that we want to
    look for the first value with a smaller key while `Forward` searches
    for the nearest greater key.

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.FillMissing``3(Deedle.Frame{``0,``1},``2)">
<summary>
 Fill missing values of a given type in the frame with a constant value.
 The operation is only applied to columns (series) that contain values of the
 same type as the provided filling value. The operation does not attempt to 
 convert between numeric values (so a series containing `float` will not be
 converted to a series of `int`).

 ## Parameters
  - `frame` - An input data frame that is to be filled
  - `value` - A constant value that is used to fill all missing values

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.ExpandColumns``1(Deedle.Frame{``0,System.String},System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Creates a new data frame where the specified columns are expanded based on runtime
 structure of the objects they store. A column can be expanded if it is 
 `Series&lt;string, T&gt;` or `IDictionary&lt;K, V&gt;` or if it is any .NET object with readable
 properties. 

 ## Example
 Given a data frame with a series that contains tuples, you can expand the
 tuple members and get a frame with columns `S.Item1` and `S.Item2`:
 
     let df = frame [ &quot;S&quot; =&gt; series [ 1 =&gt; (1, &quot;One&quot;); 2 =&gt; (2, &quot;Two&quot;) ] ]  
     df.ExpandColumns [&quot;S&quot;]

 ## Parameters
  - `names` - Names of columns in the original data frame to be expanded
  - `frame` - Input data frame whose columns will be expanded

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.ExpandColumns``1(Deedle.Frame{``0,System.String},System.Int32,System.Boolean)">
<summary>
 Creates a new data frame where all columns are expanded based on runtime
 structure of the objects they store. The expansion is performed recrusively
 to the specified depth. A column can be expanded if it is `Series&lt;string, T&gt;` 
 or `IDictionary&lt;K, V&gt;` or if it is any .NET object with readable
 properties. 

 ## Parameters
  - `nesting` - The nesting level for expansion. When set to 0, nothing is done.

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.DropSparseRows``2(Deedle.Frame{``0,``1})">
<summary>
 Creates a new data frame that contains only those rows of the original 
 data frame that are _dense_, meaning that they have a value for each column.
 The resulting data frame has the same number of columns, but may have 
 fewer rows (or no rows at all).
 
 ## Parameters
  - `frame` - An input data frame that is to be filtered

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.DropSparseColumns``2(Deedle.Frame{``0,``1})">
<summary>
 Creates a new data frame that contains only those columns of the original 
 data frame that are _dense_, meaning that they have a value for each row.
 The resulting data frame has the same number of rows, but may have 
 fewer columns (or no columns at all).

 ## Parameters
  - `frame` - An input data frame that is to be filtered

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.Diff``2(Deedle.Frame{``0,``1},System.Int32)">
<summary>
 Returns a frame with columns containing difference between an original value and
 a value at the specified offset. For example, calling `Frame.diff 1 s` returns a 
 frame where previous column values is subtracted from the current ones. In pseudo-code, the
 function behaves as follows:

     result[k] = series[k] - series[k - offset]

 Columns that cannot be converted to `float` are left without a change.

 ## Parameters
  - `offset` - When positive, subtracts the past values from the current values;
    when negative, subtracts the future values from the current values.
  - `frame` - The input frame containing at least some `float` columns.

</summary>
</member>
<member name="M:Deedle.FrameExtensions.CountRows``2(Deedle.Frame{``0,``1})">
<summary>
 Returns the total number of row keys in the specified frame. This returns
 the total length of the row series, including keys for which there is no 
 value available.
</summary>
</member>
<member name="M:Deedle.FrameExtensions.CountColumns``2(Deedle.Frame{``0,``1})">
<summary>
 Returns the total number of row keys in the specified frame. This returns
 the total length of the row series, including keys for which there is no 
 value available.
</summary>
</member>
<member name="T:Deedle.FrameExtensions">
<summary>
 Contains C# and F# extension methods for the `Frame&lt;&apos;R, &apos;C&gt;` type. The members are 
 automatically available when you import the `Deedle` namespace. The type contains 
 object-oriented counterparts to most of the functionality from the `Frame` module.

 ## Data structure manipulation
 Summary 1

 ## Input and output
 Summary 2

 ## Missing values
 Summary 3

 [category:Frame and series operations]
</summary>
</member>
<member name="M:Deedle.FrameUtils.fromRowsAndColumnKeys``3(Deedle.Indices.IIndexBuilder,Deedle.Vectors.IVectorBuilder,System.Collections.ObjectModel.ReadOnlyCollection{``1},Deedle.Series{``0,``2})">
<summary>
 Create data frame from a series of rows
</summary>
</member>
<member name="M:Deedle.FrameUtils.fromRows``3(Deedle.Indices.IIndexBuilder,Deedle.Vectors.IVectorBuilder,Deedle.Series{``0,``2})">
<summary>
 Create data frame from a series of rows
</summary>
</member>
<member name="M:Deedle.FrameUtils.fromColumns``3(Deedle.Indices.IIndexBuilder,Deedle.Vectors.IVectorBuilder,Deedle.Series{``1,``2})">
<summary>
 Create data frame from a series of columns
</summary>
</member>
<member name="T:Deedle.FrameUtils">
<summary>
 [omit]
 Module with helper functions and operations that are needed by Frame&lt;R, C&gt;, but
 are easier to write in a separate type (having them inside generic type 
 can confuse the type inference in various ways).
</summary>
</member>
<member name="P:Deedle.Frame`2.Item(`1,Deedle.Series{`0,System.Double})">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_UnaryNegation(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Subtraction(System.Int32,Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Subtraction(Deedle.Frame{`0,`1},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Subtraction(System.Double,Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Subtraction(Deedle.Frame{`0,`1},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Subtraction(Deedle.Series{`0,System.Int32},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Subtraction(Deedle.Frame{`0,`1},Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Subtraction(Deedle.Series{`0,System.Double},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Subtraction(Deedle.Frame{`0,`1},Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Subtraction(Deedle.Frame{`0,`1},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Multiply(System.Int32,Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Multiply(Deedle.Frame{`0,`1},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Multiply(System.Double,Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Multiply(Deedle.Frame{`0,`1},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Multiply(Deedle.Series{`0,System.Int32},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Multiply(Deedle.Frame{`0,`1},Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Multiply(Deedle.Series{`0,System.Double},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Multiply(Deedle.Frame{`0,`1},Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Multiply(Deedle.Frame{`0,`1},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_DynamicAssignment``3(Deedle.Frame{``0,``1},``1,System.Collections.Generic.IEnumerable{``2})">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_DynamicAssignment``3(Deedle.Frame{``0,``1},``1,Deedle.Series{``0,``2})">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Dynamic``2(Deedle.Frame{``0,``1},``1)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Dollar``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Frame{`0,`1})">
<summary>
 Custom operator that can be used for applying fuction to all elements of 
 a frame. This provides a nicer syntactic sugar for the `Frame.mapValues` 
 function.
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Division(System.Int32,Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Division(Deedle.Frame{`0,`1},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Division(System.Double,Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Division(Deedle.Frame{`0,`1},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Division(Deedle.Series{`0,System.Int32},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Division(Deedle.Frame{`0,`1},Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Division(Deedle.Series{`0,System.Double},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Division(Deedle.Frame{`0,`1},Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Division(Deedle.Frame{`0,`1},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Addition(System.Int32,Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Addition(Deedle.Frame{`0,`1},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Addition(System.Double,Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Addition(Deedle.Frame{`0,`1},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Addition(Deedle.Series{`0,System.Int32},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Addition(Deedle.Frame{`0,`1},Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Addition(Deedle.Series{`0,System.Double},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Addition(Deedle.Frame{`0,`1},Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Addition(Deedle.Frame{`0,`1},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="P:Deedle.Frame`2.RowsDense">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:Deedle.Frame`2.Rows">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:Deedle.Frame`2.RowKeys">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:Deedle.Frame`2.Item(`1)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="P:Deedle.Frame`2.Item(`1,`0)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:Deedle.Frame`2.IsEmpty">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:Deedle.Frame`2.ColumnsDense">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:Deedle.Frame`2.Columns">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:Deedle.Frame`2.ColumnTypes">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:Deedle.Frame`2.ColumnKeys">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Frame`2.Zip``3(Deedle.Frame{`0,`1},System.Func{``0,``1,``2})">
<summary>
 Aligns two data frames using both column index and row index and apply the specified operation
 on values of a specified type that are available in both data frames. This overload uses
 `JoinKind.Outer` for both columns and rows.

 Once aligned, the call `df1.Zip&lt;T&gt;(df2, f)` applies the specifed function `f` on all `T` values
 that are available in corresponding locations in both frames. For values of other types, the 
 value from `df1` is returned.

 ## Parameters
  - `otherFrame` - Other frame to be aligned and zipped with the current instance
  - `op` - A function that is applied to aligned values. The `Zip` operation is generic
    in the type of this function and the type of function is used to determine which 
    values in the frames are zipped and which are left unchanged.

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.Frame`2.Zip``3(Deedle.Frame{`0,`1},Deedle.JoinKind,Deedle.JoinKind,Deedle.Lookup,System.Func{``0,``1,``2})">
<summary>
 Aligns two data frames using both column index and row index and apply the specified operation
 on values of a specified type that are available in both data frames. The parameters `columnKind`,
 and `rowKind` can be specified to determine how the alginment works (similarly to `Join`).
 Column keys are always matched using `Lookup.Exact`, but `lookup` determines lookup for rows.

 Once aligned, the call `df1.Zip&lt;T&gt;(df2, f)` applies the specifed function `f` on all `T` values
 that are available in corresponding locations in both frames. For values of other types, the 
 value from `df1` is returned.

 ## Parameters
  - `otherFrame` - Other frame to be aligned and zipped with the current instance
  - `columnKind` - Specifies how to align columns (inner, outer, left or right join)
  - `rowKind` - Specifies how to align rows (inner, outer, left or right join)
  - `lookup` - Specifies how to find matching value for a row (when using left or right join on rows)
    Supported values are `Lookup.Exact`, `Lookup.ExactOrSmaller` and `Lookup.ExactOrGreater`.
  - `op` - A function that is applied to aligned values. The `Zip` operation is generic
    in the type of this function and the type of function is used to determine which 
    values in the frames are zipped and which are left unchanged.

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.Frame`2.TryGetRowObservation``1(`0,Deedle.Lookup)">
<summary>
 Try to find a row with the specified row key, or using the specified `lookup` parameter,
 and return the found row together with its actual key in case `lookup` was used. In case the
 row is not found, `OptionalValue.Missing` is returned.

 ## Parameters
  - `rowKey` - Specifies the key of the row to be returned
  - `lookup` - Specifies how to find value in a frame with ordered rows when the key does 
               not exactly match (look for nearest available value with the smaller/greater key).

 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Frame`2.TryGetRow``1(`0,Deedle.Lookup)">
<summary>
 Returns a row with the specieifed key wrapped in `OptionalValue`. When the specified key 
 is not found, the result is `OptionalValue.Missing`. This method is generic and returns the result 
 as a series containing values of the specified type. To get heterogeneous series of 
 type `ObjectSeries&lt;&apos;TCol&gt;`, use the `frame.Rows` property.

 ## Parameters
  - `rowKey` - Specifies the key of the row to be returned
  - `lookup` - Specifies how to find value in a frame with ordered rows when the key does 
               not exactly match (look for nearest available value with the smaller/greater key).

 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Frame`2.TryGetRow``1(`0)">
<summary>
 Returns a row with the specieifed key wrapped in `OptionalValue`. When the specified key 
 is not found, the result is `OptionalValue.Missing`. This method is generic and returns the result 
 as a series containing values of the specified type. To get heterogeneous series of 
 type `ObjectSeries&lt;&apos;TCol&gt;`, use the `frame.Rows` property.

 ## Parameters
  - `rowKey` - Specifies the key of the row to be returned

 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Frame`2.TryGetColumnObservation``1(`1,Deedle.Lookup)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.TryGetColumn``1(`1,Deedle.Lookup)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.Truncate(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.ToArray2D``1">
<summary>
 Returns data of the data frame as a 2D array. The method attempts to convert
 all values to the specified type &apos;R. If the specified type is &apos;float&apos; or &apos;double&apos;
 then the method automatically uses NaN. For other values, the default value has to
 be explicitly specified using another overload.

 [category:Fancy accessors]
</summary>
</member>
<member name="M:Deedle.Frame`2.ToArray2D``1(``0)">
<summary>
 Returns data of the data frame as a 2D array. The method attempts to convert
 all values to the specified type &apos;R. When a value is missing, the specified 
 `defaultValue` is used.

 ## Parameters
  - `defaultValue` - Default value used to fill all missing values

 [category:Fancy accessors]
</summary>
</member>
<member name="M:Deedle.Frame`2.Tanh(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Tan(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Sqrt(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Sinh(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Sin(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Sign(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.SelectValues``2(System.Func{``0,``1})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.Frame`2.Select``2(System.Func{`0,`1,``0,``1})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.Frame`2.Round(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.ReplaceColumn``1(`1,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Mutates the data frame by replacing the specified series with
 a new data sequence . (If the series does not exist, only the new
 series is added.)

 ## Parameters
  - `column` - A key (or name) for the column to be replaced or added
  - `series` - A sequence of values to be added

 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.ReplaceColumn(`1,Deedle.ISeries{`0})">
<summary>
 Mutates the data frame by replacing the specified series with
 a new series. (If the series does not exist, only the new
 series is added.)

 ## Parameters
  - `column` - A key (or name) for the column to be replaced or added
  - `series` - A data series to be used (the row key type has to match)

 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.ReplaceColumn``1(`1,System.Collections.Generic.IEnumerable{``0},Deedle.Lookup)">
<summary>
 Mutates the data frame by replacing the specified series with
 a new data sequence. (If the series does not exist, only the new series is added.) 
 When adding a series, the specified `lookup` parameter is used for filling
 missing values (e.g. `null` or `NaN`). The parameter can only be used for 
 frame with ordered indices.

 ## Parameters
  - `column` - A key (or name) for the column to be replaced or added
  - `series` - A data series to be used (the row key type has to match)
  - `lookup` - Specify how to find value in the added series (look for 
    nearest available value with the smaller/greater key).

 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.ReplaceColumn(`1,Deedle.ISeries{`0},Deedle.Lookup)">
<summary>
 Mutates the data frame by replacing the specified series with
 a new series. (If the series does not exist, only the new series is added.) 
 When adding a series, the specified `lookup` parameter is used for matching 
 keys. The parameter can only be used for frame with ordered indices.

 ## Parameters
  - `column` - A key (or name) for the column to be replaced or added
  - `series` - A data series to be used (the row key type has to match)
  - `lookup` - Specify how to find value in the added series (look for 
    nearest available value with the smaller/greater key).

 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.RenameColumns(System.Func{`1,`1})">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.RenameColumns(System.Collections.Generic.IEnumerable{`1})">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.RenameColumn(`1,`1)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.Pow(System.Double,Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Pow(Deedle.Frame{`0,`1},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Merge(Deedle.Frame{`0,`1}[])">
<summary>
 Merge multiple data frames with non-overlapping values. The operation takes the union of columns
 and rows of the source data frames and then unions the values. An exception is thrown when 
 both data frames define value for a column/row location, but the operation succeeds if one
 frame has a missing value at the location.

 Note that the rows are *not* automatically reindexed to avoid overlaps. This means that when
 a frame has rows indexed with ordinal numbers, you may need to explicitly reindex the row
 keys before calling append.

 ## Parameters
  - `otherFrames` - A collection containing other data frame to be appended 
    (combined) with the current instance

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.Frame`2.Merge(System.Collections.Generic.IEnumerable{Deedle.Frame{`0,`1}})">
<summary>
 Merge multiple data frames with non-overlapping values. The operation takes the union of columns
 and rows of the source data frames and then unions the values. An exception is thrown when 
 both data frames define value for a column/row location, but the operation succeeds if one
 frame has a missing value at the location.

 Note that the rows are *not* automatically reindexed to avoid overlaps. This means that when
 a frame has rows indexed with ordinal numbers, you may need to explicitly reindex the row
 keys before calling append.

 ## Parameters
  - `otherFrames` - A collection containing other data frame to be appended 
    (combined) with the current instance

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.Frame`2.Merge(Deedle.Frame{`0,`1})">
<summary>
 Merge two data frames with non-overlapping values. The operation takes the union of columns
 and rows of the source data frames and then unions the values. An exception is thrown when 
 both data frames define value for a column/row location, but the operation succeeds if one
 frame has a missing value at the location.

 Note that the rows are *not* automatically reindexed to avoid overlaps. This means that when
 a frame has rows indexed with ordinal numbers, you may need to explicitly reindex the row
 keys before calling append.

 ## Parameters
  - `otherFrame` - The other frame to be appended (combined) with the current instance

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.Frame`2.Log10(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Log(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Join``1(`1,Deedle.Series{`0,``0})">
<summary>
 Performs outer join on data frame and a series. The column key for the joined
 series must not occur in the current data frame. The rows are automatically aligned
 and unavailable values are marked as missing.

 ## Parameters
  - `colKey` - Column key to be used for the joined series
  - `series` - Series to be joined with the current data frame

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.Frame`2.Join``1(`1,Deedle.Series{`0,``0},Deedle.JoinKind)">
<summary>
 Join data frame and a series. The column key for the joined series must not occur in the 
 current data frame. The rows are aligned and transformed according to the specified join kind.

 ## Parameters
  - `colKey` - Column key to be used for the joined series
  - `series` - Series to be joined with the current data frame
  - `kind` - Specifies the joining behavior on row indices. Use `JoinKind.Outer` and 
    `JoinKind.Inner` to get the union and intersection of the row keys, respectively.
    Use `JoinKind.Left` and `JoinKind.Right` to use the current key of the left/right
    data frame.

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.Frame`2.Join``1(`1,Deedle.Series{`0,``0},Deedle.JoinKind,Deedle.Lookup)">
<summary>
 Join data frame and a series. The column key for the joined series must not occur in the 
 current data frame. The rows are aligned and transformed according to the specified join kind.
 When the index of both objects is ordered, it is possible to specify `lookup` 
 in order to align indices from other frame to the indices of the main frame
 (typically, to find the nearest key with available value for a key).

 ## Parameters
  - `colKey` - Column key to be used for the joined series
  - `series` - Series to be joined with the current data frame
  - `kind` - Specifies the joining behavior on row indices. Use `JoinKind.Outer` and 
    `JoinKind.Inner` to get the union and intersection of the row keys, respectively.
    Use `JoinKind.Left` and `JoinKind.Right` to use the current key of the left/right
    data frame.
  - `lookup` - When `kind` is `Left` or `Right` and the two frames have ordered row index,
    this parameter can be used to specify how to find value for a key when there is no
    exactly matching key or when there are missing values.
    Supported values are `Lookup.Exact`, `Lookup.ExactOrSmaller` and `Lookup.ExactOrGreater`.

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.Frame`2.Join(Deedle.Frame{`0,`1})">
<summary>
 Performs outer join on two data frames. The columns of the joined frames must not 
 overlap and their rows are aligned. The unavailable values are marked as missing.

 ## Parameters
  - `otherFrame` - Other frame (right) to be joined with the current instance (left)

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.Frame`2.Join(Deedle.Frame{`0,`1},Deedle.JoinKind)">
<summary>
 Join two data frames. The columns of the joined frames must not overlap and their
 rows are aligned and transformed according to the specified join kind.
 For more alignment options on ordered frames, see overload taking `lookup`.

 ## Parameters
  - `otherFrame` - Other frame (right) to be joined with the current instance (left)
  - `kind` - Specifies the joining behavior on row indices. Use `JoinKind.Outer` and 
    `JoinKind.Inner` to get the union and intersection of the row keys, respectively.
    Use `JoinKind.Left` and `JoinKind.Right` to use the current key of the left/right
    data frame.

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.Frame`2.Join(Deedle.Frame{`0,`1},Deedle.JoinKind,Deedle.Lookup)">
<summary>
 Join two data frames. The columns of the joined frames must not overlap and their
 rows are aligned and transformed according to the specified join kind.
 When the index of both frames is ordered, it is possible to specify `lookup` 
 in order to align indices from other frame to the indices of the main frame
 (typically, to find the nearest key with available value for a key).

 ## Parameters
  - `otherFrame` - Other frame (right) to be joined with the current instance (left)
  - `kind` - Specifies the joining behavior on row indices. Use `JoinKind.Outer` and 
    `JoinKind.Inner` to get the union and intersection of the row keys, respectively.
    Use `JoinKind.Left` and `JoinKind.Right` to use the current key of the left/right
    data frame.
  - `lookup` - When `kind` is `Left` or `Right` and the two frames have ordered row index,
    this parameter can be used to specify how to find value for a key when there is no
    exactly matching key or when there are missing values.
    Supported values are `Lookup.Exact`, `Lookup.ExactOrSmaller` and `Lookup.ExactOrGreater`.

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.Frame`2.IndexRows``1(`1)">
<summary>
 Returns a data frame whose rows are indexed based on the specified column of the original
 data frame. The generic type parameter is (typically) needed to specify the type of the 
 values in the required index column. 

 The resulting frame will *not* contain the specified column. If you want to preserve the
 column, use the overload that takes `keepColumn` parameter.

 ## Parameters
  - `column` - The name of a column in the original data frame that will be used for the new
    index. Note that the values in the column need to be unique.

 [category:Indexing]
</summary>
</member>
<member name="M:Deedle.Frame`2.IndexRows``1(`1,System.Boolean)">
<summary>
 Returns a data frame whose rows are indexed based on the specified column of the original
 data frame. The generic type parameter is (typically) needed to specify the type of the 
 values in the required index column.

 ## Parameters
  - `column` - The name of a column in the original data frame that will be used for the new
    index. Note that the values in the column need to be unique.
  - `keepColumn` - Specifies whether the column used as an index should be kept in the frame.

 [category:Indexing]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetSubrange(Microsoft.FSharp.Core.FSharpOption{System.Tuple{`0,Deedle.Indices.BoundaryBehavior}},Microsoft.FSharp.Core.FSharpOption{System.Tuple{`0,Deedle.Indices.BoundaryBehavior}})">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetRowsAs``1">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetRows``1">
<summary>
 [category:Fancy accessors]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetRowKeyAt(System.Int64)">
<summary>
 Returns the row key that is located at the specified int offset.
 If the index is invalid, `ArgumentOutOfRangeException` is thrown. 
 You can get the corresponding row using `GetRowAt`.

 ## Parameters
  - `index` - Offset (integer) of the row key to be returned

 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetRowAt``1(System.Int32)">
<summary>
 Returns a row of the data frame that is located at the specified int offset.
 This does not use the row key and directly accesses the frame data. This method
 is generic and returns the result as a series containing values of the specified type. 
 To get heterogeneous series of type `ObjectSeries&lt;&apos;TCol&gt;`, use the `frame.Rows` property.
 If the index is invalid, `ArgumentOutOfRangeException` is thrown. You can get the 
 matching key at a specified index using `GetRowKeyAt`.

 ## Parameters
  - `index` - Offset (integer) of the row to be returned

 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetRow``1(`0,Deedle.Lookup)">
<summary>
 Returns a row with the specieifed key. This method is generic and returns the result 
 as a series containing values of the specified type. To get heterogeneous series of 
 type `ObjectSeries&lt;&apos;TCol&gt;`, use the `frame.Rows` property.

 ## Parameters
  - `rowKey` - Specifies the key of the row to be returned
  - `lookup` - Specifies how to find value in a frame with ordered rows when the key does 
               not exactly match (look for nearest available value with the smaller/greater key).

 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetRow``1(`0)">
<summary>
 Returns a row with the specieifed key. This method is generic and returns the result 
 as a series containing values of the specified type. To get heterogeneous series of 
 type `ObjectSeries&lt;&apos;TCol&gt;`, use the `frame.Rows` property.

 ## Parameters
  - `rowKey` - Specifies the key of the row to be returned

 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetFrameData">
<summary>
 [category:Formatting and raw data access]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetColumns``1">
<summary>
 [category:Fancy accessors]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetColumnAt``1(System.Int32)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetColumn``1(`1)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetColumn``1(`1,Deedle.Lookup)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetAllValues``1(Deedle.ConversionKind)">
<summary>
 [category:Fancy accessors]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetAllValues``1">
<summary>
 [category:Fancy accessors]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetAllColumns``1(Deedle.ConversionKind)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetAllColumns``1">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetAddressRange(Deedle.RangeRestriction{System.Int64})">
<summary>
 Internal helper used by `skip`, `take`, etc.
</summary>
</member>
<member name="M:Deedle.Frame`2.Format(System.Int32,System.Int32,System.Boolean)">
<summary>
 Shows the data frame content in a human-readable format. The resulting string
 shows all columns, but a limited number of rows.

 ## Parameters
  - `startCount` - The number of rows at the beginning to be printed
  - `endCount` - The number of rows at the end of the frame to be printed
  - `printTypes` - When true, the types of vectors storing column data are printed

 [category:Formatting and raw data access]
</summary>
</member>
<member name="M:Deedle.Frame`2.Format(System.Int32,System.Int32)">
<summary>
 Shows the data frame content in a human-readable format. The resulting string
 shows all columns, but a limited number of rows.

 ## Parameters
  - `startCount` - The number of rows at the beginning to be printed
  - `endCount` - The number of rows at the end of the frame to be printed

 [category:Formatting and raw data access]
</summary>
</member>
<member name="M:Deedle.Frame`2.Format(System.Int32)">
<summary>
 Shows the data frame content in a human-readable format. The resulting string
 shows all columns, but a limited number of rows.

 ## Parameters
  - `count` - The maximal total number of rows to be printed

 [category:Formatting and raw data access]
</summary>
</member>
<member name="M:Deedle.Frame`2.Format(System.Boolean)">
<summary>
 Shows the data frame content in a human-readable format. The resulting string
 shows all columns, but a limited number of rows. 

 ## Parameters
  - `startCount` - The number of rows at the beginning to be printed
  - `endCount` - The number of rows at the end of the frame to be printed
  - `printTypes` - When true, the types of vectors storing column data are printed
 [category:Formatting and raw data access]
</summary>
</member>
<member name="M:Deedle.Frame`2.Format">
<summary>
 Shows the data frame content in a human-readable format. The resulting string
 shows all columns, but a limited number of rows. 
 [category:Formatting and raw data access]
</summary>
</member>
<member name="M:Deedle.Frame`2.Floor(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Exp(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.DropColumn(`1)">
<summary>
 Mutates the data frame by removing the specified series from the 
 frame columns. The operation throws if the column key is not found.

 ## Parameters
  - `column` - The key (or name) to be dropped from the frame
  - `frame` - Source data frame (which is not mutated by the operation)

 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.Cosh(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Cos(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.ColumnApply``1(Deedle.ConversionKind,System.Func{Deedle.Series{`0,``0},Deedle.ISeries{`0}})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.Frame`2.ColumnApply``1(System.Func{Deedle.Series{`0,``0},Deedle.ISeries{`0}})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.Frame`2.Ceiling(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Atan(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Asin(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.AggregateRowsBy``2(System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`1},System.Func{Deedle.Series{`0,``0},``1})">
<summary>
 Returns a data frame whose rows are grouped by `groupBy` and whose columns specified
 in `aggBy` are aggregated according to `aggFunc`.

 ## Parameters
  - `groupBy` - sequence of columns to group by
  - `aggBy` - sequence of columns to apply aggFunc to
  - `aggFunc` - invoked in order to aggregate values

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.Frame`2.AddColumn``1(`1,Deedle.ISeries{`0},Deedle.Lookup)">
<summary>
 Mutates the data frame by adding an additional data series
 as a new column with the specified column key. The operation 
 uses left join and aligns new series to the existing frame keys.
 A parameter `lookup` can be used to specify how to find a value in the
 added series (if an exact key is not available). The `lookup` parameter
 can only be used with ordered indices.

 ## Parameters
  - `series` - A data series to be added (the row key type has to match)
  - `column` - A key (or name) for the newly added column
  - `lookup` - Specify how to find value in the added series (look for 
    nearest available value with the smaller/greater key).

 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.AddColumn``1(`1,System.Collections.Generic.IEnumerable{``0},Deedle.Lookup)">
<summary>
 Mutates the data frame by adding an additional data series
 as a new column with the specified column key. The sequence is
 aligned to the data frame based on ordering. If it is longer, it is
 trimmed and if it is shorter, missing values will be added.
 A parameter `lookup` can be used to specify how to find a value in the
 added series (if the sequence contains invalid values like `null` or `NaN`). 

 ## Parameters
  - `column` - A key (or name) for the newly added column
  - `series` - A sequence of values to be added
  - `lookup` - Specify how to find value in the added series (look for 
    nearest available value with the smaller/greater key).

 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.AddColumn(`1,Deedle.ISeries{`0})">
<summary>
 Mutates the data frame by adding an additional data series
 as a new column with the specified column key. The operation 
 uses left join and aligns new series to the existing frame keys.

 ## Parameters
  - `series` - A data series to be added (the row key type has to match)
  - `column` - A key (or name) for the newly added column

 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.AddColumn``1(`1,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Mutates the data frame by adding an additional data series
 as a new column with the specified column key. The sequence is
 aligned to the data frame based on ordering. If it is longer, it is
 trimmed and if it is shorter, missing values will be added.

 ## Parameters
  - `column` - A key (or name) for the newly added column
  - `series` - A sequence of values to be added

 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.Acos(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Abs(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="T:Deedle.Frame`2">
<summary>
 A frame is the key Deedle data structure (together with series). It represents a 
 data table (think spreadsheet or CSV file) with multiple rows and columns. The frame 
 consists of row index, column index and data. The indices are used for efficient 
 lookup when accessing data by the row key `&apos;TRowKey` or by the column key 
 `&apos;TColumnKey`. Deedle frames are optimized for the scenario when all values in a given 
 column are of the same type (but types of different columns can differ).

 ## Joining, zipping and appending
 More info


 [category:Core frame and series types]
</summary>
</member>
<member name="M:Deedle.ICustomLookup`1.Matches(`0)">
<summary>
 Tests whether a specified key matches the current key (for example, in hierarchical indexing
 based on tuples, if the current key represents a pair (1, _) then the value (1, 42) would match).
</summary>
</member>
<member name="T:Deedle.ICustomLookup`1">
<summary>
 Represents a special lookup. This can be used to support hierarchical or duplicate keys
 in an index. A key type `K` can come with associated `ICustomLookup&lt;K&gt;` to provide 
 customized pattern matching (equality testing) 

 [category:Parameters and results of various operations]
</summary>
</member>
<member name="M:Deedle.IFrame.Apply``1(Deedle.IFrameOperation{``0})">
<summary>
 Calls the `Invoke` method of the specified interface `IFrameOperation&lt;&apos;V&gt;`
 with the typed data frame as an argument
</summary>
</member>
<member name="T:Deedle.IFrame">
<summary>
 An empty interface that is implemented by `Frame&lt;&apos;R, &apos;C&gt;`. The purpose of the
 interface is to allow writing code that works on arbitrary data frames (you 
 need to provide an implementation of the `IFrameOperation&lt;&apos;V&gt;` which contains
 a generic method `Invoke` that will be called with the typed data frame).

 [category:Specialized frame and series types]
</summary>
</member>
<member name="T:Deedle.IFrameOperation`1">
<summary>
 Represents an operation that can be invoked on `Frame&lt;&apos;R, &apos;C&gt;`. The operation
 is generic in the type of row and column keys.

 [category:Specialized frame and series types]
</summary>
</member>
<member name="T:Deedle.IRangeRestriction`1">
<summary>
 A sequence of indicies together with the total number. Use `RangeRestriction.ofSeq` to
 create one from a sequence. This can be implemented by concrete vector/index 
 builders to allow further optimizations (e.g. when the underlying source directly
 supports range operations). 

 For example, if your source has an optimised way for getting every 10th address, you 
 can create your own `IRangeRestriction` and then check for it in `LookupRange` and 
 use optimised implementation rather than actually iterating over the sequence of indices.
</summary>
</member>
<member name="P:Deedle.ISeries`1.VectorBuilder">
<summary>
 Returns the vector builder associated with this series
</summary>
</member>
<member name="P:Deedle.ISeries`1.Vector">
<summary>
 Returns the vector containing data of the series (as an untyped vector)
</summary>
</member>
<member name="P:Deedle.ISeries`1.Index">
<summary>
 Returns the index containing keys of the series 
</summary>
</member>
<member name="M:Deedle.ISeries`1.TryGetObject(`0)">
<summary>
 Attempts to get the value at a specified key and return it as `obj`
</summary>
</member>
<member name="T:Deedle.ISeries`1">
<summary>
 Represents an untyped series with keys of type `K` and values of some unknown type
 (This type should not generally be used directly, but it can be used when you need
 to write code that works on a sequence of series of heterogeneous types).

 [category:Core frame and series types]
</summary>
</member>
<member name="P:Deedle.IVector.SuppressPrinting">
<summary>
 When `true`, the formatter in F# Interactive will not attempt to evaluate the
 vector to print it. This is useful when the vector contains lazily loaded data.
</summary>
</member>
<member name="P:Deedle.IVector.ObjectSequence">
<summary>
 Returns all values of the vector as a sequence of optional objects
</summary>
</member>
<member name="P:Deedle.IVector.Length">
<summary>
 Returns the number of elements in the vector
</summary>
</member>
<member name="P:Deedle.IVector.ElementType">
<summary>
 Returns the type of elements stored in the current vector as `System.Type`.
 This member is mainly used for internal purposes (to invoke a generic function
 represented by `VectorCallSite1&lt;R&gt;` with the typed version of the current 
 vector as an argument.
</summary>
</member>
<member name="P:Deedle.IVector.AddressingScheme">
<summary>
 Returns the addressing scheme of the index. When creating a series or a frame
 this is compared for equality with the addressing scheme of the vector(s).
</summary>
</member>
<member name="M:Deedle.IVector.Invoke``1(Deedle.VectorCallSite{``0})">
<summary>
 Invokes the specified generic function (vector call site) with the current 
 instance of vector passed as a statically typed vector (ie. IVector&lt;ElementType&gt;)
</summary>
</member>
<member name="M:Deedle.IVector.GetObject(System.Int64)">
<summary>
 Return value stored in the vector at a specified address. This is simply an
 untyped version of `GetValue` method on a typed vector.
</summary>
</member>
<member name="T:Deedle.IVector">
<summary>
 Represents an (untyped) vector that stores some values and provides access
 to the values via a generic address. This type should be only used directly when
 extending the DataFrame library and adding a new way of storing or loading data.
 To allow invocation via Reflection, the vector exposes type of elements as `System.Type`.

 [category:Vectors and indices]
</summary>
</member>
<member name="P:Deedle.IVectorLocation.Offset">
<summary>
 Returns the offset of the location (this may involve some calculation)
</summary>
</member>
<member name="P:Deedle.IVectorLocation.Address">
<summary>
 Returns the address of the location (this should be immediate) 
</summary>
</member>
<member name="T:Deedle.IVectorLocation">
<summary>
 Represents a location in a vector. In general, we always know the address, but 
 sometimes (BigDeedle) it is hard to get the offset (requires some data lookups),
 so we use this interface to delay the calculation of the Offset (which is mainly
 needed in one of the `series.Select` overloads)

 [category:Vectors and indices]
</summary>
</member>
<member name="P:Deedle.IVector`1.Data">
<summary>
 Returns all data of the vector in one of the supported formats. Depending
 on the vector, data may be returned as a continuous block of memory using
 `ReadOnlyCollection&lt;T&gt;` or as a lazy sequence `seq&lt;T&gt;`.
</summary>
</member>
<member name="M:Deedle.IVector`1.Select``1(Microsoft.FSharp.Core.FSharpFunc{Deedle.IVectorLocation,Microsoft.FSharp.Core.FSharpFunc{Deedle.OptionalValue{`0},Deedle.OptionalValue{``0}}})">
<summary>
 Apply the specified function to all values stored in the vector and return
 a new vector (not necessarily of the same representation) with the results.
 The function handles missing values - it is called with optional values and
 may return a missing value as a result of the transformation.
</summary>
</member>
<member name="M:Deedle.IVector`1.GetValueAtLocation(Deedle.IVectorLocation)">
<summary>
 Returns value stored in the vector at a specified location. 
 This can typically just call &apos;GetValue(loc.Address)&apos;, but it can do something
 more clever using the fact that the caller provided us with the address &amp; offset.
</summary>
</member>
<member name="M:Deedle.IVector`1.GetValue(System.Int64)">
<summary>
 Returns value stored in the vector at a specified address. 
</summary>
</member>
<member name="M:Deedle.IVector`1.Convert``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0},Microsoft.FSharp.Core.FSharpFunc{``0,`0})">
<summary>
 Create a vector whose values are converted using the specified function, but
 can be converted back using another specified function. For virtualized vectors,
 this enables e.g. efficient lookup on the returned vectors (by delegating the
 lookup to the original source)
</summary>
</member>
<member name="T:Deedle.IVector`1">
<summary>
 A generic, typed vector. Represents mapping from addresses to values of type `T`. 
 The vector provides a minimal interface that is required by series and can be
 implemented in a number of ways to provide vector backed by database or an
 alternative representation of data.

 [category:Vectors and indices]
</summary>
</member>
<member name="M:Deedle.Index.CreateUnordered``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Create an index from a sequence of keys and assume they are not sorted
 (the resulting index is also not sorted).
</summary>
</member>
<member name="M:Deedle.Index.Create``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Create an index from a sequence of keys and check if they are sorted or not
</summary>
</member>
<member name="T:Deedle.Index">
<summary>
 Type that provides access to creating indices (represented as `LinearIndex` values)

 [category:Vectors and indices]
</summary>
</member>
<member name="F:Deedle.JoinKind.Right">
<summary>
 Take the keys of the right (second) structure and align values from the left (first)
 structure with the keys of the second one. Values for keys not available in the first
 structure will be missing.
</summary>
</member>
<member name="F:Deedle.JoinKind.Left">
<summary>
 Take the keys of the left (first) structure and align values from the right (second)
 structure with the keys of the first one. Values for keys not available in the second
 structure will be missing.
</summary>
</member>
<member name="F:Deedle.JoinKind.Inner">
<summary>
 Take the intersection of the keys available in both structures and align the 
 values of the two structures. The resulting structure cannot contain missing values.
</summary>
</member>
<member name="F:Deedle.JoinKind.Outer">
<summary>
 Combine the keys available in both structures, align the values that
 are available in both of them and mark the remaining values as missing.
</summary>
</member>
<member name="T:Deedle.JoinKind">
<summary>
 This enumeration specifies joining behavior for `Join` method provided
 by `Series` and `Frame`. Outer join unions the keys (and may introduce
 missing values), inner join takes the intersection of keys; left and
 right joins take the keys of the first or the second series/frame.

 [category:Parameters and results of various operations]
</summary>
</member>
<member name="T:Deedle.KeyValue">
<summary>
 A type with extension method for `KeyValuePair&lt;&apos;K, &apos;V&gt;` that makes
 it possible to create values using just `KeyValue.Create`.

 [category:Primitive types and values]
</summary>
</member>
<member name="F:Deedle.Lookup.Smaller">
<summary>
 Lookup a value associated with a key that is smaller than the specified one.
 Fails (or returns missing value) when the specified key is smaller or equal
 to the smallest available key.
</summary>
</member>
<member name="F:Deedle.Lookup.Greater">
<summary>
 Lookup a value associated with a key that is greater than the specified one.
 Fails (or returns missing value) when the specified key is greater or equal
 to the greatest available key.
</summary>
</member>
<member name="F:Deedle.Lookup.ExactOrSmaller">
<summary>
 Lookup a value associated with the specified key or with the nearest
 smaller key that has a value available. Fails (or returns missing value)
 only when the specified key is smaller than all available keys.
</summary>
</member>
<member name="F:Deedle.Lookup.ExactOrGreater">
<summary>
 Lookup a value associated with the specified key or with the nearest
 greater key that has a value available. Fails (or returns missing value)
 only when the specified key is greater than all available keys.
</summary>
</member>
<member name="F:Deedle.Lookup.Exact">
<summary>
 Lookup a value associated with the exact specified key. 
 If the key is not available, then fail or return missing value. 
</summary>
</member>
<member name="T:Deedle.Lookup">
<summary>
 Represents different behaviors of key lookup in series. For unordered series,
 the only available option is `Lookup.Exact` which finds the exact key - methods
 fail or return missing value if the key is not available in the index. For ordered
 series `Lookup.Greater` finds the first greater key (e.g. later date) with
 a value. `Lookup.Smaller` searches for the first smaller key. The options
 `Lookup.ExactOrGreater` and `Lookup.ExactOrSmaller` finds the exact key (if it is
 present) and otherwise search for the nearest larger or smaller key, respectively.

 [category:Parameters and results of various operations]
</summary>
</member>
<member name="P:Deedle.MissingValueException.Key">
<summary>
 The key that has been accessed
</summary>
</member>
<member name="T:Deedle.MissingValueException">
<summary>
 Thrown when a value at the specified index does not exist in the data frame or series.
 This exception is thrown only when the key is defined, but the value is not available,
 in other situations `KeyNotFoundException` is thrown

 [category:Primitive types and values]
</summary>
</member>
<member name="T:Deedle.ObjectSeries`1">
<summary>
 Represents a series containing boxed values. This type is inherited from `Series&lt;&apos;K, obj&gt;` 
 and it adds additional operations for accessing values with unboxing. This includes operations
 such as `os.GetAs&lt;&apos;T&gt;`, `os.TryGetAs&lt;&apos;T&gt;` and `os.TryAs&lt;&apos;T&gt;` which (attempt to) convert
 values to the specified type `&apos;T`.

 [category:Specialized frame and series types]
</summary>
</member>
<member name="M:Deedle.OptionalValue.OfNullable``1(System.Nullable{``0})">
<summary>
 Creates an `OptionalValue&lt;T&gt;` from a nullable value of type `T?`
</summary>
</member>
<member name="M:Deedle.OptionalValue.Empty``1">
<summary>
 Creates an `OptionalValue&lt;&apos;T&gt;` that does not contain a value
</summary>
</member>
<member name="M:Deedle.OptionalValue.Create``1(``0)">
<summary>
 Creates an `OptionalValue&lt;&apos;T&gt;` that contains a value `v`
</summary>
</member>
<member name="T:Deedle.OptionalValue">
<summary>
 Non-generic type that makes it easier to create `OptionalValue&lt;T&gt;` values
 from C# by benefiting the type inference for generic method invocations.

 [category:Primitive types and values]
</summary>
</member>
<member name="M:Deedle.OptionalValueExtensions.OrDefault``1(Deedle.OptionalValue{``0},``0)">
<summary>
 Extension method that returns value in the specified optional value
 or the provided default value (the second argument).
</summary>
</member>
<member name="M:Deedle.OptionalValueExtensions.AsNullable``1(Deedle.OptionalValue{``0})">
<summary>
 Extension method that converts optional value containing a value type
 to a C# friendly `Nullable&lt;T&gt;` or `T?` type.
</summary>
</member>
<member name="T:Deedle.OptionalValueExtensions">
<summary>
 Extension methods for working with optional values from C#. These make
 it easier to provide default values and convert optional values to 
 `Nullable` (when the contained value is value type)

 [category:Primitive types and values]
</summary>
</member>
<member name="P:Deedle.OptionalValue`1.ValueOrDefault">
<summary>
 Returns the value stored in the current `OptionalValue&lt;T&gt;` or 
 the default value of the type `T` when a value is not present.
</summary>
</member>
<member name="P:Deedle.OptionalValue`1.Value">
<summary>
 Returns the value stored in the current `OptionalValue&lt;T&gt;`. 
 Exceptions:
   `InvalidOperationException` - Thrown when `HasValue` is `false`.
</summary>
</member>
<member name="P:Deedle.OptionalValue`1.Missing">
<summary>
 Returns a new instance of `OptionalValue&lt;T&gt;` that does not contain a value.
</summary>
</member>
<member name="P:Deedle.OptionalValue`1.HasValue">
<summary>
 Gets a value indicating whether the current `OptionalValue&lt;T&gt;` has a value
</summary>
</member>
<member name="M:Deedle.OptionalValue`1.ToString">
<summary>
 Prints the value or &quot;&lt;null&gt;&quot; when the value is present, but is `null`
 or &quot;&lt;missing&gt;&quot; when the value is not present (`HasValue = false`).
</summary>
</member>
<member name="M:Deedle.OptionalValue`1.GetHashCode">
<summary>
 Support structural equality      
</summary>
</member>
<member name="M:Deedle.OptionalValue`1.Equals(System.Object)">
<summary>
 Support structural equality      
</summary>
</member>
<member name="M:Deedle.OptionalValue`1.#ctor(`0)">
<summary>
 Creates a new instance of `OptionalValue&lt;T&gt;` that contains  
 the specified `T` value .
</summary>
</member>
<member name="T:Deedle.OptionalValue`1">
<summary>
 Value type that represents a potentially missing value. This is similar to 
 `System.Nullable&lt;T&gt;`, but does not restrict the contained value to be a value
 type, so it can be used for storing values of any types. When obtained from
 `DataFrame&lt;R, C&gt;` or `Series&lt;K, T&gt;`, the `Value` will never be `Double.NaN` or `null`
 (but this is not, in general, checked when constructing the value).

 The type is only used in C#-friendly API. F# operations generally use expose
 standard F# `option&lt;T&gt;` type instead. However, there the `OptionalValue` module
 contains helper functions for using this type from F# as well as `Missing` and
 `Present` active patterns.

 [category:Primitive types and values]
</summary>
</member>
<member name="T:Deedle.RangeRestriction`1.Custom">
<summary>
 Custom range, which is a sequence of indices, or other representation of it
</summary>
</member>
<member name="T:Deedle.RangeRestriction`1.End">
<summary>
 Range referring to the specified number of elements from the end
</summary>
</member>
<member name="T:Deedle.RangeRestriction`1.Start">
<summary>
 Range referring to the specified number of elements from the start
</summary>
</member>
<member name="T:Deedle.RangeRestriction`1.Fixed">
<summary>
 Range specified as a pair of (inclusive) lower and upper addresses
</summary>
</member>
<member name="T:Deedle.RangeRestriction`1">
<summary>
 Specifies a sub-range within index that can be accessed via slicing
 (see the `GetAddressRange` method). For in-memory data structures, accessing
 range via known addresses is typically sufficient, but for virtual Big Deedle
 sources, `Start` and `End` let us avoid fully evaluating addresses.
 `Custom` range can be used for optimizations.
</summary>
</member>
<member name="M:Deedle.RowSeries`2.FromSeries(Deedle.Series{`0,Deedle.ObjectSeries{`1}})">
<summary>
 Creates a `RowSeries` from a filtered series
 (and implements slicing in terms of the specified series)  
</summary>
</member>
<member name="T:Deedle.RowSeries`2">
<summary>
 Represents a series of rows from a frame. The type inherits from a series of 
 series representing individual rows (`Series&lt;&apos;TRowKey, ObjectSeries&lt;&apos;TColumnKey&gt;&gt;`) but
 hides slicing operations with new versions that return frames.

 [category:Specialized frame and series types]
</summary>
</member>
<member name="T:Deedle.SeriesBuilder`1">
<summary>
 A simple class that inherits from `SeriesBuilder&lt;&apos;K, obj&gt;` and can be
 used instead of writing `SeriesBuilder&lt;&apos;K, obj&gt;` with two type arguments.

 [category:Specialized frame and series types]
</summary>
</member>
<member name="P:Deedle.SeriesBuilder`2.Series">
<summary>
 Returns the constructed series. The series is an immutable
 copy of the current values and so further additions will not
 change the returned series.
</summary>
</member>
<member name="M:Deedle.SeriesBuilder`2.Add(`0,`1)">
<summary>
 Add specified key and value to the series being build
</summary>
</member>
<member name="T:Deedle.SeriesBuilder`2">
<summary>
 The type can be used for creating series using mutation. You can add 
 items using `Add` and get the resulting series using the `Series` property.

 ## Using from C#

 The type supports the C# collection builder pattern:

    	var s = new SeriesBuilder&lt;string, double&gt;
       { { &quot;A&quot;, 1.0 }, { &quot;B&quot;, 2.0 }, { &quot;C&quot;, 3.0 } }.Series;

 The type also supports the `dynamic` operator:

     dynamic sb = new SeriesBuilder&lt;string, obj&gt;();
     sb.ID = 1;
     sb.Value = 3.4;

 [category:Specialized frame and series types]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.SortByKey``2(Deedle.Series{``0,``1})">
<summary>
 Returns a new series whose entries are reordered according to index order

 ## Parameters
  - `series` - An input series to be used

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Shift``2(Deedle.Series{``0,``1},System.Int32)">
<summary>
 Returns a series with values shifted by the specified offset. When the offset is 
 positive, the values are shifted forward and first `offset` keys are dropped. When the
 offset is negative, the values are shifted backwards and the last `offset` keys are dropped.
 Expressed in pseudo-code:

     result[k] = series[k - offset]

 ## Parameters
  - `offset` - Can be both positive and negative number.
  - `series` - The input series to be shifted.

 ## Remarks
 If you want to calculate the difference, e.g. `s - (Series.shift 1 s)`, you can
 use `Series.diff` which will be a little bit faster.
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.SampleInto``1(Deedle.Series{System.DateTimeOffset,``0},System.TimeSpan,Deedle.Direction,System.Func{System.DateTimeOffset,Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{System.DateTimeOffset,``0},System.Object}})">
<summary>
 Performs sampling by time and aggregates chunks obtained by time-sampling into a single
 value using a specified function. The operation generates keys starting at the first
 key in the source series, using the specified `interval` and then obtains chunks based on 
 these keys in a fashion similar to the `Series.resample` function.

 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.
  - `aggregate` - A function that is called to aggregate each chunk into a single value.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.SampleInto``1(Deedle.Series{System.DateTime,``0},System.TimeSpan,Deedle.Direction,System.Func{System.DateTime,Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{System.DateTime,``0},System.Object}})">
<summary>
 Performs sampling by time and aggregates chunks obtained by time-sampling into a single
 value using a specified function. The operation generates keys starting at the first
 key in the source series, using the specified `interval` and then obtains chunks based on 
 these keys in a fashion similar to the `Series.resample` function.

 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.
  - `aggregate` - A function that is called to aggregate each chunk into a single value.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Sample``1(Deedle.Series{System.DateTimeOffset,``0},System.TimeSpan)">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting from the smallest key of the original series, using the specified `interval`
 and then finds nearest smaller values close to such keys. The function generates samples
 at, or just before the end of an interval and at, or after, the end of the series.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Sample``1(Deedle.Series{System.DateTime,``0},System.TimeSpan)">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting from the smallest key of the original series, using the specified `interval`
 and then finds nearest smaller values close to such keys. The function generates samples
 at, or just before the end of an interval and at, or after, the end of the series.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Sample``1(Deedle.Series{System.DateTimeOffset,``0},System.TimeSpan,Deedle.Direction)">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting from the smallest key of the original series, using the specified `interval`
 and then finds nearest smaller values close to such keys according to `dir`.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
  - `dir` - Specifies how the keys should be generated. `Direction.Forward` means that the 
    key is the smallest value of each chunk (and so first key of the series is returned and 
    the last is not, unless it matches exactly _start + k*interval_); `Direction.Backward`
    means that the first key is skipped and sample is generated at, or just before the end 
    of interval and at the end of the series.
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Sample``1(Deedle.Series{System.DateTime,``0},System.TimeSpan,Deedle.Direction)">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting from the smallest key of the original series, using the specified `interval`
 and then finds nearest smaller values close to such keys according to `dir`.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
  - `lookup` - Specifies how the lookup based on keys is performed. `Exact` means that the
    values at exact keys will be returned; `NearestGreater` returns the nearest greater key value
    (starting at the first key) and `NearestSmaller` returns the nearest smaller key value
    (starting at most `interval` after the end of the series)
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Sample``1(Deedle.Series{System.DateTimeOffset,``0},System.DateTimeOffset,System.TimeSpan,Deedle.Direction)">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting at the specified `start` time, using the specified `interval`
 and then finds nearest smaller values close to such keys according to `dir`.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `start` - The initial time to be used for sampling
  - `interval` - The interval between the individual samples 
  - `lookup` - Specifies how the lookup based on keys is performed. `Exact` means that the
    values at exact keys will be returned; `NearestGreater` returns the nearest greater key value
    (starting at the first key) and `NearestSmaller` returns the nearest smaller key value
    (starting at most `interval` after the end of the series)
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Sample``1(Deedle.Series{System.DateTime,``0},System.DateTime,System.TimeSpan,Deedle.Direction)">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting at the specified `start` time, using the specified `interval`
 and then finds nearest smaller values close to such keys according to `dir`.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `start` - The initial time to be used for sampling
  - `interval` - The interval between the individual samples 
  - `lookup` - Specifies how the lookup based on keys is performed. `Exact` means that the
    values at exact keys will be returned; `NearestGreater` returns the nearest greater key value
    (starting at the first key) and `NearestSmaller` returns the nearest smaller key value
    (starting at most `interval` after the end of the series)
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Sample``2(Deedle.Series{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Sample an (ordered) series by finding the value at the exact or closest prior key 
 for some new sequence of keys. 
 
 ## Parameters
  - `series` - An input series to be sampled
  - `keys`   - The keys at which to sample
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered.
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.ResampleUniform``3(Deedle.Series{``0,``1},System.Func{``0,``2},System.Func{``2,``2},Deedle.Lookup)">
<summary>
 Resample the series based on equivalence class on the keys and also generate values 
 for all keys of the target space that are between the minimal and maximal key of the
 specified series (e.g. generate value for all days in the range covered by the series).
 A specified function `keyProj` is used to project keys to another space and `nextKey`
 is used to generate all keys in the range. The last value of each chunk is returned.

 When there are no values for a (generated) key, then the function attempts to get the
 greatest value from the previous smaller chunk (i.e. value for the previous date time).

 ## Parameters
  - `series` - An input series to be resampled
  - `fillMode` - When set to `Lookup.NearestSmaller` or `Lookup.NearestGreater`, 
     the function searches for a nearest available observation in an neighboring chunk.
     Otherwise, the function `f` is called with an empty series as an argument.
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)
  - `nextKey` - A function that gets the next key in the transformed space
    
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.ResampleUniform``3(Deedle.Series{``0,``1},System.Func{``0,``2},System.Func{``2,``2})">
<summary>
 Resample the series based on equivalence class on the keys and also generate values 
 for all keys of the target space that are between the minimal and maximal key of the
 specified series (e.g. generate value for all days in the range covered by the series).
 For each equivalence class (e.g. date), select the latest value (with greatest key).
 A specified function `keyProj` is used to project keys to another space and `nextKey`
 is used to generate all keys in the range. 

 When there are no values for a (generated) key, then the function attempts to get the
 greatest value from the previous smaller chunk (i.e. value for the previous date time).

 ## Parameters
  - `series` - An input series to be resampled
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)
  - `nextKey` - A function that gets the next key in the transformed space
    
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.ResampleEquivalence``4(Deedle.Series{``0,``1},System.Func{``0,``2},System.Func{Deedle.Series{``0,``1},``3})">
<summary>
 Resample the series based on equivalence class on the keys. A specified function
 `keyProj` is used to project keys to another space and the observations for which the 
 projected keys are equivalent are grouped into chunks. The chunks are then transformed
 to values using the provided function `f`.

 ## Parameters
  - `series` - An input series to be resampled
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)
  - `aggregate` - A function that is used to collapse a generated chunk into a 
    single value. 

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. For unordered
 series, similar functionality can be implemented using `GroupBy`.
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.ResampleEquivalence``3(Deedle.Series{``0,``1},System.Func{``0,``2})">
<summary>
 Resample the series based on equivalence class on the keys. A specified function
 `keyProj` is used to project keys to another space and the observations for which the 
 projected keys are equivalent are grouped into chunks. The chunks are then returned
 as nested series.

 ## Parameters
  - `series` - An input series to be resampled
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. For unordered
 series, similar functionality can be implemented using `GroupBy`.
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.GetObservations``2(Deedle.Series{``0,``1})">
<summary>
 Return observations with available values. The operation skips over 
 all keys with missing values (such as values created from `null`,
 `Double.NaN`, or those that are missing due to outer join etc.).
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.GetAllValues``2(Deedle.Series{``0,``1})">
<summary>
 Returns all (optional) values. The values are returned using the 
 `OptionalValue&lt;T&gt;` struct which provides `HasValue` for testing 
 if the value is available.
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.GetAllObservations``2(Deedle.Series{``0,``1})">
<summary>
 Returns all keys from the sequence, together with the associated (optional)
 values. The values are returned using the `OptionalValue&lt;T&gt;` struct which
 provides `HasValue` for testing if the value is available.
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Flatten``2(Deedle.Series{``0,Deedle.OptionalValue{``1}})">
<summary>
 Collapses a series of OptionalValue&lt;&apos;T&gt; values to just &apos;T values
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.FillMissing``2(Deedle.Series{``0,``1},System.Func{``0,``1})">
<summary>
 Fill missing values in the series using the specified function.
 The specified function is called with all keys for which the series
 does not contain value and the result of the call is used in place 
 of the missing value. 

 ## Parameters
  - `series` - An input series that is to be filled
  - `filler` - A function that takes key `K` and generates a value to be
    used in a place where the original series contains a missing value.

 ## Remarks
 This function can be used to implement more complex interpolation.
 For example see [handling missing values in the tutorial](../frame.html#missing)

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.FillMissing``2(Deedle.Series{``0,``1},Deedle.Direction)">
<summary>
 Fill missing values in the series with the nearest available value
 (using the specified direction). The default direction is `Direction.Backward`.
 Note that the series may still contain missing values after call to this 
 function. This operation can only be used on ordered series. 

 ## Example

     let sample = Series.ofValues [ Double.NaN; 1.0; Double.NaN; 3.0 ]

     // Returns a series consisting of [1; 1; 3; 3]
     sample.FillMissing(Direction.Backward)

     // Returns a series consisting of [&lt;missing&gt;; 1; 1; 3]
     sample.FillMissing(Direction.Forward)

 ## Parameters
  - `direction` - Specifies the direction used when searching for 
    the nearest available value. `Backward` means that we want to
    look for the first value with a smaller key while `Forward` searches
    for the nearest greater key.

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.FillMissing``2(Deedle.Series{``0,``1},``1)">
<summary>
 Fill missing values in the series with a constant value.

 ## Parameters
  - `series` - An input series that is to be filled
  - `value` - A constant value that is used to fill all missing values

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.DropMissing``2(Deedle.Series{``0,``1})">
<summary>
 Drop missing values from the specified series. The returned series contains 
 only those keys for which there is a value available in the original one.

 ## Parameters
  - `series` - An input series to be filtered

 ## Example

     let s = series [ 1 =&gt; 1.0; 2 =&gt; Double.NaN ]
     s.DropMissing()
     [fsi:val it : Series&lt;int,float&gt; = series [ 1 =&gt; 1]

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Diff``1(Deedle.Series{``0,System.Int32},System.Int32)">
<summary>
 Returns a series containing difference between a value in the original series and 
 a value at the specified offset. For example, calling `Series.diff 1 s` returns a 
 series where previous value is subtracted from the current one. 

 ## Parameters
  - `offset` - When positive, subtracts the past values from the current values;
    when negative, subtracts the future values from the current values.
  - `series` - The input series.

</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Diff``1(Deedle.Series{``0,System.Decimal},System.Int32)">
<summary>
 Returns a series containing difference between a value in the original series and 
 a value at the specified offset. For example, calling `Series.diff 1 s` returns a 
 series where previous value is subtracted from the current one. 

 ## Parameters
  - `offset` - When positive, subtracts the past values from the current values;
    when negative, subtracts the future values from the current values.
  - `series` - The input series.

</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Diff``1(Deedle.Series{``0,System.Single},System.Int32)">
<summary>
 Returns a series containing difference between a value in the original series and 
 a value at the specified offset. For example, calling `Series.diff 1 s` returns a 
 series where previous value is subtracted from the current one. 

 ## Parameters
  - `offset` - When positive, subtracts the past values from the current values;
    when negative, subtracts the future values from the current values.
  - `series` - The input series.

</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Diff``1(Deedle.Series{``0,System.Double},System.Int32)">
<summary>
 Returns a series containing difference between a value in the original series and 
 a value at the specified offset. For example, calling `Series.diff 1 s` returns a 
 series where previous value is subtracted from the current one. 

 ## Parameters
  - `offset` - When positive, subtracts the past values from the current values;
    when negative, subtracts the future values from the current values.
  - `series` - The input series.

</summary>
</member>
<member name="T:Deedle.SeriesExtensions">
<summary>
 The type implements C# and F# extension methods for the `Series&lt;&apos;K, &apos;V&gt;` type.
 The members are automatically available when you import the `Deedle` namespace.
 The type contains object-oriented counterparts to most of the functionality 
 from the `Series` module.

 [category:Frame and series operations]
</summary>
</member>
<member name="M:Deedle.SeriesStatsExtensions.SumLevel``2(Deedle.Series{``0,System.Double},System.Func{``0,``1})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the sum of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the sums
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesStatsExtensions.Sum``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns the sum of the elements of the series of float values.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesStatsExtensions.StdDevLevel``2(Deedle.Series{``0,System.Double},System.Func{``0,``1})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the standard deviation of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the standard deviations
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesStatsExtensions.StdDev``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns the standard deviation of the elements of the series.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesStatsExtensions.Skewness``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns the skewness of the elements of the series.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesStatsExtensions.NumSum``2(Deedle.Series{``0,``1})">
<summary>
 Returns the sum of the elements of the series of numeric values.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesStatsExtensions.MinLevel``3(Deedle.Series{``0,``1},System.Func{``0,``2})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the smallest element of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the smallest elements
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesStatsExtensions.Min``2(Deedle.Series{``0,``1})">
<summary>
 Returns the smallest of all elements of the series.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesStatsExtensions.MedianLevel``2(Deedle.Series{``0,System.Double},System.Func{``0,``1})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the median of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the medians
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesStatsExtensions.Median``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns the median of the elements of the series.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesStatsExtensions.MeanLevel``2(Deedle.Series{``0,System.Double},System.Func{``0,``1})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the mean of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the means
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesStatsExtensions.Mean``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns the mean of the elements of the series.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesStatsExtensions.MaxLevel``3(Deedle.Series{``0,``1},System.Func{``0,``2})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the greatest element of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the greatest elements
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesStatsExtensions.Max``2(Deedle.Series{``0,``1})">
<summary>
 Returns the greatest of all elements of the series.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesStatsExtensions.Kurtosis``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns the kurtosis of the elements of the series.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesStatsExtensions.InterpolateLinear``1(Deedle.Series{``0,System.Double},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Double})">
<summary>
 Linearly interpolates an ordered series given a new sequence of keys. 

 ## Parameters
  - `keys` - Sequence of new keys that forms the index of interpolated results
  - `keyDiff` - A function representing &quot;subtraction&quot; between two keys

 [category:Calculations, aggregation and statistics]
</summary>
</member>
<member name="T:Deedle.SeriesStatsExtensions">
<summary>
 The type implements C# and F# extension methods that add numerical operations 
 to Deedle series. With a few exceptions, the methods are only available for 
 series containing floating-point values, that is `Series&lt;&apos;K, float&gt;`.

 [category:Frame and series operations]
</summary>
</member>
<member name="F:Deedle.Series`2.valueCount">
<summary>
 Value to hold the number of elements (so that we do not recalculate this all the time)
 (This is calculated on first access; we do not use Lazy&lt;T&gt; to avoid allocations)
</summary>
</member>
<member name="M:Deedle.Series`2.op_UnaryNegation(Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_UnaryNegation(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Subtraction(Deedle.Series{`0,System.Double},Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Subtraction(Deedle.Series{`0,System.Int32},Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Subtraction(Deedle.Series{`0,System.Double},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Subtraction(System.Double,Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Subtraction(Deedle.Series{`0,System.Int32},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Subtraction(System.Int32,Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Multiply(Deedle.Series{`0,System.Double},Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Multiply(Deedle.Series{`0,System.Int32},Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Multiply(Deedle.Series{`0,System.Double},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Multiply(System.Double,Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Multiply(Deedle.Series{`0,System.Int32},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Multiply(System.Int32,Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Dynamic``1(Deedle.Series{System.String,``0},System.String)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Dollar``1(Microsoft.FSharp.Core.FSharpFunc{`1,``0},Deedle.Series{`0,`1})">
<summary>
 Custom operator that can be used for applying a function to all elements of 
 a series. This provides a nicer syntactic sugar for the `Series.mapValues` 
 function. For example:

     // Given a float series and a function on floats
     let s1 = Series.ofValues [ 1.0 .. 10.0 ]
     let adjust v = max 10.0 v

     // Apply &quot;adjust (v + v)&quot; to all elements
     adjust $ (s1 + s1)

</summary>
</member>
<member name="M:Deedle.Series`2.op_Division(Deedle.Series{`0,System.Double},Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Division(Deedle.Series{`0,System.Int32},Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Division(Deedle.Series{`0,System.Double},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Division(System.Double,Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Division(Deedle.Series{`0,System.Int32},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Division(System.Int32,Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Addition(Deedle.Series{`0,System.Double},Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Addition(Deedle.Series{`0,System.Int32},Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Addition(Deedle.Series{`0,System.Double},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Addition(System.Double,Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Addition(Deedle.Series{`0,System.Int32},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Addition(System.Int32,Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="P:Deedle.Series`2.VectorBuilder">
<summary>
 Returns the vector builder associated with this series
</summary>
</member>
<member name="P:Deedle.Series`2.Vector">
<summary>
 Returns the vector associated with this series. This member should not generally
 be accessed directly, because all functionality is exposed through series operations.

 [category:Series data]
</summary>
</member>
<member name="P:Deedle.Series`2.ValuesAll">
<summary>
 Returns a collection of values, including possibly missing values. Note that 
 the length of this sequence matches the `Keys` sequence.

 [category:Series data]
</summary>
</member>
<member name="P:Deedle.Series`2.Values">
<summary>
 Returns a collection of values that are available in the series data.
 Note that the length of this sequence does not match the `Keys` sequence
 if there are missing values. To get matching sequence, use the `Observations`
 property or `Series.observation`.

 [category:Series data]
</summary>
</member>
<member name="P:Deedle.Series`2.ValueCount">
<summary>
 Returns the total number of values in the specified series. This excludes
 missing values or not available values (such as values created from `null`,
 `Double.NaN`, or those that are missing due to outer join etc.).

 [category:Series data]
</summary>
</member>
<member name="P:Deedle.Series`2.Reversed">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="P:Deedle.Series`2.ObservationsAll">
<summary>
 Returns a collection of observations that form this series. Note that this property
 includes all missing (or NaN) values. Observations are returned as 
 `KeyValuePair&lt;K, OptionalValue&lt;V&gt;&gt;` objects. For an F# alternative that uses tuples, 
 see `Series.observationsAll`.

 [category:Series data]
</summary>
</member>
<member name="P:Deedle.Series`2.Observations">
<summary>
 Returns a collection of observations that form this series. Note that this property
 skips over all missing (or NaN) values. Observations are returned as `KeyValuePair&lt;K, V&gt;` 
 objects. For an F# alternative that uses tuples, see `Series.observations`.

 [category:Series data]
</summary>
</member>
<member name="P:Deedle.Series`2.Keys">
<summary>
 Returns a collection of keys that are defined by the index of this series.
 Note that the length of this sequence does not match the `Values` sequence
 if there are missing values. To get matching sequence, use the `Observations`
 property or `Series.observation`.

 [category:Series data]
</summary>
</member>
<member name="P:Deedle.Series`2.KeyRange">
<summary>
 [category:Series data]
</summary>
</member>
<member name="P:Deedle.Series`2.KeyCount">
<summary>
 Returns the total number of keys in the specified series. This returns
 the total length of the series, including keys for which there is no 
 value available.

 [category:Series data]
</summary>
</member>
<member name="P:Deedle.Series`2.Item(Deedle.ICustomLookup{`0})">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:Deedle.Series`2.Item(System.Collections.Generic.IEnumerable{`0})">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:Deedle.Series`2.Item(`0)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:Deedle.Series`2.IsOrdered">
<summary>
 [category:Series data]
</summary>
</member>
<member name="P:Deedle.Series`2.IsEmpty">
<summary>
 [category:Series data]
</summary>
</member>
<member name="P:Deedle.Series`2.IndexBuilder">
<summary>
 Returns the index builder associated with this series
</summary>
</member>
<member name="P:Deedle.Series`2.Index">
<summary>
 Returns the index associated with this series. This member should not generally
 be accessed directly, because all functionality is exposed through series operations.

 [category:Series data]
</summary>
</member>
<member name="M:Deedle.Series`2.ZipInner``1(Deedle.Series{`0,``0})">
<summary>
 [category:Merging, joining and zipping]
</summary>
</member>
<member name="M:Deedle.Series`2.Zip``1(Deedle.Series{`0,``0},Deedle.JoinKind,Deedle.Lookup)">
<summary>
 [category:Merging, joining and zipping]
</summary>
</member>
<member name="M:Deedle.Series`2.Zip``1(Deedle.Series{`0,``0},Deedle.JoinKind)">
<summary>
 [category:Merging, joining and zipping]
</summary>
</member>
<member name="M:Deedle.Series`2.Zip``1(Deedle.Series{`0,``0})">
<summary>
 [category:Merging, joining and zipping]
</summary>
</member>
<member name="M:Deedle.Series`2.WithMissingFrom``1(Deedle.Series{`0,``0})">
<summary>
 Returns the current series with the same index but with values missing wherever the 
 corresponding key exists in the other series index with an associated missing value.

 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.Series`2.WhereOptional(System.Func{System.Collections.Generic.KeyValuePair{`0,Deedle.OptionalValue{`1}},System.Boolean})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.Series`2.Where(System.Func{System.Collections.Generic.KeyValuePair{`0,`1},System.Boolean})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.Series`2.Where(System.Func{System.Collections.Generic.KeyValuePair{`0,`1},System.Int32,System.Boolean})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.Series`2.TryGetObservation(`0)">
<summary>
 Attempts to get a value at the specified &apos;key&apos;

 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.TryGetObservation(`0,Deedle.Lookup)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.TryGetAt(System.Int32)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.TryGet(`0)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.TryGet(`0,Deedle.Lookup)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.Truncate(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Tanh(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Tan(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Sqrt(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Sinh(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Sin(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Sign(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.SelectValues``1(System.Func{`1,``0})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.Series`2.SelectOptional``1(System.Func{System.Collections.Generic.KeyValuePair{`0,Deedle.OptionalValue{`1}},Deedle.OptionalValue{``0}})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.Series`2.SelectKeys``1(System.Func{System.Collections.Generic.KeyValuePair{`0,Deedle.OptionalValue{`1}},``0})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.Series`2.Select``1(System.Func{System.Collections.Generic.KeyValuePair{`0,`1},``0})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.Series`2.Select``1(System.Func{System.Collections.Generic.KeyValuePair{`0,`1},System.Int32,``0})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.Series`2.ScanValues``1(System.Func{``0,`1,``0},``0)">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.Series`2.ScanAllValues``1(System.Func{Deedle.OptionalValue{``0},Deedle.OptionalValue{`1},Deedle.OptionalValue{``0}},Deedle.OptionalValue{``0})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.Series`2.Round(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Resample(System.Collections.Generic.IEnumerable{`0},Deedle.Direction)">
<summary>
 Resample the series based on a provided collection of keys. The values of the series
 are aggregated into chunks based on the specified keys. Depending on `direction`, the 
 specified key is either used as the smallest or as the greatest key of the chunk (with
 the exception of boundaries that are added to the first/last chunk). The chunks
 are then returned as a nested series. 

 ## Parameters
  - `keys` - A collection of keys to be used for resampling of the series
  - `direction` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered.

 [category:Resampling]
</summary>
</member>
<member name="M:Deedle.Series`2.Resample``1(System.Collections.Generic.IEnumerable{`0},Deedle.Direction,System.Func{`0,Deedle.Series{`0,`1},``0})">
<summary>
 Resample the series based on a provided collection of keys. The values of the series
 are aggregated into chunks based on the specified keys. Depending on `direction`, the 
 specified key is either used as the smallest or as the greatest key of the chunk (with
 the exception of boundaries that are added to the first/last chunk).

 Such chunks are then aggregated using the provided `valueSelector` and `keySelector`
 (an overload that does not take `keySelector` just selects the explicitly provided key).

 ## Parameters
  - `keys` - A collection of keys to be used for resampling of the series
  - `direction` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.
  - `valueSelector` - A function that is used to collapse a generated chunk into a 
    single value. Note that this function may be called with empty series.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered.

 [category:Resampling]
</summary>
</member>
<member name="M:Deedle.Series`2.Resample``2(System.Collections.Generic.IEnumerable{`0},Deedle.Direction,System.Func{``0,Deedle.Series{`0,`1},``1},System.Func{`0,Deedle.Series{`0,`1},``0})">
<summary>
 Resample the series based on a provided collection of keys. The values of the series
 are aggregated into chunks based on the specified keys. Depending on `direction`, the 
 specified key is either used as the smallest or as the greatest key of the chunk (with
 the exception of boundaries that are added to the first/last chunk).

 Such chunks are then aggregated using the provided `valueSelector` and `keySelector`
 (an overload that does not take `keySelector` just selects the explicitly provided key).

 ## Parameters
  - `keys` - A collection of keys to be used for resampling of the series
  - `direction` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.
  - `valueSelector` - A function that is used to collapse a generated chunk into a 
    single value. Note that this function may be called with empty series.
  - `keySelector` - A function that is used to generate a new key for each chunk.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered.

 [category:Resampling]
</summary>
</member>
<member name="M:Deedle.Series`2.Realign(System.Collections.Generic.IEnumerable{`0})">
<summary>
 [category:Indexing]
</summary>
</member>
<member name="M:Deedle.Series`2.Pow(Deedle.Series{`0,System.Double},Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Pow(Deedle.Series{`0,System.Double},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Pow(System.Double,Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Pairwise">
<summary>
 Returns a series containing the predecessor and an element for each input, except
 for the first one. The returned series is one key shorter (it does not contain a 
 value for the first key).

 ## Parameters
  - `series` - The input series to be aggregated.

 ## Example

     let input = series [ 1 =&gt; &apos;a&apos;; 2 =&gt; &apos;b&apos;; 3 =&gt; &apos;c&apos;]
     let res = input.Pairwise()
     res = series [2 =&gt; (&apos;a&apos;, &apos;b&apos;); 3 =&gt; (&apos;b&apos;, &apos;c&apos;) ]

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.Series`2.Pairwise(Deedle.Boundary)">
<summary>
 Returns a series containing an element and its neighbor for each input.
 The returned series is one key shorter (it does not contain a 
 value for the first or last key depending on `boundary`). If `boundary` is 
 other than `Boundary.Skip`, then the key is included in the returned series, 
 but its value is missing.

 ## Parameters
  - `series` - The input series to be aggregated.
  - `boundary` - Specifies the direction in which the series is aggregated and 
    how the corner case is handled. If the value is `Boundary.AtEnding`, then the
    function returns value and its successor, otherwise it returns value and its
    predecessor.

 ## Example

     let input = series [ 1 =&gt; &apos;a&apos;; 2 =&gt; &apos;b&apos;; 3 =&gt; &apos;c&apos;]
     let res = input.Pairwise()
     res = series [2 =&gt; (&apos;a&apos;, &apos;b&apos;); 3 =&gt; (&apos;b&apos;, &apos;c&apos;) ]

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.Series`2.Merge(Deedle.Series{`0,`1},Deedle.UnionBehavior)">
<summary>
 [category:Merging, joining and zipping]
</summary>
</member>
<member name="M:Deedle.Series`2.Merge(Deedle.Series{`0,`1}[])">
<summary>
 [category:Merging, joining and zipping]
</summary>
</member>
<member name="M:Deedle.Series`2.Merge(System.Collections.Generic.IEnumerable{Deedle.Series{`0,`1}})">
<summary>
 [category:Merging, joining and zipping]
</summary>
</member>
<member name="M:Deedle.Series`2.Merge(Deedle.Series{`0,`1})">
<summary>
 [category:Merging, joining and zipping]
</summary>
</member>
<member name="M:Deedle.Series`2.Log10(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Log(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Interpolate(System.Collections.Generic.IEnumerable{`0},System.Func{`0,Deedle.OptionalValue{System.Collections.Generic.KeyValuePair{`0,`1}},Deedle.OptionalValue{System.Collections.Generic.KeyValuePair{`0,`1}},`1})">
<summary>
 Interpolates an ordered series given a new sequence of keys. The function iterates through
 each new key, and invokes a function on the current key, the nearest smaller and larger valid 
 observations from the series argument. The function must return a new valid float. 

 ## Parameters
  - `keys` - Sequence of new keys that forms the index of interpolated results
  - `f` - Function to do the interpolating

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.Series`2.IndexWith``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 [category:Indexing]
</summary>
</member>
<member name="M:Deedle.Series`2.IndexOrdinally">
<summary>
 Replace the index of the series with ordinally generated integers starting from zero.
 The elements of the series are assigned index according to the current order, or in a
 non-deterministic way, if the current index is not ordered.

 [category:Indexing]
</summary>
</member>
<member name="M:Deedle.Series`2.GroupBy``1(System.Func{System.Collections.Generic.KeyValuePair{`0,`1},``0})">
<summary>
 Groups a series (ordered or unordered) using the specified key selector (`keySelector`) 

 ## Parameters
  - `keySelector` - Generates a new key that is used for aggregation, based on the original 
    key and value. The new key must support equality testing.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.Series`2.GetSubrange(Microsoft.FSharp.Core.FSharpOption{System.Tuple{`0,Deedle.Indices.BoundaryBehavior}},Microsoft.FSharp.Core.FSharpOption{System.Tuple{`0,Deedle.Indices.BoundaryBehavior}})">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.GetSlice(Microsoft.FSharp.Core.FSharpOption{`0},Microsoft.FSharp.Core.FSharpOption{`0})">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.GetObservation(`0)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.GetObservation(`0,Deedle.Lookup)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.GetKeyAt(System.Int32)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.GetItems(System.Collections.Generic.IEnumerable{`0},Deedle.Lookup)">
<summary>
 Returns a new series with an index containing the specified keys.
 When the key is not found in the current series, the newly returned
 series will contain a missing value. When the second parameter is not
 specified, the keys have to exactly match the keys in the current series
 (`Lookup.Exact`).

 ## Parameters

  * `keys` - A collection of keys in the current series.
  * `lookup` - Specifies the lookup behavior when searching for keys in 
    the current series. `Lookup.NearestGreater` and `Lookup.NearestSmaller`
    can be used when the current series is ordered.

 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.GetItems(System.Collections.Generic.IEnumerable{`0})">
<summary>
 Returns a new series with an index containing the specified keys.
 When the key is not found in the current series, the newly returned
 series will contain a missing value. When the second parameter is not
 specified, the keys have to exactly match the keys in the current series
 (`Lookup.Exact`).

 ## Parameters

  * `keys` - A collection of keys in the current series.

 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.GetByLevel(Deedle.ICustomLookup{`0})">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.GetAt(System.Int32)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.GetAddressRange(Deedle.RangeRestriction{System.Int64})">
<summary>
 Internal helper used by `skip`, `take`, etc.
</summary>
</member>
<member name="M:Deedle.Series`2.Get(`0)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.Get(`0,Deedle.Lookup)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.Format(System.Int32,System.Int32)">
<summary>
 Shows the series content in a human-readable format. The resulting string
 shows a limited number of values from the series.

 ## Parameters
  - `startCount` - The number of elements to show at the beginning of the series
  - `endCount` - The number of elements to show at the end of the series
</summary>
</member>
<member name="M:Deedle.Series`2.Format(System.Int32)">
<summary>
 Shows the series content in a human-readable format. The resulting string
 shows a limited number of values from the series.

 ## Parameters
  - `itemCount` - The total number of items to show. The result will show
    at most `itemCount/2` items at the beginning and ending of the series.
</summary>
</member>
<member name="M:Deedle.Series`2.Format">
<summary>
 Shows the series content in a human-readable format. The resulting string
 shows a limited number of values from the series.
</summary>
</member>
<member name="M:Deedle.Series`2.Floor(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Exp(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Cosh(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Cos(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Convert``1(System.Func{`1,``0},System.Func{``0,`1})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.Series`2.Ceiling(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Atan(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Asin(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Aggregate``2(Deedle.Aggregation{`0},System.Func{Deedle.DataSegment{Deedle.Series{`0,`1}},System.Collections.Generic.KeyValuePair{``0,Deedle.OptionalValue{``1}}})">
<summary>
 Aggregates an ordered series using the method specified by `Aggregation&lt;K&gt;` and then
 applies the provided `observationSelector` on each window or chunk to produce the result
 which is returned as a new series. The selector returns both the key and the value.

 ## Parameters
  - `aggregation` - Specifies the aggregation method using `Aggregation&lt;K&gt;`. This is
    a discriminated union listing various chunking and windowing conditions.
  - `observationSelector` - A function that is called on each chunk to obtain a key and a value.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.Series`2.Aggregate``2(Deedle.Aggregation{`0},System.Func{Deedle.DataSegment{Deedle.Series{`0,`1}},``0},System.Func{Deedle.DataSegment{Deedle.Series{`0,`1}},Deedle.OptionalValue{``1}})">
<summary>
 Aggregates an ordered series using the method specified by `Aggregation&lt;K&gt;` and then
 applies the provided `valueSelector` on each window or chunk to produce the result
 which is returned as a new series. A key for each window or chunk is
 selected using the specified `keySelector`.

 ## Parameters
  - `aggregation` - Specifies the aggregation method using `Aggregation&lt;K&gt;`. This is
    a discriminated union listing various chunking and windowing conditions.
  - `keySelector` - A function that is called on each chunk to obtain a key.
  - `valueSelector` - A value selector function that is called to aggregate each chunk or window.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.Series`2.Acos(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Abs(Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Abs(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="T:Deedle.Series`2">
<summary>
 The type `Series&lt;K, V&gt;` represents a data series consisting of values `V` indexed by
 keys `K`. The keys of a series may or may not be ordered 

 [category:Core frame and series types]
</summary>
</member>
<member name="M:Deedle.Stats.variance``2(Deedle.Frame{``0,``1})">
<summary>
 For each numerical column, returns the variance of the values in the column.
 The function skips over missing values and `NaN` values. When there are less 
 than 2 values, the result is NaN.

 [category:Frame statistics]
</summary>
</member>
<member name="M:Deedle.Stats.variance``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns the variance of the values in a series. The function skips over missing values
 and `NaN` values. When there are less than 2 values, the result is NaN.

 [category:Series statistics]
</summary>
</member>
<member name="M:Deedle.Stats.sum``2(Deedle.Frame{``0,``1})">
<summary>
 For each numerical column, returns the sum of the values in the column. 
 The function skips over missing values and `NaN` values. When there are no 

 [category:Frame statistics]
</summary>
</member>
<member name="M:Deedle.Stats.sum``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns the sum of the values in a series. The function skips over missing values
 and `NaN` values. When there are no available values, the result is NaN.

 [category:Series statistics]
</summary>
</member>
<member name="M:Deedle.Stats.stdDev``2(Deedle.Frame{``0,``1})">
<summary>
 For each numerical column, returns the standard deviation of the values in the column. 
 The function skips over missing values and `NaN` values. When there are less than 2 values, 
 the result is NaN.

 [category:Frame statistics]
</summary>
</member>
<member name="M:Deedle.Stats.stdDev``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns the standard deviation of the values in a series. The function skips over 
 missing values and `NaN` values. When there are less than 2 values, the result is NaN.

 [category:Series statistics]
</summary>
</member>
<member name="M:Deedle.Stats.skew``2(Deedle.Frame{``0,``1})">
<summary>
 For each numerical column, returns the skewness of the values in a series. 
 The function skips over missing values and `NaN` values. When there are less than 3 values, 
 the result is NaN.

 [category:Frame statistics]
</summary>
</member>
<member name="M:Deedle.Stats.skew``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns the skewness of the values in a series. The function skips over missing 
 values and `NaN` values. When there are less than 3 values, the result is NaN.

 [category:Series statistics]
</summary>
</member>
<member name="M:Deedle.Stats.numSum``2(Deedle.Series{``0,``1})">
<summary>
 Sum that operates only any appropriate numeric type. When there are no available 
 values, the result is zero of the approriate numeric type.

 [category:Series statistics]
</summary>
</member>
<member name="M:Deedle.Stats.movingVariance``1(System.Int32,Deedle.Series{``0,System.Double})">
<summary>
 Returns a series that contains variance over a moving window of the specified size.
 The first `size-1` elements of the returned series are always missing; if the 
 entire window contains missing values, the result is also missing.

 [category:Moving windows]
</summary>
</member>
<member name="M:Deedle.Stats.movingSum``1(System.Int32,Deedle.Series{``0,System.Double})">
<summary>
 Returns a series that contains sums over a moving window of the specified size.
 The first `size-1` elements of the returned series are always missing; if the 
 entire window contains missing values, the result is 0.

 [category:Moving windows]
</summary>
</member>
<member name="M:Deedle.Stats.movingStdDev``1(System.Int32,Deedle.Series{``0,System.Double})">
<summary>
 Returns a series that contains standard deviations over a moving window of the specified size.
 The first `size-1` elements of the returned series are always missing; if the 
 entire window contains missing values, the result is also missing.

 [category:Moving windows]
</summary>
</member>
<member name="M:Deedle.Stats.movingSkew``1(System.Int32,Deedle.Series{``0,System.Double})">
<summary>
 Returns a series that contains skewness over a moving window of the specified size.
 The first `size-1` elements of the returned series are always missing; if the 
 entire window contains missing values, the result is also missing.

 [category:Moving windows]
</summary>
</member>
<member name="M:Deedle.Stats.movingMin``1(System.Int32,Deedle.Series{``0,System.Double})">
<summary>
 Returns a series that contains minimum over a moving window of the specified size.
 The first `size-1` elements are calculated using smaller windows spanning over `1 .. size-1` 
 values. If the entire window contains missing values, the result is missing.

 [category:Moving windows]
</summary>
</member>
<member name="M:Deedle.Stats.movingMean``1(System.Int32,Deedle.Series{``0,System.Double})">
<summary>
 Returns a series that contains means over a moving window of the specified size.
 The first `size-1` elements of the returned series are always missing; if the 
 entire window contains missing values, the result is also missing.

 [category:Moving windows]
</summary>
</member>
<member name="M:Deedle.Stats.movingMax``1(System.Int32,Deedle.Series{``0,System.Double})">
<summary>
 Returns a series that contains maximum over a moving window of the specified size.
 The first `size-1` elements are calculated using smaller windows spanning over `1 .. size-1` 
 values. If the entire window contains missing values, the result is missing.

 [category:Moving windows]
</summary>
</member>
<member name="M:Deedle.Stats.movingKurt``1(System.Int32,Deedle.Series{``0,System.Double})">
<summary>
 Returns a series that contains kurtosis over a moving window of the specified size.
 The first `size-1` elements of the returned series are always missing; if the 
 entire window contains missing values, the result is also missing.

 [category:Moving windows]
</summary>
</member>
<member name="M:Deedle.Stats.movingCount``1(System.Int32,Deedle.Series{``0,System.Double})">
<summary>
 Returns a series that contains counts over a moving window of the specified size.
 The first `size-1` elements of the returned series are always missing; if the 
 entire window contains missing values, the result is 0.

 [category:Moving windows]
</summary>
</member>
<member name="M:Deedle.Stats.minBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``2,``0})">
<summary>
 Returns the key and value of the least element in the series. The result
 is an optional value. When the series contains no values, the result is `None`.

 [category:Series statistics]
</summary>
</member>
<member name="M:Deedle.Stats.min``2(Deedle.Frame{``0,``1})">
<summary>
 For each numerical column, returns the minimal values as a series.
 The function skips over missing and `NaN` values. When there are no values,
 the result is `NaN`.

 [category:Frame statistics]
</summary>
</member>
<member name="M:Deedle.Stats.min``2(Deedle.Series{``0,``1})">
<summary>
 Returns the minimum of the values in a series. The result is an option value.
 When the series contains no values, the result is `None`.

 [category:Series statistics]
</summary>
</member>
<member name="M:Deedle.Stats.median``2(Deedle.Frame{``0,``1})">
<summary>
 For each numerical column, returns the median of the values in the column.

 [category:Frame statistics]
</summary>
</member>
<member name="M:Deedle.Stats.median``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns the median of the elements of the series.

 [category:Series statistics]
</summary>
</member>
<member name="M:Deedle.Stats.mean``2(Deedle.Frame{``0,``1})">
<summary>
 For each numerical column, returns the mean of the values in the column. 
 The function skips over missing values and `NaN` values. When there are 
 no available values, the result is NaN.

 [category:Frame statistics]
</summary>
</member>
<member name="M:Deedle.Stats.mean``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns the mean of the values in a series. The function skips over missing values
 and `NaN` values. When there are no available values, the result is NaN.

 [category:Series statistics]
</summary>
</member>
<member name="M:Deedle.Stats.maxBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``2,``0})">
<summary>
 Returns the key and value of the greatest element in the series. The result
 is an optional value. When the series contains no values, the result is `None`.

 [category:Series statistics]
</summary>
</member>
<member name="M:Deedle.Stats.max``2(Deedle.Frame{``0,``1})">
<summary>
 For each numerical column, returns the maximal values as a series.
 The function skips over missing and `NaN` values. When there are no values,
 the result is `NaN`.

 [category:Frame statistics]
</summary>
</member>
<member name="M:Deedle.Stats.max``2(Deedle.Series{``0,``1})">
<summary>
 Returns the maximum of the values in a series. The result is an option value.
 When the series contains no values, the result is `None`.

 [category:Series statistics]
</summary>
</member>
<member name="M:Deedle.Stats.levelVariance``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``0,System.Double})">
<summary>
 For each group with equal keys at the level specified by `level`, 
 returns the variance of the values in the group. The function skips over missing 
 values and `NaN` values. When there are less than 2 values, the result is NaN.

 [category:Multi-level statistics]
</summary>
</member>
<member name="M:Deedle.Stats.levelSum``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``0,System.Double})">
<summary>
 For each group with equal keys at the level specified by `level`, 
 returns the sum of the values in the group. The function skips over missing values 
 and `NaN` values. When there are no available values, the result is 0.

 [category:Multi-level statistics]
</summary>
</member>
<member name="M:Deedle.Stats.levelStdDev``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``0,System.Double})">
<summary>
 For each group with equal keys at the level specified by `level`, 
 returns the standard deviation of the values in the group. The function skips over 
 missing values and `NaN` values. When there are less than 2 values, the result is NaN.

 [category:Multi-level statistics]
</summary>
</member>
<member name="M:Deedle.Stats.levelSkew``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``0,System.Double})">
<summary>
 For each group with equal keys at the level specified by `level`, 
 returns the skewness of the values in a series. The function skips over missing 
 values and `NaN` values. When there are less than 3 values, the result is NaN.

 [category:Multi-level statistics]
</summary>
</member>
<member name="M:Deedle.Stats.levelMedian``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``0,System.Double})">
<summary>
 For each group with equal keys at the level specified by `level`, 
 returns the median of the values in the group.

 [category:Multi-level statistics]
</summary>
</member>
<member name="M:Deedle.Stats.levelMean``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``0,System.Double})">
<summary>
 For each group with equal keys at the level specified by `level`, 
 returns the mean of the values in the group. The function skips over missing 
 values and `NaN` values. When there are no available values, the result is NaN.

 [category:Multi-level statistics]
</summary>
</member>
<member name="M:Deedle.Stats.levelKurt``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``0,System.Double})">
<summary>
 For each group with equal keys at the level specified by `level`, 
 returns the kurtosis of the values in a series. The function skips over missing values 
 and `NaN` values. When there are less than 4 values, the result is NaN.

 [category:Multi-level statistics]
</summary>
</member>
<member name="M:Deedle.Stats.levelCount``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``0,``2})">
<summary>
 For each group with equal keys at the level specified by `level`, 
 returns the number of the values in the group. This excludes missing 
 values and values created from `Double.NaN` etc.

 [category:Multi-level statistics]
</summary>
</member>
<member name="M:Deedle.Stats.kurt``2(Deedle.Frame{``0,``1})">
<summary>
 For each numerical column, returns the kurtosis of the values in a series. 
 The function skips over missing values and `NaN` values. When there are less than 4 values, 
 the result is NaN.

 [category:Frame statistics]
</summary>
</member>
<member name="M:Deedle.Stats.kurt``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns the kurtosis of the values in a series. The function skips over missing 
 values and `NaN` values. When there are less than 4 values, the result is NaN.

 [category:Series statistics]
</summary>
</member>
<member name="M:Deedle.Stats.interpolateLinear``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Double}},Deedle.Series{``0,System.Double})">
<summary>
 Linearly interpolates an ordered series given a new sequence of keys. 

 ## Parameters
  - `keys` - Sequence of new keys that forms the index of interpolated results
  - `keyDiff` - A function representing &quot;subtraction&quot; between two keys

 [category:Series interoploation]
</summary>
</member>
<member name="M:Deedle.Stats.interpolate``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,``1}},``1}}},Deedle.Series{``0,``1})">
<summary>
 Interpolates an ordered series given a new sequence of keys. The function iterates through
 each new key, and invokes a function on the current key, the nearest smaller and larger valid 
 observations from the series argument. The function must return a new valid float. 

 ## Parameters
  - `keys` - Sequence of new keys that forms the index of interpolated results
  - `f` - Function to do the interpolating

 [category:Series interoploation]
</summary>
</member>
<member name="M:Deedle.Stats.expandingVariance``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns a series that contains variance over expanding windows (the value for
 a given key is calculated from all elements with smaller keys); If the 
 entire window contains fewer than 2 values, the result is missing.

 [category:Expanding windows]
</summary>
</member>
<member name="M:Deedle.Stats.expandingSum``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns a series that contains sums over expanding windows (the value for
 a given key is calculated from all elements with smaller keys); If the 
 entire window contains no values, the result is 0.

 [category:Expanding windows]
</summary>
</member>
<member name="M:Deedle.Stats.expandingStdDev``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns a series that contains standard deviation over expanding windows (the 
 value for a given key is calculated from all elements with smaller keys); If the 
 entire window contains fewer than 2 values, the result is missing.

 [category:Expanding windows]
</summary>
</member>
<member name="M:Deedle.Stats.expandingSkew``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns a series that contains skewness over expanding windows (the value for
 a given key is calculated from all elements with smaller keys); If the 
 entire window contains fewer than 3 values, the result is missing.

 [category:Expanding windows]
</summary>
</member>
<member name="M:Deedle.Stats.expandingMin``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns a series that contains minimum over an expanding window. The value
 for a key _k_ in the returned series is the minimum from all elements with
 smaller keys.

 [category:Expanding windows]
</summary>
</member>
<member name="M:Deedle.Stats.expandingMean``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns a series that contains means over expanding windows (the value for
 a given key is calculated from all elements with smaller keys); If the 
 entire window contains no values, the result is missing.

 [category:Expanding windows]
</summary>
</member>
<member name="M:Deedle.Stats.expandingMax``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns a series that contains maximum over an expanding window. The value
 for a key _k_ in the returned series is the maximum from all elements with
 smaller keys.

 [category:Expanding windows]
</summary>
</member>
<member name="M:Deedle.Stats.expandingKurt``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns a series that contains kurtosis over expanding windows (the value for
 a given key is calculated from all elements with smaller keys); If the 
 entire window contains fewer than 4 values, the result is missing.

 [category:Expanding windows]
</summary>
</member>
<member name="M:Deedle.Stats.expandingCount``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns a series that contains counts over expanding windows (the value for
 a given key is calculated from all elements with smaller keys).

 [category:Expanding windows]
</summary>
</member>
<member name="M:Deedle.Stats.count``2(Deedle.Frame{``0,``1})">
<summary>
 For each column, returns the number of the values in the column. 
 This excludes missing values and values created from `Double.NaN` etc.

 [category:Frame statistics]
</summary>
</member>
<member name="M:Deedle.Stats.count``2(Deedle.Series{``0,``1})">
<summary>
 Returns the number of the values in a series. This excludes missing values
 and values created from `Double.NaN` etc.

 [category:Series statistics]
</summary>
</member>
<member name="T:Deedle.Stats">
<summary>
 The `Stats` type contains functions for fast calculation of statistics over
 series and frames as well as over a moving and an expanding window in a series. 

 The resulting series has the same keys as the input series. When there are
 no values, or missing values, different functions behave in different ways.
 Statistics (e.g. mean) return missing value when any value is missing, while min/max
 functions return the minimal/maximal element (skipping over missing values).

 ## Series statistics
 
 Functions such as `count`, `mean`, `kurt` etc. return the
 statistics calculated over all values of a series. The calculation skips
 over missing values (or `nan` values), so for example `mean` returns the
 average of all _present_ values.

 ## Frame statistics

 The standard functions are exposed as static members and are 
 overloaded. This means that they can be applied to both `Series&lt;&apos;K, float&gt;` and 
 to `Frame&lt;&apos;R, &apos;C&gt;`. When applied to data frame, the functions apply the 
 statistical calculation to all numerical columns of the frame.

 ## Moving windows

 Moving window means that the window has a fixed size and moves over the series.
 In this case, the result of the statisitcs is always attached to the last key
 of the window. The function names are prefixed with `moving`.

 ## Expanding windows

 Expanding window means that the window starts as a single-element sized window
 and expands as it moves over the series. In this case, statistics is calculated
 for all values up to the current key. This means that the result is attached
 to the key at the end of the window. The function names are prefixed
 with `expanding`.

 ## Multi-level statistics

 For a series with multi-level (hierarchical) index, the
 functions prefixed with `level` provide a way to apply statistical operation on 
 a single level of the index. (For example you can sum values along the `&apos;K1` keys 
 in a series `Series&lt;&apos;K1 * &apos;K2, float&gt;` and get `Series&lt;&apos;K1, float&gt;` as the result.)

 ## Remarks

 The windowing functions in the `Stats` type support calculations over a fixed-size
 windows specified by the size of the window. If you need more complex windowing 
 behavior (such as window based on the distance between keys), different handling
 of boundary, or chunking (calculation over adjacent chunks), you can use chunking and
 windowing functions from the `Series` module such as `Series.windowSizeInto` or
 `Series.chunkSizeInto`.

 [category:Frame and series operations]
</summary>
</member>
<member name="P:Deedle.TryValue`1.Value">
<summary>
 Returns the value of `TryValue&lt;T&gt;` when the value is present; 
 otherwise, throws an exception that was captured
</summary>
</member>
<member name="P:Deedle.TryValue`1.HasValue">
<summary>
 Returns `true` when the `TryValue&lt;T&gt;` object represents a 
 successfully calculated value 
</summary>
</member>
<member name="P:Deedle.TryValue`1.Exception">
<summary>
 Returns the exception captured by this value. When `HasValue = true`, 
 accessing the property throws `InvalidOperationException`.
</summary>
</member>
<member name="M:Deedle.TryValue`1.ToString">
<summary>
 Returns the string representation of the underlying value or `&lt;error&gt;`
</summary>
</member>
<member name="T:Deedle.TryValue`1">
<summary>
 Represents a value or an exception. This type is used by functions such as
 `Series.tryMap` and `Frame.tryMap` to capture the result of a lambda function,
 which may be either a value or an exception. The type is a discriminated union,
 so it can be processed using F# pattern matching, or using `Value`, `HasValue`
 and `Exception` properties

 [category:Primitive types and values]
</summary>
</member>
<member name="F:Deedle.UnionBehavior.Exclusive">
<summary>
 When there are values available in both series that are being unioned, raise an exception.
</summary>
</member>
<member name="F:Deedle.UnionBehavior.PreferRight">
<summary>
 When there are values available in both series that are being unioned, prefer the right value.
</summary>
</member>
<member name="F:Deedle.UnionBehavior.PreferLeft">
<summary>
 When there are values available in both series that are being unioned, prefer the left value.
</summary>
</member>
<member name="T:Deedle.UnionBehavior">
<summary>
 This enumeration specifies the behavior of `Union` operation on series when there are
 overlapping keys in two series that are being unioned. The options include preferring values
 from the left/right series or throwing an exception when both values are available.

 [category:Parameters and results of various operations]
</summary>
</member>
<member name="T:Deedle.VectorCallSite`1">
<summary>
 Represents a generic function `\forall.&apos;T.(IVector&lt;&apos;T&gt; -&gt; &apos;R)`. The function can be 
 generically invoked on an argument of type `IVector` using `IVector.Invoke`

 [category:Vectors and indices]
</summary>
</member>
<member name="T:Deedle.opt`1">
<summary>
 A type alias for the `OptionalValue&lt;T&gt;` type. The type alias can be used
 to make F# type definitions that use optional values directly more succinct.

 [category:Primitive types and values]
</summary>
</member>
<member name="T:Deedle.tryval`1">
<summary>
 A type alias for the `TryValue&lt;T&gt;` type. The type alias can be used
 to make F# type declarations that explcitly handle exceptions more succinct.

 [category:Primitive types and values]
</summary>
</member>
<member name="P:Deedle.Addressing.IAddressOperations.Range">
<summary>
 Returns a sequence that iterates over `FirstElement .. LastElement`
</summary>
</member>
<member name="P:Deedle.Addressing.IAddressOperations.LastElement">
<summary>
 Returns the last address of the range
</summary>
</member>
<member name="P:Deedle.Addressing.IAddressOperations.FirstElement">
<summary>
 Returns the first address of the range
</summary>
</member>
<member name="M:Deedle.Addressing.IAddressOperations.OffsetOf(System.Int64)">
<summary>
 Given an address, return the absolute offset of the address in the range
 This might be tricky for partitioned ranges. For example if you have two 
 partitions with 10 values addressed by (0,0)..(0,9); (1,0)..(1,9), the the
 offset of address (1, 5) is 15.
</summary>
</member>
<member name="M:Deedle.Addressing.IAddressOperations.AdjustBy(System.Int64,System.Int64)">
<summary>
 Increment or decrement the specified address by a given number
</summary>
</member>
<member name="M:Deedle.Addressing.IAddressOperations.AddressOf(System.Int64)">
<summary>
 Return the address of a value at the specified absolute offset.
 (See the comment for `OffsetOf` for more info about partitioning)
</summary>
</member>
<member name="T:Deedle.Addressing.IAddressOperations">
<summary>
 Various implementations can use different schemes for working with addresses 
 (for example, address can be just a global offset, or it can be pair of `int32` values
 that store partition and offset in a partition). This interface represents a specific
 address range and abstracts operations that BigDeedle needs to perform on addresses
 (within the specified range)
</summary>
</member>
<member name="P:Deedle.Addressing.LinearAddressingScheme.Instance">
<summary>
 Returns a single instance of the object (to enable reference equality)
</summary>
</member>
<member name="T:Deedle.Addressing.LinearAddressingScheme">
<summary>
 Represents a linear addressing scheme where the addresses are `0 .. &lt;size&gt;-1`.
</summary>
</member>
<member name="T:Deedle.Addressing.IAddressingScheme">
<summary>
 An empty interface that is used as an marker for &quot;addressing schemes&quot;. As discussed
 above, Deedle can use different addressing schemes. We need to make sure that the index
 and vector share the scheme - this is done by attaching `IAddressingScheme` to each
 index or vector and checking that they match. Implementations must support equality!
</summary>
</member>
<member name="T:Deedle.Addressing.Address">
<summary>
 Address is `int64&lt;address&gt;`. We use unit of measure annotation
 to make sure that correct conversion functions are used.
</summary>
</member>
<member name="T:Deedle.Addressing.LinearAddress">
<summary>
 Address operations that are used by the standard in-memory Deedle structures
 (LinearIndex and ArrayVector). Here, address is a positive array offset.
</summary>
</member>
<member name="P:Deedle.Addressing.AddressModule.invalid">
<summary>
 Represents an invalid address (which is returned from 
 optimized lookup functions when they fail)
</summary>
</member>
<member name="T:Deedle.Addressing">
<summary>
 An `Address` value is used as an interface between vectors and indices. The index maps
 keys of various types to address, which is then used to get a value from the vector.

 Here is a brief summary of what we assume (and don&apos;t assume) about addresses:

  - Address is `int64` (although we might need to generalize this in the future)
  - Different data sources can use different addressing schemes
    (as long as both index and vector use the same scheme)
  - Addresses don&apos;t have to be continuous (e.g. if the source is partitioned, it
    can use 32bit partition index + 32bit offset in the partition)
  - In the in-memory representation, address is just index into an array
  - In the BigDeedle representation, address is abstracted and comes with
    `AddressOperations` that specifies how to use it (tests use linear
    offset and partitioned representation)

 [category:Vectors and indices]
</summary>
</member>
<member name="M:Deedle.DataSegment.GetKind``1(Deedle.DataSegment{``0})">
<summary>
 Returns the kind property of the specified `DataSegment&lt;T&gt;`
</summary>
</member>
<member name="M:Deedle.DataSegment.GetData``1(Deedle.DataSegment{``0})">
<summary>
 Returns the data property of the specified `DataSegment&lt;T&gt;`
</summary>
</member>
<member name="M:Deedle.DataSegment.|Complete|Incomplete|``1(Deedle.DataSegment{``0})">
<summary>
 Complete active pattern that makes it possible to write functions that behave 
 differently for complete and incomplete segments. For example, the following 
 returns zero for incomplete segments:

     let sumSegmentOrZero = function
       | DataSegment.Complete(value) -&gt; Stats.sum value
       | DataSegment.Incomplete _ -&gt; 0.0

</summary>
</member>
<member name="M:Deedle.DataSegment.|Any|``1(Deedle.DataSegment{``0})">
<summary>
 A complete active pattern that extracts the kind and data from a `DataSegment`
 value. This makes it easier to write functions that only need data:

    let sumAny = function DataSegment.Any(_, data) -&gt; Stats.sum data

</summary>
</member>
<member name="T:Deedle.DataSegment">
<summary>
 Provides helper functions and active patterns for working with `DataSegment` values

 [category:Parameters and results of various operations]
</summary>
</member>
<member name="T:Deedle.Delayed.DelayedIndexBuilder">
<summary>
 Delayed index builder - this is where interesting things happen. Most operations
 are still delegated to LinearIndexBuilder, but the `GetRange` method looks at the
 index and if it is DelayedIndex, then it uses the `Source` to build a new `Source`
 with a restricted range.
</summary>
</member>
<member name="T:Deedle.Delayed.DelayedIndexFunction`2">
<summary>
 A polymorphic function that is passed to IDelayedIndex.Invoke
</summary>
</member>
<member name="T:Deedle.Delayed.IDelayedIndex`1">
<summary>
 In the DelayedIndexBuilder, we do not know the type of values, so this 
 is a less generic interface that gives us a way for accessing it...
</summary>
</member>
<member name="T:Deedle.Delayed.DelayedIndex`2">
<summary>
 Delayed index that is lnked to a DelayedSource specified during construction
 (This simply delegates all operations to the &apos;source.Keys&apos; index)
</summary>
</member>
<member name="T:Deedle.Delayed.DelayedVector`2">
<summary>
 A delayed vector that is linked to a DelayedSource specified during construction
 (This simply delegates all operations to the &apos;source.Values&apos; vector)
</summary>
</member>
<member name="T:Deedle.Delayed.DelayedSource`2">
<summary>
 This type represents data source for constructing delayed series. To construct
 a delayed series, use `DelayedSeries.Create` (this creates index and vector 
 linked to this `DelayedSource`).

 The function `loader` is called outside of the `async` (on the calling thread)
 but the returned async computations are invoked on background thread.
</summary>
</member>
<member name="T:Deedle.Delayed.DelayedSourceData`2">
<summary>
 Result that should be returned in response to `DelayedSourceRanges` request
</summary>
</member>
<member name="T:Deedle.Delayed.DelayedSourceRanges`1">
<summary>
 Specifies the ranges for which data need to be provided
</summary>
</member>
<member name="M:Deedle.Delayed.Ranges.flattenRanges``1(``0,``0,System.Collections.Generic.IComparer{``0},Deedle.Delayed.Ranges.Ranges{``0})">
<summary>
 Returns an ordered sequence of exclusive ranges
</summary>
</member>
<member name="M:Deedle.Delayed.Ranges.contains``1(System.Collections.Generic.IComparer{``0},``0,Deedle.Delayed.Ranges.Ranges{``0})">
<summary>
 Test if a range contains the specified value
</summary>
</member>
<member name="M:Deedle.Delayed.Ranges.containsSub``1(System.Collections.Generic.IComparer{``0},``0,``0,Deedle.Delayed.Ranges.Ranges{``0})">
<summary>
 Test if a range contains the specified sub-range
 (the function assumes that the sub-range is smaller than any range in the input)
</summary>
</member>
<member name="T:Deedle.Delayed.Ranges">
<summary>
 Module that contains functions for working with ranges - most importantly
 it handles flattening of trees constructed by unioning &amp; intersecting ranges
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.Frame`2.SaveCsv``2(Deedle.Frame{``0,``1},System.IO.Stream,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.String}},Microsoft.FSharp.Core.FSharpOption{System.Char},Microsoft.FSharp.Core.FSharpOption{System.Globalization.CultureInfo})">
<summary>
 [omit]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.Frame`2.ToDataTable``2(Deedle.Frame{``0,``1},System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Returns the data of the frame as a .NET `DataTable` object. The column keys are
 automatically converted to strings that are used as column names. The row index is
 turned into an additional column with the specified name (the function takes the name
 as a sequence to support hierarchical keys, but typically you can write just
 `frame.ToDataTable([&quot;KeyName&quot;])`.

 ## Parameters
  - `rowKeyNames` - Specifies the names of the row key components (or just a single
    row key name if the row index is not hierarchical).

 [category:Input and output]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.Frame`2.SaveCsv``2(Deedle.Frame{``0,``1},System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Save data frame to a CSV file or to a `TextWriter`. When calling the operation,
 you can specify whether you want to save the row keys or not (and headers for the keys)
 and you can also specify the separator (use `\t` for writing TSV files). When specifying
 file name ending with `.tsv`, the `\t` separator is used automatically.

 ## Parameters
  - `path` - Specifies the output file name where the CSV data should be written
  - `keyNames` - Specifies the CSV headers for row key (or keys, for multi-level index)
  - `separator` - Specify the column separator in the file (the default is `\t` for 
    TSV files and `,` for CSV files)
  - `culture` - Specify the `CultureInfo` object used for formatting numerical data

 [category:Input and output]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.Frame`2.SaveCsv``2(Deedle.Frame{``0,``1},System.String,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.String}},Microsoft.FSharp.Core.FSharpOption{System.Char},Microsoft.FSharp.Core.FSharpOption{System.Globalization.CultureInfo})">
<summary>
 Save data frame to a CSV file or a `TextWriter`. When calling the operation,
 you can specify whether you want to save the row keys or not (and headers for the keys)
 and you can also specify the separator (use `\t` for writing TSV files). When specifying
 file name ending with `.tsv`, the `\t` separator is used automatically.

 ## Parameters
  - `path` - Specifies the output file name where the CSV data should be written
  - `includeRowKeys` - When set to `true`, the row key is also written to the output file
  - `keyNames` - Can be used to specify the CSV headers for row key (or keys, for multi-level index)
  - `separator` - Specify the column separator in the file (the default is `\t` for 
    TSV files and `,` for CSV files)
  - `culture` - Specify the `CultureInfo` object used for formatting numerical data

 [category:Input and output]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.Frame`2.SaveCsv``2(Deedle.Frame{``0,``1},System.IO.TextWriter,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.String}},Microsoft.FSharp.Core.FSharpOption{System.Char},Microsoft.FSharp.Core.FSharpOption{System.Globalization.CultureInfo})">
<summary>
 Save data frame to a CSV file or a `TextWriter`. When calling the operation,
 you can specify whether you want to save the row keys or not (and headers for the keys)
 and you can also specify the separator (use `\t` for writing TSV files). When specifying
 file name ending with `.tsv`, the `\t` separator is used automatically.

 ## Parameters
  - `writer` - Specifies the TextWriter to which the CSV data should be written
  - `includeRowKeys` - When set to `true`, the row key is also written to the output file
  - `keyNames` - Can be used to specify the CSV headers for row key (or keys, for multi-level index)
  - `separator` - Specify the column separator in the file (the default is `\t` for 
    TSV files and `,` for CSV files)
  - `culture` - Specify the `CultureInfo` object used for formatting numerical data

 [category:Input and output]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.Frame`2.PivotTable``5(Deedle.Frame{``0,``1},``1,``1,Microsoft.FSharp.Core.FSharpFunc{Deedle.Frame{``0,``1},``4})">
<summary>
 Creates a new data frame resulting from a &apos;pivot&apos; operation. Consider a denormalized data 
 frame representing a table: column labels are field names &amp; table values are observations
 of those fields. pivotTable buckets the rows along two axes, according to the values of 
 the columns `r` and `c`; and then computes a value for the frame of rows that land in each 
 bucket.

 ## Parameters
  - `r` - A column key to group on for the resulting row index
  - `c` - A column key to group on for the resulting col index
  - `op` - A function computing a value from the corresponding bucket frame 

 [category:Frame operations]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.Frame.ofArray2D.Static``1(``0[0:,0:])">
<summary>
 Create data frame from a 2D array of values. The first dimension of the array
 is used as rows and the second dimension is treated as columns. Rows and columns
 of the returned frame are indexed with the element&apos;s offset in the array.

 ## Parameters
  - `array` - A two-dimensional array to be converted into a data frame

 [category:Frame construction]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.Frame.ofRecords.Static``1(System.Collections.IEnumerable,System.String)">
<summary>
 Creates a data frame from a sequence of any .NET objects. The method uses reflection
 over the specified type parameter `&apos;T` and turns its properties to columns.

 [category:Frame construction]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.Frame.ofRecords.Static``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a data frame from a sequence of any .NET objects. The method uses reflection
 over the specified type parameter `&apos;T` and turns its properties to columns.

 [category:Frame construction]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.Frame.ofRecords.Static``2(Deedle.Series{``0,``1})">
<summary>
 Creates a data frame from a series containing any .NET objects. The method uses reflection
 over the specified type parameter `&apos;T` and turns its properties to columns.

 [category:Frame construction]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.Frame.ofValues.Static``3(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1,``2}})">
<summary>
 Create a data frame from a sequence of tuples containing row key, column key and a value.

 [category:Frame construction]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.Frame.ofColumns.Static``3(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Creates a frame from a sequence of column keys and column series pairs. 
 The column series can contain values of any type, but it has to be the same 
 for all the series - if you have heterogenously typed series, use `=?&gt;`.

 [category:Frame construction]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.Frame.ofColumns.Static``3(Deedle.Series{``0,``1})">
<summary>
 Creates a frame from a series that maps column keys to a nested series 
 containing values for each column.

 [category:Frame construction]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.Frame.ofRowKeys.Static``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a frame with the specified row keys, but no columns (and no data).
 This is useful if you want to build a frame gradually and restrict all the
 later added data to a sequence of row keys known in advance.

 [category:Frame construction]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.Frame.ofRows.Static``3(Deedle.Series{``0,``1})">
<summary>
 Creates a frame from a series that maps row keys to a nested series 
 containing values for each row.

 [category:Frame construction]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.Frame.ofRows.Static``3(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Creates a frame from a sequence of row keys and row series pairs. 
 The row series can contain values of any type, but it has to be the same 
 for all the series - if you have heterogenously typed series, use `=?&gt;`.

 [category:Frame construction]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.Frame.ofRowsOrdinal.Static``3(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a frame with ordinal Integer index from a sequence of rows.
 The column indices of individual rows are unioned, so if a row has fewer
 columns, it will be successfully added, but there will be missing values.

 [category:Frame construction]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.Frame.ReadCsv.Static(System.IO.TextReader,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String[]})">
<summary>
 Load data frame from a CSV file. The operation automatically reads column names from the 
 CSV file (if they are present) and infers the type of values for each column. Columns
 of primitive types (`int`, `float`, etc.) are converted to the right type. Columns of other
 types (such as dates) are not converted automatically.

 ## Parameters

  * `reader` - Specifies the `TextReader`, positioned at the beginning of CSV data
  * `hasHeaders` - Specifies whether the input CSV file has header row
  * `inferTypes` - Specifies whether the method should attempt to infer types
    of columns automatically (set this to `false` if you want to specify schema)
  * `inferRows` - If `inferTypes=true`, this parameter specifies the number of
    rows to use for type inference. The default value is 100.
  * `schema` - A string that specifies CSV schema. See the documentation for 
    information about the schema format.
  * `separators` - A string that specifies one or more (single character) separators
    that are used to separate columns in the CSV file. Use for example `&quot;;&quot;` to 
    parse semicolon separated files.
  * `culture` - Specifies the name of the culture that is used when parsing 
    values in the CSV file (such as `&quot;en-US&quot;`). The default is invariant culture. 
  * `maxRows` - The maximal number of rows that should be read from the CSV file.
  * `missingValues` - An array of strings that contains values which should be treated
    as missing when reading the file. The default value is: &quot;NaN&quot;; &quot;NA&quot;; &quot;#N/A&quot;; &quot;:&quot;; &quot;-&quot;; &quot;TBA&quot;; &quot;TBD&quot;.

 [category:Input and output]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.Frame.ReadCsv.Static(System.IO.Stream,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String[]})">
<summary>
 Load data frame from a CSV file. The operation automatically reads column names from the 
 CSV file (if they are present) and infers the type of values for each column. Columns
 of primitive types (`int`, `float`, etc.) are converted to the right type. Columns of other
 types (such as dates) are not converted automatically.

 ## Parameters

  * `stream` - Specifies the input stream, opened at the beginning of CSV data
  * `hasHeaders` - Specifies whether the input CSV file has header row
  * `inferTypes` - Specifies whether the method should attempt to infer types
    of columns automatically (set this to `false` if you want to specify schema)
  * `inferRows` - If `inferTypes=true`, this parameter specifies the number of
    rows to use for type inference. The default value is 100.
  * `schema` - A string that specifies CSV schema. See the documentation for 
    information about the schema format.
  * `separators` - A string that specifies one or more (single character) separators
    that are used to separate columns in the CSV file. Use for example `&quot;;&quot;` to 
    parse semicolon separated files.
  * `culture` - Specifies the name of the culture that is used when parsing 
    values in the CSV file (such as `&quot;en-US&quot;`). The default is invariant culture. 
  * `maxRows` - The maximal number of rows that should be read from the CSV file.
  * `missingValues` - An array of strings that contains values which should be treated
    as missing when reading the file. The default value is: &quot;NaN&quot;; &quot;NA&quot;; &quot;#N/A&quot;; &quot;:&quot;; &quot;-&quot;; &quot;TBA&quot;; &quot;TBD&quot;.

 [category:Input and output]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.Frame.ReadCsv.Static(System.String,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String[]})">
<summary>
 Load data frame from a CSV file. The operation automatically reads column names from the 
 CSV file (if they are present) and infers the type of values for each column. Columns
 of primitive types (`int`, `float`, etc.) are converted to the right type. Columns of other
 types (such as dates) are not converted automatically.

 ## Parameters

  * `path` - Specifies a file name or an web location of the resource.
  * `hasHeaders` - Specifies whether the input CSV file has header row
  * `inferTypes` - Specifies whether the method should attempt to infer types
    of columns automatically (set this to `false` if you want to specify schema)
  * `inferRows` - If `inferTypes=true`, this parameter specifies the number of
    rows to use for type inference. The default value is 100.
  * `schema` - A string that specifies CSV schema. See the documentation for 
    information about the schema format.
  * `separators` - A string that specifies one or more (single character) separators
    that are used to separate columns in the CSV file. Use for example `&quot;;&quot;` to 
    parse semicolon separated files.
  * `culture` - Specifies the name of the culture that is used when parsing 
    values in the CSV file (such as `&quot;en-US&quot;`). The default is invariant culture. 
  * `maxRows` - The maximal number of rows that should be read from the CSV file.
  * `missingValues` - An array of strings that contains values which should be treated
    as missing when reading the file. The default value is: &quot;NaN&quot;; &quot;NA&quot;; &quot;#N/A&quot;; &quot;:&quot;; &quot;-&quot;; &quot;TBA&quot;; &quot;TBD&quot;.

 [category:Input and output]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.Frame.ReadCsv.Static``1(System.String,System.String,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String[]})">
<summary>
 Load data frame from a CSV file. The operation automatically reads column names from the 
 CSV file (if they are present) and infers the type of values for each column. Columns
 of primitive types (`int`, `float`, etc.) are converted to the right type. Columns of other
 types (such as dates) are not converted automatically.

 ## Parameters

  * `path` - Specifies a file name or an web location of the resource.
  * `indexCol` - Specifies the column that should be used as an index in the 
     resulting frame. The type is specified via a type parameter, e.g. use
     `Frame.ReadCsv&lt;int&gt;(&quot;file.csv&quot;, indexCol=&quot;Day&quot;)`.
  * `hasHeaders` - Specifies whether the input CSV file has header row
  * `inferTypes` - Specifies whether the method should attempt to infer types
    of columns automatically (set this to `false` if you want to specify schema)
  * `inferRows` - If `inferTypes=true`, this parameter specifies the number of
    rows to use for type inference. The default value is 0, meaninig all rows.
  * `schema` - A string that specifies CSV schema. See the documentation for 
    information about the schema format.
  * `separators` - A string that specifies one or more (single character) separators
    that are used to separate columns in the CSV file. Use for example `&quot;;&quot;` to 
    parse semicolon separated files.
  * `culture` - Specifies the name of the culture that is used when parsing 
    values in the CSV file (such as `&quot;en-US&quot;`). The default is invariant culture. 
  * `maxRows` - The maximal number of rows that should be read from the CSV file.
  * `missingValues` - An array of strings that contains values which should be treated
    as missing when reading the file. The default value is: &quot;NaN&quot;; &quot;NA&quot;; &quot;#N/A&quot;; &quot;:&quot;; &quot;-&quot;; &quot;TBA&quot;; &quot;TBD&quot;.

 [category:Input and output]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.frame``3(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 A function for constructing data frame from a sequence of name - column pairs.
 This provides a nicer syntactic sugar for `Frame.ofColumns`.

 ## Example
 To create a simple frame with two columns, you can write:
 
     frame [ &quot;A&quot; =&gt; series [ 1 =&gt; 30.0; 2 =&gt; 35.0 ]
             &quot;B&quot; =&gt; series [ 1 =&gt; 30.0; 3 =&gt; 40.0 ] ]

 [category:Frame construction]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.op_EqualsQmarkGreater``2(``0,Deedle.ISeries{``1})">
<summary>
 Custom operator that can be used when constructing a frame from observations
 of series. The operator simply returns a tuple, but it upcasts the series 
 argument so you don&apos;t have to do manual casting. For example:

     frame [ &quot;k1&quot; =?&gt; series [0 =&gt; &quot;a&quot;]; &quot;k2&quot; =?&gt; series [&quot;x&quot; =&gt; &quot;y&quot;] ]

 [category:Frame construction]
</summary>
</member>
<member name="M:Deedle.F# Frame extensions.op_EqualsGreater``2(``0,``1)">
<summary>
 Custom operator that can be used when constructing series from observations
 or frames from key-row or key-column pairs. The operator simply returns a 
 tuple, but it provides a more convenient syntax. For example:

     series [ &quot;k1&quot; =&gt; 1; &quot;k2&quot; =&gt; 15 ]

 [category:Frame construction]
</summary>
</member>
<member name="T:Deedle.F# Frame extensions">
<summary>
 This module contains F# functions and extensions for working with frames. This
 includes operations for creating frames such as the `frame` function, `=&gt;` operator
 and `Frame.ofRows`, `Frame.ofColumns` and `Frame.ofRowKeys` functions. The module
 also provides additional F# extension methods including `ReadCsv`, `SaveCsv` and `PivotTable`.

 ## Frame construction
 The functions and methods in this group can be used to create frames. If you are creating
 a frame from a number of sample values, you can use `frame` and the `=&gt;` operator (or the
 `=?&gt;` opreator which is useful if you have multiple series of distinct types):

     frame [ &quot;Column 1&quot; =&gt; series [ 1 =&gt; 1.0; 2 =&gt; 2.0 ]
             &quot;Column 2&quot; =&gt; series [ 3 =&gt; 3.0 ] ]

 Aside from this, the various type extensions let you write `Frame.ofXyz` to construct frames
 from data in various formats - `Frame.ofRows` and `Frame.ofColumns` create frame from a series
 or a sequence of rows or columns; `Frame.ofRecords` creates a frame from .NET objects using
 Reflection and `Frame.ofRowKeys` creates an empty frame with the specified keys.

 ## Frame operations
 The group contains two overloads of the F#-friendly version of the `PivotTable` method.

 ## Input and output
 This group of extensions includes a number of overloads for the `ReadCsv` and `SaveCsv` 
 methods. The methods here are designed to be used from F# and so they are F#-style extensions
 and they use F#-style optional arguments. In general, the overlads take either a path or
 `TextReader`/`TextWriter`. Also note that `ReadCsv&lt;&apos;R&gt;(path, indexCol, ...)` lets you specify
 the column to be used as the index.

 [category:Frame and series operations]
</summary>
</member>
<member name="M:Deedle.F# Index extensions.Index.ofUnorderedKeys``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Create an index from a sequence of keys and assume they are not sorted
 (the resulting index is also not sorted).
</summary>
</member>
<member name="M:Deedle.F# Index extensions.Index.ofUnorderedKeys``1(``0[])">
<summary>
 Create an index from a sequence of keys and assume they are not sorted
 (the resulting index is also not sorted).
</summary>
</member>
<member name="M:Deedle.F# Index extensions.Index.ofUnorderedKeys``1(System.Collections.ObjectModel.ReadOnlyCollection{``0})">
<summary>
 Create an index from a sequence of keys and assume they are not sorted
 (the resulting index is also not sorted).
</summary>
</member>
<member name="M:Deedle.F# Index extensions.Index.ofKeys``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Create an index from a sequence of keys and check if they are sorted or not
</summary>
</member>
<member name="M:Deedle.F# Index extensions.Index.ofKeys``1(``0[])">
<summary>
 Create an index from a sequence of keys and check if they are sorted or not
</summary>
</member>
<member name="M:Deedle.F# Index extensions.Index.ofKeys``1(System.Collections.ObjectModel.ReadOnlyCollection{``0})">
<summary>
 Create an index from a sequence of keys and check if they are sorted or not
</summary>
</member>
<member name="T:Deedle.F# Index extensions.Index">
<summary>
 Type that provides a simple access to creating indices represented
 using the built-in `LinearVector` type.
</summary>
</member>
<member name="T:Deedle.F# Index extensions">
<summary>
 Defines non-generic `Index` type that provides functions for building indices
 (hard-bound to `LinearIndexBuilder` type). In F#, the module is automatically opened
 using `AutoOpen`. The methods are not designed for the use from C#.

 [category:Vectors and indices]
</summary>
</member>
<member name="P:Deedle.F# IndexBuilder implementation.IndexBuilder.Instance">
<summary>
 Returns concrete implementation for IVectorBuilder
</summary>
</member>
<member name="T:Deedle.F# IndexBuilder implementation">
<summary>
 Set concrete IIndexBuilder implementation

 [category:Vectors and indices]
</summary>
</member>
<member name="M:Deedle.F# Series extensions.Series.ofValues``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Create a series from the specified sequence of values. The keys
 of the resulting series are generated ordinarilly, starting from 0.
</summary>
</member>
<member name="M:Deedle.F# Series extensions.Series.ofOptionalObservations``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,Microsoft.FSharp.Core.FSharpOption{``1}}})">
<summary>
 Create a series from a sequence of observations where the value is of
 type `option&lt;&apos;T&gt;`. When the value is `None`, the key remains in the
 series, but the value is treated as missing.
</summary>
</member>
<member name="M:Deedle.F# Series extensions.Series.ofObservations``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Create a series from a sequence of key-value pairs that represent
 the observations of the series. Consider using a shorthand 
 `series` function instead.
</summary>
</member>
<member name="M:Deedle.F# Series extensions.Series.ofNullables``1(System.Collections.Generic.IEnumerable{System.Nullable{``0}})">
<summary>
 Create a series from a sequence of nullable values. The keys
 of the resulting series are generated ordinarilly, starting from 0.
 The resulting series will contain keys associated with the `null`
 values, but the values are treated as missing.
</summary>
</member>
<member name="M:Deedle.F# Series extensions.series``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Create a series from a sequence of key-value pairs that represent
 the observations of the series. This function can be used together
 with the `=&gt;` operator to create key-value pairs.

 ## Example

     // Creates a series with squares of numbers
     let sqs = series [ 1 =&gt; 1.0; 2 =&gt; 4.0; 3 =&gt; 9.0 ]

</summary>
</member>
<member name="T:Deedle.F# Series extensions">
<summary>
 Contains extensions for creating values of type `Series&lt;&apos;K, &apos;V&gt;` including
 a type with functions such as `Series.ofValues` and the `series` function.
 The module is automatically opened for all F# code that references `Deedle`.

 [category:Core frame and series types]
</summary>
</member>
<member name="M:Deedle.F# Vector extensions.Vector.ofValues``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a vector that stores the specified data in an array.
 Values such as `null` and `Double.NaN` are turned into missing values.
</summary>
</member>
<member name="M:Deedle.F# Vector extensions.Vector.ofValues``1(``0[])">
<summary>
 Creates a vector that stores the specified data in an array.
 Values such as `null` and `Double.NaN` are turned into missing values.
</summary>
</member>
<member name="M:Deedle.F# Vector extensions.Vector.ofOptionalValues``1(Deedle.OptionalValue{``0}[])">
<summary>
 Missing values can be specified explicitly as `OptionalValue.Missing`, but 
 other values such as `null` and `Double.NaN` are turned into missing values too.
</summary>
</member>
<member name="M:Deedle.F# Vector extensions.Vector.ofOptionalValues``1(System.Collections.Generic.IEnumerable{Deedle.OptionalValue{``0}})">
<summary>
 Missing values can be specified explicitly as `OptionalValue.Missing`, but 
 other values such as `null` and `Double.NaN` are turned into missing values too.
</summary>
</member>
<member name="M:Deedle.F# Vector extensions.Vector.ofOptionalValues``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Creates a vector that stores the specified data in an array.
 Missing values can be specified explicitly as `None`, but other values 
 such as `null` and `Double.NaN` are turned into missing values too.
</summary>
</member>
<member name="T:Deedle.F# Vector extensions.Vector">
<summary>
 Type that provides a simple access to creating vectors represented
 using the built-in `ArrayVector` type that stores the data in a 
 continuous block of memory.
</summary>
</member>
<member name="T:Deedle.F# Vector extensions">
<summary>
 Defines non-generic `Vector` type that provides functions for building vectors
 (hard-bound to `ArrayVectorBuilder` type). In F#, the module is automatically opened
 using `AutoOpen`. The methods are not designed for the use from C#.

 [category:Vectors and indices]
</summary>
</member>
<member name="M:Deedle.F# Vector extensions (core).IVector`1.get_DataSequence``1(Deedle.IVector{``0})">
<summary>
 Returns the data of the vector as a lazy sequence. (This preserves the 
 order of elements in the vector and so it also returns missing values.)
</summary>
</member>
<member name="M:Deedle.F# Vector extensions (core).IVector`1.Select``2(Deedle.IVector{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Apply the specified function to all values stored in the vector and return
 a new vector (not necessarily of the same representation) with the results.
 The function skips missing values.
</summary>
</member>
<member name="T:Deedle.F# Vector extensions (core)">
<summary>
 Module with extensions for generic vector type. Given `vec` of type `IVector&lt;T&gt;`, 
 the extension property `vec.DataSequence` returns all data of the vector converted
 to the &quot;least common denominator&quot; data structure - `IEnumerable&lt;T&gt;`.

 [category:Vectors and indices]
</summary>
</member>
<member name="P:Deedle.F# VectorBuilder implementation.VectorBuilder.Instance">
<summary>
 Returns concrete implementation for IVectorBuilder
</summary>
</member>
<member name="T:Deedle.F# VectorBuilder implementation">
<summary>
 Set concrete IVectorBuilder implementation

 [category:Vectors and indices]
</summary>
</member>
<member name="T:Deedle.FrameBuilder">
<summary>
 Type that can be used for creating frames using the C# collection initializer syntax.
 You can use `new FrameBuilder.Columns&lt;...&gt;` to create a new frame from columns or you
 can use `new FrameBuilder.Rows&lt;...&gt;` to create a new frame from rows.

 ## Example
 The following creates a new frame with columns `Foo` and `Bar`:
 
     var sampleFrame =
       new FrameBuilder.Columns&lt;int, string&gt; {
         { &quot;Foo&quot;, new SeriesBuilder&lt;int&gt; { {1,11.1}, {2,22.4} }.Series }
         { &quot;Bar&quot;, new SeriesBuilder&lt;int&gt; { {1,42.42} }.Series }
       }.Frame;

 [category:Frame and series operations]
</summary>
</member>
<member name="M:Deedle.FrameModule.Unnest``3(Deedle.Series{``0,Deedle.Frame{``1,``2}})">
<summary>
 Given a series of frames, returns a new data frame with two-level hierarchical
 row index, using the series keys as the first component. This function is the
 dual of `Frame.nest`.

 [category:Hierarchical index operations]
</summary>
</member>
<member name="M:Deedle.FrameModule.NestBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Frame{``0,``2})">
<summary>
 Given a data frame, use the specified `keySelector` to generate a new, first-level
 of indices based on the current indices. Returns a series (indexed by the first-level)
 of frames (indexed by the second-level). 

 [category:Hierarchical index operations]
</summary>
</member>
<member name="M:Deedle.FrameModule.Nest``3(Deedle.Frame{System.Tuple{``0,``1},``2})">
<summary>
 Given a frame with two-level row index, returns a series indexed by the first
 part of the key, containing frames representing individual groups. This function
 can be used if you want to perform a transformation individually on each group
 (e.g. using `Series.mapValues` after calling `Frame.nest`).

 [category:Hierarchical index operations]
</summary>
</member>
<member name="M:Deedle.FrameModule.ApplyLevel``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``2},``2},Deedle.Frame{``0,``3})">
<summary>
 Apply a specified function to a group of values in each series according to the specified 
 level of a hierarchical row key. For each group of rows as specified by `levelSel`, the function 
 applies the specified function `op` to all columns. Columns that cannot be converted to a 
 type required by `op` are skipped. 

 ## Example
 To get the standard deviation of values in all numerical columns according to the first 
 component of a two level row key `&apos;K1 * &apos;K2`, you can use the following:

     df |&gt; Frame.applyLevel fst Stats.stdDev
 ## Remarks
 This function reduces a series of values using a function `Series&lt;&apos;R, &apos;T&gt; -&gt; &apos;T`. If
 you want to reduce values using a simpler function `&apos;T -&gt; &apos;T -&gt; &apos;T`, you can use
 `Frame.reduceLevel` instead.

 [category:Hierarchical index operations]
</summary>
</member>
<member name="M:Deedle.FrameModule.ReduceLevel``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``2,``2}},Deedle.Frame{``0,``3})">
<summary>
 Reduce the values in each series according to the specified level of a hierarchical row key.
 For each group of rows as specified by `levelSel`, the function reduces the values in each series 
 using the preovided function `op` by applying `Series.reduceLevel`. Columns that cannot be
 converted to a type required by `op` are skipped.

 ## Example
 To sum the values in all numerical columns according to the first component of a two level
 row key `&apos;K1 * &apos;K2`, you can use the following:

     df |&gt; Frame.reduceLevel fst (fun (a:float) b -&gt; a + b)
 ## Remarks
 This function reduces values using a function `&apos;T -&gt; &apos;T -&gt; &apos;T`. If you want to process
 an entire group of values at once, you can use `applyLevel` instead.

 [category:Hierarchical index operations]
</summary>
</member>
<member name="M:Deedle.FrameModule.ZipInto``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Deedle.Frame{``3,``4},Deedle.Frame{``3,``4})">
<summary>
 Aligns two data frames using both column index and row index and apply the specified operation
 on values of a specified type that are available in both data frames. This overload uses
 `JoinKind.Outer` for both columns and rows.

 Once aligned, the call `df1.Zip&lt;T&gt;(df2, f)` applies the specifed function `f` on all `T` values
 that are available in corresponding locations in both frames. For values of other types, the 
 value from `df1` is returned.

 ## Parameters
  - `frame1` - First frame to be aligned and zipped with the other instance
  - `frame2` - Other frame to be aligned and zipped with the first  instance
  - `columnKind` - Specifies how to align columns (inner, outer, left or right join)
  - `rowKind` - Specifies how to align rows (inner, outer, left or right join)
  - `lookup` - Specifies how to find matching value for a row (when using left or right join on rows)
  - `op` - A function that is applied to aligned values. The `Zip` operation is generic
    in the type of this function and the type of function is used to determine which 
    values in the frames are zipped and which are left unchanged.

 [category:Joining, merging and zipping]
</summary>
</member>
<member name="M:Deedle.FrameModule.ZipAlignInto``5(Deedle.JoinKind,Deedle.JoinKind,Deedle.Lookup,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Deedle.Frame{``3,``4},Deedle.Frame{``3,``4})">
<summary>
 Aligns two data frames using both column index and row index and apply the specified operation
 on values of a specified type that are available in both data frames. The parameters `columnKind`,
 and `rowKind` can be specified to determine how the alginment works (similarly to `Join`).
 Column keys are always matched using `Lookup.Exact`, but `lookup` determines lookup for rows.

 Once aligned, the call `df1.Zip&lt;T&gt;(df2, f)` applies the specifed function `f` on all `T` values
 that are available in corresponding locations in both frames. For values of other types, the 
 value from `df1` is returned.

 ## Parameters
  - `frame1` - First frame to be aligned and zipped with the other instance
  - `frame2` - Other frame to be aligned and zipped with the first  instance
  - `columnKind` - Specifies how to align columns (inner, outer, left or right join)
  - `rowKind` - Specifies how to align rows (inner, outer, left or right join)
  - `lookup` - Specifies how to find matching value for a row (when using left or right join on rows)
  - `op` - A function that is applied to aligned values. The `Zip` operation is generic
    in the type of this function and the type of function is used to determine which 
    values in the frames are zipped and which are left unchanged.

 [category:Joining, merging and zipping]
</summary>
</member>
<member name="M:Deedle.FrameModule.Merge``2(Deedle.Frame{``0,``1},Deedle.Frame{``0,``1})">
<summary>
 Append two data frames with non-overlapping values. The operation takes the union of columns
 and rows of the source data frames and then unions the values. An exception is thrown when 
 both data frames define value for a column/row location, but the operation succeeds if one
 frame has a missing value at the location.

 Note that the rows are *not* automatically reindexed to avoid overlaps. This means that when
 a frame has rows indexed with ordinal numbers, you may need to explicitly reindex the row
 keys before calling append.

 ## Parameters
  - `frame1` - First of the two frames to be merged (combined)
  - `frame2` - The other frame to be merged (combined) with the first instance

 [category:Joining, merging and zipping]
</summary>
</member>
<member name="M:Deedle.FrameModule.MergeAll``2(System.Collections.Generic.IEnumerable{Deedle.Frame{``0,``1}})">
<summary>
 Append a sequence of data frames with non-overlapping values. The operation takes the union of 
 columns and rows of the source data frames and then unions the values. An exception is thrown when 
 both data frames define value for a column/row location, but the operation succeeds if one
 all frames but one has a missing value at the location.

 Note that the rows are *not* automatically reindexed to avoid overlaps. This means that when
 a frame has rows indexed with ordinal numbers, you may need to explicitly reindex the row
 keys before calling append.

 [category:Joining, merging and zipping]
</summary>
</member>
<member name="M:Deedle.FrameModule.JoinAlign``2(Deedle.JoinKind,Deedle.Lookup,Deedle.Frame{``0,``1},Deedle.Frame{``0,``1})">
<summary>
 Join two data frames. The columns of the joined frames must not overlap and their
 rows are aligned and transformed according to the specified join kind.
 When the index of both frames is ordered, it is possible to specify `lookup` 
 in order to align indices from other frame to the indices of the main frame
 (typically, to find the nearest key with available value for a key).

 ## Parameters
  - `frame1` - First data frame (left) to be used in the joining
  - `frame2` - Other frame (right) to be joined with `frame1`
  - `kind` - Specifies the joining behavior on row indices. Use `JoinKind.Outer` and 
    `JoinKind.Inner` to get the union and intersection of the row keys, respectively.
    Use `JoinKind.Left` and `JoinKind.Right` to use the current key of the left/right
    data frame.
  - `lookup` - When `kind` is `Left` or `Right` and the two frames have ordered row index,
    this parameter can be used to specify how to find value for a key when there is no
    exactly matching key or when there are missing values.

 [category:Joining, merging and zipping]
</summary>
</member>
<member name="M:Deedle.FrameModule.Join``2(Deedle.JoinKind,Deedle.Frame{``0,``1},Deedle.Frame{``0,``1})">
<summary>
 Join two data frames. The columns of the joined frames must not overlap and their
 rows are aligned and transformed according to the specified join kind.
 For more alignment options on ordered frames, see `joinAlign`.

 ## Parameters
  - `frame1` - First data frame (left) to be used in the joining
  - `frame2` - Other frame (right) to be joined with `frame1`
  - `kind` - Specifies the joining behavior on row indices. Use `JoinKind.Outer` and 
    `JoinKind.Inner` to get the union and intersection of the row keys, respectively.
    Use `JoinKind.Left` and `JoinKind.Right` to use the current key of the left/right
    data frame.

 [category:Joining, merging and zipping]
</summary>
</member>
<member name="M:Deedle.FrameModule.DenseRows``2(Deedle.Frame{``0,``1})">
<summary>
 Returns the rows of the data frame that do not have any missing values. 
 The operation returns a series (indexed by the row keys of the source frame) 
 containing _series_ representing individual row of the frame. This is similar 
 to `Rows`, but it skips rows that contain missing value in _any_ column.

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.FrameModule.DenseColumns``2(Deedle.Frame{``0,``1})">
<summary>
 Returns the columns of the data frame that do not have any missing values.
 The operation returns a series (indexed by the column keys of the source frame) 
 containing _series_ representing individual columns of the frame. This is similar 
 to `Columns`, but it skips columns that contain missing value in _any_ row.

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.FrameModule.DropSparseColumns``2(Deedle.Frame{``0,``1})">
<summary>
 Creates a new data frame that contains only those columns of the original 
 data frame that are _dense_, meaning that they have a value for each row.
 The resulting data frame has the same number of rows, but may have 
 fewer columns (or no columns at all).

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.FrameModule.DropSparseRows``2(Deedle.Frame{``0,``1})">
<summary>
 Creates a new data frame that contains only those rows of the original 
 data frame that are _dense_, meaning that they have a value for each column.
 The resulting data frame has the same number of columns, but may have 
 fewer rows (or no rows at all).
 
 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.FrameModule.FillMissingUsing``3(Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Deedle.Frame{``0,``2})">
<summary>
 Fill missing values in the frame using the specified function. The specified
 function is called with all series and keys for which the frame does not 
 contain value and the result of the call is used in place of the missing value.

 The operation is only applied to columns (series) that contain values of the
 same type as the return type of the provided filling function. The operation 
 does not attempt to convert between numeric values (so a series containing 
 `float` will not be converted to a series of `int`).

 ## Parameters
  - `frame` - An input data frame that is to be filled
  - `f` - A function that takes a series `Series&lt;R, T&gt;` together with a key `K` 
    in the series and generates a value to be used in a place where the original 
    series contains a missing value.

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.FrameModule.FillMissing``2(Deedle.Direction,Deedle.Frame{``0,``1})">
<summary>
 Fill missing values in the data frame with the nearest available value
 (using the specified direction). Note that the frame may still contain
 missing values after call to this function (e.g. if the first value is not available
 and we attempt to fill series with previous values). This operation can only be
 used on ordered frames.

 ## Parameters
  - `frame` - An input data frame that is to be filled
  - `direction` - Specifies the direction used when searching for 
    the nearest available value. `Backward` means that we want to
    look for the first value with a smaller key while `Forward` searches
    for the nearest greater key.

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.FrameModule.FillMissingWith``3(``0,Deedle.Frame{``1,``2})">
<summary>
 Fill missing values of a given type in the frame with a constant value.
 The operation is only applied to columns (series) that contain values of the
 same type as the provided filling value. The operation does not attempt to 
 convert between numeric values (so a series containing `float` will not be
 converted to a series of `int`).

 ## Parameters
  - `frame` - An input data frame that is to be filled
  - `value` - A constant value that is used to fill all missing values

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.FrameModule.FillErrorsWith``3(``0,Deedle.Frame{``1,``2})">
<summary>
 Fills all error cases of a `tryval&lt;&apos;T&gt;` value in a data frame with the specified 
 `value`. The function takes all columns of type `tryval&lt;&apos;T&gt;` and uses `Series.fillErrorsWith`
 to fill the error values with the specified default value.
 
 [category:Processing frames with exceptions]
</summary>
</member>
<member name="M:Deedle.FrameModule.TryValues``2(Deedle.Frame{``0,``1})">
<summary>
 Given a data frame containing columns of type `tryval&lt;&apos;T&gt;`, returns a new data frame
 that contains the underlying values of type `&apos;T`. When the frame contains one or more 
 failures, the operation throws `AggregateException`. Otherwise, it returns a frame containing values.

 [category:Processing frames with exceptions]
</summary>
</member>
<member name="M:Deedle.FrameModule.TryMapRows``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Deedle.ObjectSeries{``1},``2}},Deedle.Frame{``0,``1})">
<summary>
 Returns a series, obtained by applying the specified projection function `f` to all rows
 of the input frame. The resulting series wraps the results in `tryval&lt;&apos;V&gt;`. When the projection 
 function fails, the exception is wrapped using the `Error` case.

 [category:Processing frames with exceptions]
</summary>
</member>
<member name="M:Deedle.FrameModule.Diff``2(System.Int32,Deedle.Frame{``0,``1})">
<summary>
 Returns a frame with columns containing difference between an original value and
 a value at the specified offset. For example, calling `Frame.diff 1 s` returns a 
 frame where previous column values is subtracted from the current ones. In pseudo-code, the
 function behaves as follows:

     result[k] = series[k] - series[k - offset]

 Columns that cannot be converted to `float` are left without a change.

 ## Parameters
  - `offset` - When positive, subtracts the past values from the current values;
    when negative, subtracts the future values from the current values.
  - `frame` - The input frame containing at least some `float` columns.

 [category:Frame transformations]
</summary>
</member>
<member name="M:Deedle.FrameModule.Shift``2(System.Int32,Deedle.Frame{``0,``1})">
<summary>
 Returns a frame with columns shifted by the specified offset. When the offset is 
 positive, the values are shifted forward and first `offset` keys are dropped. When the
 offset is negative, the values are shifted backwards and the last `offset` keys are dropped.
 Expressed in pseudo-code:

     result[k] = series[k - offset]

 ## Parameters
  - `offset` - Can be both positive and negative number.
  - `frame` - The input frame whose columns are to be shifted.

 ## Remarks
 If you want to calculate the difference, e.g. `df - (Frame.shift 1 df)`, you can
 use `Frame.diff` which will be a little bit faster.

 [category:Frame transformations]
</summary>
</member>
<member name="M:Deedle.FrameModule.MinRowBy``2(``0,Deedle.Frame{``1,``0})">
<summary>
 Returns a row of the data frame which has the smallest value of the
 specified `column`. The row is returned as an optional value (which is
 `None` for empty frame) and contains a key together with an object
 series representing the row.

 [category:Frame transformations]
</summary>
</member>
<member name="M:Deedle.FrameModule.MaxRowBy``2(``0,Deedle.Frame{``1,``0})">
<summary>
 Returns a row of the data frame which has the greatest value of the
 specified `column`. The row is returned as an optional value (which is
 `None` for empty frame) and contains a key together with an object
 series representing the row.

 [category:Frame transformations]
</summary>
</member>
<member name="M:Deedle.FrameModule.ReduceValues``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Deedle.Frame{``1,``2})">
<summary>
 Returns a series that contains the results of aggregating each column
 to a single value. The function takes columns that can be converted to 
 the type expected by the specified `op` function and reduces the values
 in each column using `Series.reduceValues`. 

 ## Example
 The following sums the values in each column that can be converted to
 `float` and returns the result as a new series:

     df |&gt; Frame.reduceValues (fun (a:float) b -&gt; a + b)

 [category:Frame transformations]
</summary>
</member>
<member name="M:Deedle.FrameModule.map``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},Deedle.Frame{``0,``1})">
<summary>
 Builds a new data frame whose values are the results of applying the specified
 function on these values, but only for those columns which can be converted 
 to the appropriate type for input to the mapping function. 

 ## Parameters
  - `frame` - Input data frame to be transformed
  - `f` - Function that defines the mapping

 [category:Frame transformations]
</summary>
</member>
<member name="M:Deedle.FrameModule.MapValues``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Frame{``2,``3})">
<summary>
 Builds a new data frame whose values are the results of applying the specified
 function on these values, but only for those columns which can be converted 
 to the appropriate type for input to the mapping function (use `map` if you need 

 ## Parameters
  - `frame` - Input data frame to be transformed
  - `f` - Function that defines the mapping

 [category:Frame transformations]
</summary>
</member>
<member name="M:Deedle.FrameModule.SelectColumnKeys``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Frame{``2,``0})">
<summary>
 Builds a new data frame whose column keys are the results of applying the
 specified function on the column keys of the original data frame.

 ## Parameters
  - `frame` - Input data frame to be transformed
  - `f` - Function of one argument that defines the column key mapping

 [category:Frame transformations]
</summary>
</member>
<member name="M:Deedle.FrameModule.SelectColumnValues``4(Microsoft.FSharp.Core.FSharpFunc{Deedle.ObjectSeries{``0},``1},Deedle.Frame{``0,``3})">
<summary>
 Builds a new data frame whose columns are the results of applying the specified
 function on the columns of the input data frame. The function is called
 with an object series that represents the column data (use `mapCols`
 if you need to access the column key).

 ## Parameters
  - `frame` - Input data frame to be transformed
  - `f` - Function of one argument that defines the column mapping

 [category:Frame transformations]
</summary>
</member>
<member name="M:Deedle.FrameModule.SelectColumns``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Deedle.ObjectSeries{``1},``2}},Deedle.Frame{``1,``0})">
<summary>
 Builds a new data frame whose columns are the results of applying the specified
 function on the columns of the input data frame. The function is called
 with the column key and object series that represents the column data.

 ## Parameters
  - `frame` - Input data frame to be transformed
  - `f` - Function of two arguments that defines the column mapping

 [category:Frame transformations]
</summary>
</member>
<member name="M:Deedle.FrameModule.WhereColumnValues``2(Microsoft.FSharp.Core.FSharpFunc{Deedle.ObjectSeries{``0},System.Boolean},Deedle.Frame{``0,``1})">
<summary>
 Returns a new data frame containing only the columns of the input frame
 for which the specified predicate returns `true`. The predicate is called
 with an object series that represents the column data (use `filterCols`
 if you need to access the column key).

 ## Parameters
  - `frame` - Input data frame to be transformed
  - `f` - Function of one argument that defines the predicate

 [category:Frame transformations]
</summary>
</member>
<member name="M:Deedle.FrameModule.WhereColumns``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Deedle.ObjectSeries{``1},System.Boolean}},Deedle.Frame{``1,``0})">
<summary>
 Returns a new data frame containing only the columns of the input frame
 for which the specified predicate returns `true`. The predicate is called
 with the column key and object series that represents the column data.

 ## Parameters
  - `frame` - Input data frame to be transformed
  - `f` - Function of two arguments that defines the predicate

 [category:Frame transformations]
</summary>
</member>
<member name="M:Deedle.FrameModule.SelectRowKeys``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Frame{``0,``2})">
<summary>
 Builds a new data frame whose row keys are the results of applying the
 specified function on the row keys of the original data frame.

 ## Parameters
  - `frame` - Input data frame to be transformed
  - `f` - Function of one argument that defines the row key mapping

 [category:Frame transformations]
</summary>
</member>
<member name="M:Deedle.FrameModule.SelectRowValues``3(Microsoft.FSharp.Core.FSharpFunc{Deedle.ObjectSeries{``0},``1},Deedle.Frame{``2,``0})">
<summary>
 Builds a new data frame whose rows are the results of applying the specified
 function on the rows of the input data frame. The function is called
 with an object series that represents the row data (use `mapRows`
 if you need to access the row key).

 ## Parameters
  - `frame` - Input data frame to be transformed
  - `f` - Function of one argument that defines the row mapping

 [category:Frame transformations]
</summary>
</member>
<member name="M:Deedle.FrameModule.SelectRows``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Deedle.ObjectSeries{``1},``2}},Deedle.Frame{``0,``1})">
<summary>
 Builds a new data frame whose rows are the results of applying the specified
 function on the rows of the input data frame. The function is called
 with the row key and object series that represents the row data.

 ## Parameters
  - `frame` - Input data frame to be transformed
  - `f` - Function of two arguments that defines the row mapping

 [category:Frame transformations]
</summary>
</member>
<member name="M:Deedle.FrameModule.WhereRowsBy``3(``0,``1,Deedle.Frame{``2,``0})">
<summary>
 Returns a new data frame containing only the rows of the input frame
 for which the specified `column` has the specified `value`. The operation
 may be implemented via an index for virtualized Deedle frames.
 
 ## Parameters
  - `frame` - Input data frame to be transformed
  - `column` - The name of the column to be matched
  - `value` - Required value of the column. Note that the function
    is generic and no conversions are performed, so the value has
    to match including the actual type.

 [category:Frame transformations]
</summary>
</member>
<member name="M:Deedle.FrameModule.WhereRowValues``2(Microsoft.FSharp.Core.FSharpFunc{Deedle.ObjectSeries{``0},System.Boolean},Deedle.Frame{``1,``0})">
<summary>
 Returns a new data frame containing only the rows of the input frame
 for which the specified predicate returns `true`. The predicate is called
 with an object series that represents the row data (use `filterRows`
 if you need to access the row key).

 ## Parameters
  - `frame` - Input data frame to be transformed
  - `f` - Function of one argument that defines the predicate

 [category:Frame transformations]
</summary>
</member>
<member name="M:Deedle.FrameModule.WhereRows``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Deedle.ObjectSeries{``1},System.Boolean}},Deedle.Frame{``0,``1})">
<summary>
 Returns a new data frame containing only the rows of the input frame
 for which the specified predicate returns `true`. The predicate is called
 with the row key and object series that represents the row data.

 ## Parameters
  - `frame` - Input data frame to be transformed
  - `f` - Function of two arguments that defines the predicate

 [category:Frame transformations]
</summary>
</member>
<member name="M:Deedle.FrameModule.SkipLast``2(System.Int32,Deedle.Frame{``0,``1})">
<summary>
 Returns a frame that contains the data from the original frame,
 except for the last `count` rows; `count` must be smaller or equal to the
 original number of rows.

 [category:Frame transformations]
</summary>
</member>
<member name="M:Deedle.FrameModule.Skip``2(System.Int32,Deedle.Frame{``0,``1})">
<summary>
 Returns a frame that contains the data from the original frame,
 except for the first `count` rows; `count` must be smaller or equal 
 to the original number of rows.

 [category:Frame transformations]
</summary>
</member>
<member name="M:Deedle.FrameModule.TakeLast``2(System.Int32,Deedle.Frame{``0,``1})">
<summary>
 Returns a frame that contains the specified `count` of rows from the 
 original frame. The rows are taken from the end of the frame; `count`
 must be smaller or equal to the original number of rows.

 [category:Frame transformations]
</summary>
</member>
<member name="M:Deedle.FrameModule.Take``2(System.Int32,Deedle.Frame{``0,``1})">
<summary>
 Returns a frame that contains the specified `count` of rows from the 
 original frame; `count` must be smaller or equal to the original number of rows.

 [category:Frame transformations]
</summary>
</member>
<member name="M:Deedle.FrameModule.getRange``2(System.Int64,System.Int64,Deedle.Frame{``0,``1})">
<summary>
 Internal helper used by `skip`, `take`, etc.
</summary>
</member>
<member name="M:Deedle.FrameModule.ExpandColumns``1(System.Collections.Generic.IEnumerable{System.String},Deedle.Frame{``0,System.String})">
<summary>
 Creates a new data frame where the specified columns are expanded based on runtime
 structure of the objects they store. A column can be expanded if it is 
 `Series&lt;string, T&gt;` or `IDictionary&lt;K, V&gt;` or if it is any .NET object with readable
 properties. 

 ## Example
 Given a data frame with a series that contains tuples, you can expand the
 tuple members and get a frame with columns `S.Item1` and `S.Item2`:
 
     let df = frame [ &quot;S&quot; =&gt; series [ 1 =&gt; (1, &quot;One&quot;); 2 =&gt; (2, &quot;Two&quot;) ] ]  
     df |&gt; Frame.expandCols [&quot;S&quot;]

 ## Parameters
  - `names` - Names of columns in the original data frame to be expanded
  - `frame` - Input data frame whose columns will be expanded

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.ExpandAllColumns``1(System.Int32,Deedle.Frame{``0,System.String})">
<summary>
 Creates a new data frame where all columns are expanded based on runtime
 structure of the objects they store. The expansion is performed recrusively
 to the specified depth. A column can be expanded if it is `Series&lt;string, T&gt;` 
 or `IDictionary&lt;K, V&gt;` or if it is any .NET object with readable
 properties. 

 ## Parameters
  - `nesting` - The nesting level for expansion. When set to 0, nothing is done.
  - `frame` - Input data frame whose columns will be expanded

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.SortColumnsByKey``2(Deedle.Frame{``0,``1})">
<summary>
 Returns a data frame that contains the same data as the input, 
 but whose columns are an ordered series. This allows using operations that are
 only available on indexed series such as alignment and inexact lookup.

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.SortRowBy``4(``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2},Deedle.Frame{``3,``0})">
<summary>
 Returns a data frame that contains the same data as the input, 
 but whose rows are ordered on a particular column of the frame. 

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.SortRowsWith``3(``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,System.Int32}},Deedle.Frame{``2,``0})">
<summary>
 Returns a data frame that contains the same data as the input, 
 but whose rows are ordered on a particular column of the frame. 

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.SortRows``2(``0,Deedle.Frame{``1,``0})">
<summary>
 Returns a data frame that contains the same data as the input, 
 but whose rows are ordered on a particular column of the frame. 

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.SortRowsByKey``2(Deedle.Frame{``0,``1})">
<summary>
 Returns a data frame that contains the same data as the input, 
 but whose rows are an ordered series. This allows using operations that are
 only available on indexed series such as alignment and inexact lookup.

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.Transpose``2(Deedle.Frame{``0,``1})">
<summary>
 Returns a transposed data frame. The rows of the original data frame are used as the
 columns of the new one (and vice versa). Use this operation if you have a data frame
 and you mostly need to access its rows as a series (because accessing columns as a 
 series is more efficient).
 
 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.IndexRowsUsing``3(Microsoft.FSharp.Core.FSharpFunc{Deedle.ObjectSeries{``0},``1},Deedle.Frame{``2,``0})">
<summary>
 Replace the row index of the frame with a sequence of row keys generated using
 a function invoked on each row.

 ## Parameters
  - `frame` - Source data frame whose row index are to be replaced.
  - `f` - A function from row (as object series) to new row key value

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.IndexRowsOrdinally``2(Deedle.Frame{``0,``1})">
<summary>
 Replace the row index of the frame with ordinarilly generated integers starting from zero.
 The rows of the frame are assigned index according to the current order, or in a
 non-deterministic way, if the current row index is not ordered.

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.IndexRowsWith``3(System.Collections.Generic.IEnumerable{``0},Deedle.Frame{``1,``2})">
<summary>
 Replace the row index of the frame with the provided sequence of row keys.
 The rows of the frame are assigned keys according to the provided order.

 ## Parameters
  - `frame` - Source data frame whose row index are to be replaced.
  - `keys` - A collection of new row keys.

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.IndexColumnsWith``3(System.Collections.Generic.IEnumerable{``0},Deedle.Frame{``1,``2})">
<summary>
 Replace the column index of the frame with the provided sequence of column keys.
 The columns of the frame are assigned keys according to the provided order.
 The specified column is removed from the resulting frame.

 ## Parameters
  - `frame` - Source data frame whose column index are to be replaced.
  - `keys` - A collection of new column keys.

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.IndexRowsByString``2(``0,Deedle.Frame{``1,``0})">
<summary>
 Returns a data frame whose rows are indexed based on the specified column of the original
 data frame. This function casts (or converts) the column key to values of type `string`
 (a generic variant that may require some type annotation is `Frame.indexRows`)
 The specified column is removed from the resulting frame.

 ## Parameters
  - `frame` - Source data frame whose row index is to be replaced.
  - `column` - The name of a column in the original data frame that will be used for the new
    index. Note that the values in the column need to be unique.

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.IndexRowsByDateTimeOffset``2(``0,Deedle.Frame{``1,``0})">
<summary>
 Returns a data frame whose rows are indexed based on the specified column of the original
 data frame. This function casts (or converts) the column key to values of type `DateTimeOffset`
 (a generic variant that may require some type annotation is `Frame.indexRows`)
 The specified column is removed from the resulting frame.

 ## Parameters
  - `frame` - Source data frame whose row index is to be replaced.
  - `column` - The name of a column in the original data frame that will be used for the new
    index. Note that the values in the column need to be unique.

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.IndexRowsByDateTime``2(``0,Deedle.Frame{``1,``0})">
<summary>
 Returns a data frame whose rows are indexed based on the specified column of the original
 data frame. This function casts (or converts) the column key to values of type `DateTime`
 (a generic variant that may require some type annotation is `Frame.indexRows`)
 The specified column is removed from the resulting frame.

 ## Parameters
  - `frame` - Source data frame whose row index is to be replaced.
  - `column` - The name of a column in the original data frame that will be used for the new
    index. Note that the values in the column need to be unique.

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.IndexRowsByInt``2(``0,Deedle.Frame{``1,``0})">
<summary>
 Returns a data frame whose rows are indexed based on the specified column of the original
 data frame. This function casts (or converts) the column key to values of type `int`
 (a generic variant that may require some type annotation is `Frame.indexRows`)
 The specified column is removed from the resulting frame.

 ## Parameters
  - `frame` - Source data frame whose row index is to be replaced.
  - `column` - The name of a column in the original data frame that will be used for the new
    index. Note that the values in the column need to be unique.

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.IndexRowsByObject``2(``0,Deedle.Frame{``1,``0})">
<summary>
 Returns a data frame whose rows are indexed based on the specified column of the original
 data frame. This function casts (or converts) the column key to values of type `obj`
 (a generic variant that may require some type annotation is `Frame.indexRows`)
 The specified column is removed from the resulting frame.

 ## Parameters
  - `frame` - Source data frame whose row index is to be replaced.
  - `column` - The name of a column in the original data frame that will be used for the new
    index. Note that the values in the column need to be unique.

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.IndexRows``3(``0,Deedle.Frame{``1,``0})">
<summary>
 Returns a data frame whose rows are indexed based on the specified column of the original
 data frame. The generic type parameter is specifies the type of the values in the required 
 index column (and usually needs to be specified using a type annotation). The specified
 column is removed from the resulting frame.

 ## Parameters
  - `frame` - Source data frame whose row index is to be replaced.
  - `column` - The name of a column in the original data frame that will be used for the new
    index. Note that the values in the column need to be unique.

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.RealignRows``2(System.Collections.Generic.IEnumerable{``0},Deedle.Frame{``0,``1})">
<summary>
 Align the existing data to a specified collection of row keys. Values in the data frame
 that do not match any new key are dropped, new keys (that were not in the original data 
 frame) are assigned missing values.

 ## Parameters
  - `frame` - Source data frame that is to be realigned.
  - `keys` - A sequence of new row keys. The keys must have the same type as the original
    frame keys (because the rows are realigned).

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.Unstack``3(Deedle.Frame{``0,System.String})">
<summary>
 This function is the opposite of `stack`. It takes a data frame
 with three columns named `Row`, `Column` and `Value` and reconstructs
 a data frame by using `Row` and `Column` as row and column index keys,
 respectively.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.FrameModule.Stack``2(Deedle.Frame{``0,``1})">
<summary>
 Returns a data frame with three columns named `Row`, `Column`
 and `Value` that contains the data of the original data frame 
 in individual rows.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.FrameModule.WindowInto``3(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Deedle.Frame{``0,``1},``2},Deedle.Frame{``0,``1})">
<summary>
 Creates a sliding window using the specified size and then applies the provided 
 value selector `f` on each window to produce the result which is returned as a new series. 
 This function skips incomplete chunks. 

 ## Parameters
  - `size` - The size of the sliding window.
  - `frame` - The input frame to be aggregated.
  - `f` - A function that is called on each created window.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.FrameModule.Window``2(System.Int32,Deedle.Frame{``0,``1})">
<summary>
 Creates a sliding window using the specified size. The result is a series
 containing data frames that represent individual windows.
 This function skips incomplete chunks. 

 ## Parameters
  - `size` - The size of the sliding window.
  - `frame` - The input frame to be aggregated.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.FrameModule.PivotTable``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Deedle.ObjectSeries{``1},``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Deedle.ObjectSeries{``1},``3}},Microsoft.FSharp.Core.FSharpFunc{Deedle.Frame{``0,``1},``4},Deedle.Frame{``0,``1})">
<summary>
 Creates a new data frame resulting from a &apos;pivot&apos; operation. Consider a denormalized data 
 frame representing a table: column labels are field names &amp; table values are observations
 of those fields. pivotTable buckets the rows along two axes, according to the results of 
 the functions `rowGrp` and `colGrp`; and then computes a value for the frame of rows that
 land in each bucket.

 ## Parameters
  - `rowGrp` - A function from rowkey &amp; row to group value for the resulting row index
  - `colGrp` - A function from rowkey &amp; row to group value for the resulting col index
  - `op` - A function computing a value from the corresponding bucket frame 

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.FrameModule.AggregateRowsBy``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``1,``2},``3},Deedle.Frame{``1,``0})">
<summary>
 Returns a data frame whose rows are grouped by `groupBy` and whose columns specified
 in `aggBy` are aggregated according to `aggFunc`.

 ## Parameters
  - `groupBy` - sequence of columns to group by
  - `aggBy` - sequence of columns to apply aggFunc to
  - `aggFunc` - invoked in order to aggregate values

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.FrameModule.GroupRowsByIndex``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Frame{``0,``2})">
<summary>
 Group rows of a data frame using the specified `keySelector`. The selector is called with
 a key of each row and should return a new key. The result is a frame with multi-level index, 
 here the first level is formed by the newly created keys.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.FrameModule.GroupRowsByBool``2(``0,Deedle.Frame{``1,``0})">
<summary>
 Groups the rows of a frame by a specified column in the same way as `groupRowsBy`.
 This function assumes that the values of the specified column are of type `bool`.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.FrameModule.GroupRowsByString``2(``0,Deedle.Frame{``1,``0})">
<summary>
 Groups the rows of a frame by a specified column in the same way as `groupRowsBy`.
 This function assumes that the values of the specified column are of type `string`.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.FrameModule.GroupRowsByInt``2(``0,Deedle.Frame{``1,``0})">
<summary>
 Groups the rows of a frame by a specified column in the same way as `groupRowsBy`.
 This function assumes that the values of the specified column are of type `int`.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.FrameModule.GroupRowsByObj``2(``0,Deedle.Frame{``1,``0})">
<summary>
 Groups the rows of a frame by a specified column in the same way as `groupRowsBy`.
 This function assumes that the values of the specified column are of type `obj`.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.FrameModule.GroupRowsBy``3(``0,Deedle.Frame{``1,``0})">
<summary>
 Group rows of a data frame using the specified `column`. The type of the column is inferred
 from the usage of the resulting frame. The result is a frame with multi-level index, where 
 the first level is formed by the newly created keys. Use `groupRowsBy[Int|String|...]` to
 explicitly specify the type of the column.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.FrameModule.GroupRowsUsing``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Deedle.ObjectSeries{``1},``2}},Deedle.Frame{``0,``1})">
<summary>
 Group rows of a data frame using the specified `selector`. The selector is called with
 a row key and object series representing the row and should return a new key. The result
 is a frame with multi-level index, where the first level is formed by the newly created
 keys.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.FrameModule.ToArray2D``2(Deedle.Frame{``0,``1})">
<summary>
 Returns data of the data frame as a 2D array containing data as `float` values.
 Missing data are represented as `Double.NaN` in the returned array.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.ReplaceColumn``2(``0,Deedle.ISeries{``1},Deedle.Frame{``1,``0})">
<summary>
 Creates a new data frame where the specified column is replaced
 with a new series. (If the series does not exist, only the new
 series is added.)

 ## Parameters
  - `column` - A key (or name) for the column to be replaced or added
  - `series` - A data series to be used (the row key type has to match)
  - `frame` - Source data frame (which is not mutated by the operation)

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.DropColumn``2(``0,Deedle.Frame{``1,``0})">
<summary>
 Creates a new data frame that contains all data from the original
 data frame without the specified series (column). The operation throws
 if the column key is not found.

 ## Parameters
  - `column` - The key (or name) to be dropped from the frame
  - `frame` - Source data frame (which is not mutated by the operation)

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.AddColumn``3(``0,Deedle.Series{``1,``2},Deedle.Frame{``1,``0})">
<summary>
 Creates a new data frame that contains all data from 
 the original data frame, together with an additional series.
 The operation uses left join and aligns new series to the 
 existing frame keys.

 ## Parameters
  - `column` - A key (or name) for the newly added column
  - `series` - A data series to be added (the row key type has to match)
  - `frame` - Source data frame (which is not mutated by the operation)

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.SliceRows``2(System.Collections.Generic.IEnumerable{``0},Deedle.Frame{``0,``1})">
<summary>
 Returns a frame consisting of the specified rows from the original
 data frame. The function uses exact key matching semantics.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.SliceCols``2(System.Collections.Generic.IEnumerable{``0},Deedle.Frame{``1,``0})">
<summary>
 Returns a frame consisting of the specified columns from the original
 data frame. The function uses exact key matching semantics.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.TryLookupRowObservation``3(``0,Deedle.Lookup,Deedle.Frame{``0,``1})">
<summary>
 Returns a specified series (row) and key from a data frame, or missing value if 
 row doesn&apos;t exit.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.TryLookupRow``3(``0,Deedle.Lookup,Deedle.Frame{``0,``1})">
<summary>
 Returns a specified series (row) from a data frame, or missing value if 
 row doesn&apos;t exit.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.LookupRow``3(``0,Deedle.Lookup,Deedle.Frame{``0,``1})">
<summary>
 Returns a specified row from a data frame. If the data frame has 
 ordered row index, the lookup semantics can be used to get row with 
 nearest greater/smaller key. For exact semantics, you can use `getRow`.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.TryLookupColObservation``3(``0,Deedle.Lookup,Deedle.Frame{``1,``0})">
<summary>
 Returns a specified key and series (column) from a data frame, or missing value if 
 doesn&apos;t exist.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.TryLookupColumn``3(``0,Deedle.Lookup,Deedle.Frame{``1,``0})">
<summary>
 Returns a specified series (column) from a data frame, or missing value if 
 column doesn&apos;t exist.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.LookupColumn``3(``0,Deedle.Lookup,Deedle.Frame{``1,``0})">
<summary>
 Returns a specified series (column) from a data frame. If the data frame has 
 ordered column index, the lookup semantics can be used to get series
 with nearest greater/smaller key. For exact semantics, you can use `getCol`.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.GetRows``3(Deedle.Frame{``0,``1})">
<summary>
 Returns a series of rows of the data frame indexed by the row keys, 
 which contains those rows whose values are convertible to &apos;T, and with 
 missing values where the conversion fails.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.GetRow``3(``0,Deedle.Frame{``0,``1})">
<summary>
 Returns a specified row from a data frame. This function uses exact matching 
 semantics on the key. Use `lookupRow` if you want to use inexact matching 
 (e.g. on dates)

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.Rows``2(Deedle.Frame{``0,``1})">
<summary>
 Returns the rows of the data frame as a series (indexed by 
 the row keys of the source frame) containing untyped series representing
 individual row of the frame.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.GetNumericColumns``2(Deedle.Frame{``0,``1})">
<summary>
 Returns a series of columns of the data frame indexed by the column keys, 
 which contains those series whose values are convertible to float, and with 
 missing values where the conversion fails.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.GetColumns``3(Deedle.Frame{``0,``1})">
<summary>
 Returns a series of columns of the data frame indexed by the column keys, 
 which contains those series whose values are convertible to `&apos;T`, and with 
 missing values where the conversion fails.

 If you want to get numeric columns, you can use a simpler `numericCols` function
 instead. Note that this function typically requires a type annotation. This can
 be specified in various ways, for example by annotating the result value:

     let (res:Series&lt;_, Series&lt;_, string&gt;&gt;) = frame |&gt; getCols

 Here, the annotation on the values of the nested series specifies that we want
 to get columns containing `string` values.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.GetColumn``3(``0,Deedle.Frame{``1,``0})">
<summary>
 Returns a specified column from a data frame. This function uses exact matching 
 semantics on the key. Use `lookupCol` if you want to use inexact 
 matching (e.g. on dates)

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.Columns``2(Deedle.Frame{``0,``1})">
<summary>
 Returns the columns of the data frame as a series (indexed by 
 the column keys of the source frame) containing untyped series representing
 individual columns of the frame.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.CountValues``2(Deedle.Frame{``0,``1})">
<summary>
 Returns a series with the total number of values in each column. This counts
 the number of actual values, excluding the missing values or not available 
 values (such as `nan`, `null`, etc.)

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.CountColumns``2(Deedle.Frame{``0,``1})">
<summary>
 Returns the total number of column keys in the specified frame. This returns
 the total length of columns, including keys for which there is no 
 data available.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.CountRows``2(Deedle.Frame{``0,``1})">
<summary>
 Returns the total number of row keys in the specified frame. This returns
 the total length of the row series, including keys for which there is no 
 value available.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="T:Deedle.FrameModule">
<summary>
 The `Frame` module provides an F#-friendly API for working with data frames. 
 The module follows the usual desing for collection-processing in F#, so the 
 functions work well with the pipelining operator (`|&gt;`). For example, given
 a frame with two columns representing prices, we can use `Frame.diff` and 
 numerical operators to calculate daily returns like this:
 
     let df = frame [ &quot;MSFT&quot; =&gt; prices1; &quot;AAPL&quot; =&gt; prices2 ]
     let past = df |&gt; Frame.diff 1
     let rets = past / df * 100.0
     rets |&gt; Stats.mean

 Note that the `Stats.mean` operation is overloaded and works both on series 
 (returning a number) and on frames (returning a series).
 
 The functions in this module are designed to be used from F#. For a C#-friendly
 API, see the `FrameExtensions` type. For working with individual series, see the
 `Series` module. The functions in the `Frame` module are grouped in a number of 
 categories and documented below.

 Accessing frame data and lookup
 -------------------------------

 Functions in this category provide access to the values in the fame. You can 
 also add and remove columns from a frame (which both return a new value).

 - `addCol`, `replaceCol` and `dropCol` can be used to create a new data frame
   with a new column, by replacing an existing column with a new one, or by dropping
   an existing column

 - `cols` and `rows` return the columns or rows of a frame as a series containing
   objects; `getCols` and `getRows` return a generic series and cast the values to
   the type inferred from the context (columns or rows of incompatible types are skipped);
   `getNumericCols` returns columns of a type convertible to `float` for convenience.

 - You can get a specific row or column using `get[Col|Row]` or `lookup[Col|Row]` functions.
   The `lookup` variant lets you specify lookup behavior for key matching (e.g. find the
   nearest smaller key than the specified value). There are also `[try]get` and `[try]Lookup`
   functions that return optional values and functions returning entire observations
   (key together with the series).

 - `sliceCols` and `sliceRows` return a sub-frame containing only the specified columns
   or rows. Finally, `toArray2D` returns the frame data as a 2D array.

 Grouping, windowing and chunking
 --------------------------------

 The basic grouping functions in this category can be used to group the rows of a
 data frame by a specified projection or column to create a frame with hierarchical
 index such as `Frame&lt;&apos;K1 * &apos;K2, &apos;C&gt;`. The functions always aggregate rows, so if you
 want to group columns, you need to use `Frame.transpose` first.

 The function `groupRowsBy` groups rows by the value of a specified column. Use
 `groupRowsBy[Int|Float|String...]` if you want to specify the type of the column in
 an easier way than using type inference; `groupRowsUsing` groups rows using the 
 specified _projection function_ and `groupRowsByIndex` projects the grouping key just
 from the row index.

 More advanced functions include: `aggregateRowsBy` which groups the rows by a 
 specified sequence of columns and aggregates each group into a single value; 
 `pivotTable` implements the pivoting operation [as documented in the 
 tutorials](../frame.html#pivot).

 The `stack` and `unstack` functions turn the data frame into a single data frame
 containing columns `Row`, `Column` and `Value` containing the data of the original
 frame; `unstack` can be used to turn this representation back into an original frame.

 A simple windowing functions that are exposed for an entire frame operations are
 `window` and `windowInto`. For more complex windowing operations, you currently have
 to use `mapRows` or `mapCols` and apply windowing on individual series.

 Sorting and index manipulation
 ------------------------------

 A frame is indexed by row keys and column keys. Both of these indices can be sorted
 (by the keys). A frame that is sorted allows a number of additional operations (such 
 as lookup using the `Lookp.ExactOrSmaller` lookup behavior). The functions in this 
 category provide ways for manipulating the indices. It is expected that most operations
 are done on rows and so more functions are available in a row-wise way. A frame can
 alwyas be transposed using `Frame.transpose`.

 ### Index operations
 
 The existing row/column keys can be replaced by a sequence of new keys using the 
 `indexColsWith` and `indexRowsWith` functions. Row keys can also be replaced by 
 ordinal numbers using `indexRowsOrdinally`.

 The function `indexRows` uses the specified column of the original frame as the 
 index. It removes the column from the resulting frame (to avoid this, use overloaded
 `IndexRows` method). This function infers the type of row keys from the context, so it 
 is usually more convenient to use `indexRows[Date|String|Int|...]` functions. Finally, 
 if you want to calculate the index value based on multiple columns of the row, you
 can use `indexRowsUsing`.

 ### Sorting frame rows
 
 Frame rows can be sorted according to the value of a specified column using the
 `sortRows` function; `sortRowsBy` takes a projection function which lets you 
 transform the value of a column (e.g. to project a part of the value). 

 The functions `sortRowsByKey` and `sortColsByKey` sort the rows or columns 
 using the default ordering on the key values. The result is a frame with ordered
 index.

 ### Expanding columns

 When the frame contains a series with complex .NET objects such as F# records or 
 C# classes, it can be useful to &quot;expand&quot; the column. This operation looks at the 
 type of the objects, gets all properties of the objects (recursively) and 
 generates multiple series representing the properties as columns.

 The function `expandCols` expands the specified columns while `expandAllCols`
 applies the expansion to all columns of the data frame.

 Frame transformations
 ---------------------

 Functions in this category perform standard transformations on data frames including
 projections, filtering, taking some sub-frame of the frame, aggregating values
 using scanning and so on.

 Projection and filtering functions such as `[map|filter][Cols|Rows]` call the 
 specified function with the column or row key and an `ObjectSeries&lt;&apos;K&gt;` representing
 the column or row. You can use functions ending with `Values` (such as `mapRowValues`)
 when you do not require the row key, but only the row series; `mapRowKeys` and 
 `mapColKeys` can be used to transform the keys.

 You can use `reduceValues` to apply a custom reduction to values of columns. Other
 aggregations are available in the `Stats` module. You can also get a row with the 
 greaterst or smallest value of a given column using `[min|max]RowBy`.

 The functions `take[Last]` and `skip[Last]` can be used to take a sub-frame of the
 original source frame by skipping a specified number of rows. Note that this 
 does not require an ordered frame and it ignores the index - for index-based lookup
 use slicing, such as `df.Rows.[lo .. hi]`, instead.

 Finally the `shift` function can be used to obtain a frame with values shifted by 
 the specified offset. This can be used e.g. to get previous value for each key using
 `Frame.shift 1 df`. The `diff` function calculates difference from previous value using
 `df - (Frame.shift offs df)`.

 Processing frames with exceptions
 ---------------------------------
 
 The functions in this group can be used to write computations over frames that may fail.
 They use the type `tryval&lt;&apos;T&gt;` which is defined as a discriminated union:

     type tryval&lt;&apos;T&gt; = 
       | Success of &apos;T
       | Error of exn

 Using `tryval&lt;&apos;T&gt;` as a value in a data frame is not generally recommended, because
 the type of values cannot be tracked in the type. For this reason, it is better to use
 `tryval&lt;&apos;T&gt;` with individual series. However, `tryValues` and `fillErrorsWith` functions
 can be used to get values, or fill failed values inside an entire data frame.

 The `tryMapRows` function is more useful. It can be used to write a transformation
 that applies a computation (which may fail) to each row of a data frame. The resulting
 series is of type `Series&lt;&apos;R, tryval&lt;&apos;T&gt;&gt;` and can be processed using the `Series` module
 functions.

 Missing values
 --------------

 This group of functions provides a way of working with missing values in a data frame.
 The category provides the following functions that can be used to fill missing values:

  * `fillMissingWith` fills missing values with a specified constant
  * `fillMissingUsing` calls a specified function for every missing value
  * `fillMissing` and variants propagates values from previous/later keys

 We use the terms _sparse_ and _dense_ to denote series that contain some missing values
 or do not contain any missing values, respectively. The functions `denseCols` and 
 `denseRows` return a series that contains only dense columns or rows and all sparse
 rows or columns are replaced with a missing value. The `dropSparseCols` and `dropSparseRows`
 functions drop these missing values and return a frame with no missing values.

 Joining, merging and zipping
 ----------------------------

 The simplest way to join two frames is to use the `join` operation which can be used to 
 perform left, right, outer or inner join of two frames. When the row keys of the frames do
 not match exactly, you can use `joinAlign` which takes an additional parameter that specifies
 how to find matching key in left/right join (e.g. by taking the nearest smaller available key).

 Frames that do not contian overlapping values can be combined using `merge` (when combining
 just two frames) or using `mergeAll` (for larger number of frames). Tha latter is optimized
 to work well for a large number of data frames.

 Finally, frames with overlapping values can be combined using `zip`. It takes a function
 that is used to combine the overlapping values. A `zipAlign` function provides a variant
 with more flexible row key matching (as in `joinAlign`)

 Hierarchical index operations
 -----------------------------

 A data frame has a hierarchical row index if the row index is formed by a tuple, such as
 `Frame&lt;&apos;R1 * &apos;R2, &apos;C&gt;`. Frames of this kind are returned, for example, by the grouping 
 functions such as `Frame.groupRowsBy`. The functions in this category provide ways for 
 working with data frames that have hierarchical row keys.

 The functions `applyLevel` and `reduceLevel` can be used to reduce values according to 
 one of the levels. The `applyLevel` function takes a reduction of type `Series&lt;&apos;K, &apos;T&gt; -&gt; &apos;T`
 while `reduceLevel` reduces individual values using a function of type `&apos;T -&gt; &apos;T -&gt; &apos;T`.

 The functions `nest` and `unnest` can be used to convert between frames with 
 hierarchical indices (`Frame&lt;&apos;K1 * &apos;K2, &apos;C&gt;`) and series of frames that represent 
 individual groups (`Series&lt;&apos;K1, Frame&lt;&apos;K2, &apos;C&gt;&gt;`). The `nestBy` function can be 
 used to perform group by operation and return the result as a series of frems.

 [category:Frame and series operations]
</summary>
</member>
<member name="T:Deedle.FrameUtilsModule.IResizeVector">
<summary>
 Helper type for the `readCsv` function - represents a vector that is constructed gradually
 by adding reading strings - and you get an `IVector` with the data at the end
</summary>
</member>
<member name="M:Deedle.FrameUtilsModule.expandColumns``1(Microsoft.FSharp.Collections.FSharpSet{System.String},Deedle.Frame{``0,System.String})">
<summary>
 Expand properties of vectors recursively. Nothing is done when `nesting = 0`.
</summary>
</member>
<member name="M:Deedle.FrameUtilsModule.expandVectors``1(System.Int32,System.Boolean,Deedle.Frame{``0,System.String})">
<summary>
 Expand properties of vectors recursively. Nothing is done when `nesting = 0`.
</summary>
</member>
<member name="M:Deedle.FrameUtilsModule.fromValues``4(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2},Microsoft.FSharp.Core.FSharpFunc{``0,``3})">
<summary>
 Create data frame from a sequence of values using
 projections that return column/row keys and the value
</summary>
</member>
<member name="M:Deedle.FrameUtilsModule.readCsv(System.IO.TextReader,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String[]},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Load data from a CSV file using F# Data API
</summary>
</member>
<member name="M:Deedle.FrameUtilsModule.makeResizeVector``1(Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Creates `IResizeVector` implementation that uses `ResizeArray&lt;&apos;T&gt;` internally
</summary>
</member>
<member name="M:Deedle.FrameUtilsModule.readReader(System.Data.IDataReader)">
<summary>
 Load data frame from a data reader (and cast the values of columns
 to their actual types to create IVector&lt;T&gt; with the right T)
</summary>
</member>
<member name="M:Deedle.FrameUtilsModule.toDataTable``2(System.Collections.Generic.IEnumerable{System.String},Deedle.Frame{``0,``1})">
<summary>
 Export the specified frame to &apos;DataTable&apos;. Caller needs to specify
 keys (headers) for the row keys (there may be more of them for multi-level index)
</summary>
</member>
<member name="M:Deedle.FrameUtilsModule.writeCsv``2(System.IO.TextWriter,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Char},Microsoft.FSharp.Core.FSharpOption{System.Globalization.CultureInfo},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.String}},Deedle.Frame{``0,``1})">
<summary>
 Store data frame to a CSV file using the specified information
 (use TSV format if file ends with .tsv, when including row keys, the
 caller needs to provide headers)
</summary>
</member>
<member name="T:Deedle.Indices.AsyncSeriesConstruction`1">
<summary>
 Asynchronous version of `SeriesConstruction&lt;&apos;K&gt;`. Returns a workflow that evaluates
 the index, together with a construction to apply (asynchronously) on vectors
</summary>
</member>
<member name="T:Deedle.Indices.BoundaryBehavior">
<summary>
 Specifies the boundary behavior for the `IIndexBuilder.GetRange` operation
 (whether the boundary elements should be included or not)
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.WithIndex``2(Deedle.Indices.IIndex{``0},Deedle.IVector{``1},Deedle.Vectors.VectorConstruction)">
<summary>
 Create a new index by picking a new key value for each key in the original index
 (used e.g. when we have a frame and want to use specified column as a new index).
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.Union``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction})">
<summary>
 Creates a union of two indices and builds corresponding vector transformations
 for both vectors that match the left and the right index.
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.Shift``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},System.Int32)">
<summary>
 Shift the values in the series by a specified offset, in a specified direction.
 The resulting series should be shorter by abs(offset); key for which there is no
 value should be dropped. For example:
 
     (original)  (shift 1) (shift -1)
     a b c       _ b c     a b _
     1 2 3         1 2     1 2
 
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.Search``2(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},Deedle.IVector{``1},``1)">
<summary>
 Get a series construction that restricts the range of the input to only 
 locations where the specified vector contains the specified value.
 (used to filter frame rows according to a column value)
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.Resample``3(Deedle.Indices.IIndexBuilder,Deedle.Indices.IIndex{``0},System.Collections.Generic.IEnumerable{``0},Deedle.Direction,Deedle.Vectors.VectorConstruction,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction}},System.Tuple{``1,Deedle.OptionalValue{``2}}})">
<summary>
 Aggregate data into non-overlapping chunks by aligning them to the
 specified keys. The second parameter specifies the direction. If it is
 `Direction.Forward` than the key is the first element of a chunk; for 
 `Direction.Backward`, the key is the last element (note that this does not 
 hold at the boundaries where values before/after the key may also be included)
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.Reindex``1(Deedle.Indices.IIndex{``0},Deedle.Indices.IIndex{``0},Deedle.Lookup,Deedle.Vectors.VectorConstruction,Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Boolean})">
<summary>
 Given an old index and a new index, build a vector transformation that reorders
 elements from a vector associated with the old index so that they match the new
 index. When finding element location in the new index, the provided `Lookup` strategy
 is used. This is used, for example, when doing left/right join (to align the new data
 with another index) or when selecting multiple keys (`Series.lookupAll`).

 The proivded `condition` is used when searching for a value in the old index
 (when lookup is not exact). It is called to check that the address contains an
 appropriate value (e.g. when we need to skip over missing values).
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.Recreate``1(Deedle.Indices.IIndex{``0})">
<summary>
 When we create a new vector (`IVectorBuilder.Create`), then we may get a materialized
 vector and we may need to perform the same transformation on the index. This is similar
 to `Project`, but used in different scenarios.
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.Project``1(Deedle.Indices.IIndex{``0})">
<summary>
 When we perform some projection on the vector (`Select` or `Convert`), then we may also
 need to perform some transformation on the index (because it may turn delayed index 
 into an evaluated index). If the vector operation does that, then `Project` should do the 
 same (e.g. evaluate) on the index.
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.OrderIndex``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction})">
<summary>
 Order (possibly unordered) index and return transformation that reorders vector
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.Merge``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction}},Deedle.Vectors.VectorListTransform)">
<summary>
 Append two indices and builds corresponding vector transformations
 for both vectors that match the left and the right index. If the indices
 are ordered, the ordering should be preserved (the keys should be aligned).
 The specified `VectorListTransform` defines how to deal with the case when
 a key is defined in both indices (i.e. which value should be in the new vector).
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.LookupLevel``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},Deedle.ICustomLookup{``0})">
<summary>
 Get items associated with the specified key from the index. This method takes
 `ICustomLookup&lt;K&gt;` which provides an implementation of `ICustomKey&lt;K&gt;`. This 
 is used for custom equality testing (for example, when getting a level of a hierarchical index)
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.Intersect``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction})">
<summary>
 Creates an interesection of two indices and builds corresponding vector transformations
 for both vectors that match the left and the right index.
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.GroupBy``2(Deedle.Indices.IIndex{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Deedle.OptionalValue{``1}},Deedle.Vectors.VectorConstruction)">
<summary>
 Group a (possibly unordered) index according to a provided sequence of labels.
 The operation results in a sequence of unique labels along with corresponding 
 series construction objects which can be applied to arbitrary vectors/columns.
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.GetRange``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},System.Tuple{Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,Deedle.Indices.BoundaryBehavior}},Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,Deedle.Indices.BoundaryBehavior}}})">
<summary>
 Create a new index that represents sub-range of an existing index. The range is specified
 as a pair of options (when `None`, the original left/right boundary should be used) 
 that contain boundary behavior and the boundary key.
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.GetAddressRange``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},Deedle.RangeRestriction{System.Int64})">
<summary>
 Create a new index that represents sub-range of an existing index.
 The range is specified as a pair of addresses, which means that it can be 
 used by operations such as &quot;series.Take(5)&quot; (which do not rely on keys)
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.DropItem``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},``0)">
<summary>
 Drop an item associated with the specified key from the index. 
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.Create``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Create a new index using the specified keys. This overload takes data as ReadOnlyCollection
 and so it is more efficient if the caller already has the keys in an allocated collection.
 Optionally, the caller can specify if the index keys are ordered or not. When the value 
 is not set, the construction should check and infer this from the data.
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.Create``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Create a new index using the specified keys. Optionally, the caller can specify
 if the index keys are ordered or not. When the value is not set, the construction
 should check and infer this from the data.
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.AsyncMaterialize``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction})">
<summary>
 Given an index and vector construction, return a new index asynchronously
 to allow composing evaluation of lazy series. The command to be applied to
 vectors can be applied asynchronously using `vectorBuilder.AsyncBuild`
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.Aggregate``3(Deedle.Indices.IIndex{``0},Deedle.Aggregation{``0},Deedle.Vectors.VectorConstruction,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Deedle.DataSegmentKind,System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction}},System.Tuple{``1,Deedle.OptionalValue{``2}}})">
<summary>
 Aggregate an ordered index into floating windows or chunks. 

 ## Parameters

  - `index` - Specifies the index to be aggregated
  - `aggregation` - Defines the kind of aggregation to apply (the type 
    is a discriminated union with a couple of cases)
  - `source` - Source vector construction to be transformed 
  - `selector` - Given information about window/chunk (including 
    vector construction that can be used to build the data chunk), return
    a new key, together with a new value for the returned vector.
</summary>
</member>
<member name="T:Deedle.Indices.IIndexBuilder">
<summary>
 A builder represents various ways of constructing index, either from keys or from
 other indices. The operations that build a new index from an existing index also 
 build `VectorConstruction` which specifies how to transform vectors aligned with the
 previous index to match the new index. The methods generally take `VectorConstruction`
 as an input, apply necessary transformations to it and return a new `VectorConstruction`.

 ## Example

 For example, given `index`, we can say:

     // Create an index that excludes the value 42
     let newIndex, vectorCmd = indexBuilder.DropItem(index, 42, VectorConstruction.Return(0))

     // Now we can transform multiple vectors (e.g. all frame columns) using &apos;vectorCmd&apos;
     // (the integer &apos;0&apos; in `Return` is an offset in the array of vector arguments)
     let newVector = vectorBuilder.Build(vectorCmd, [| vectorToTransform |])

</summary>
</member>
<member name="P:Deedle.Indices.IIndex`1.Mappings">
<summary>
 Returns all key-address mappings in the index
</summary>
</member>
<member name="P:Deedle.Indices.IIndex`1.Keys">
<summary>
 Returns a (fully evaluated) collection with all keys in the index
</summary>
</member>
<member name="P:Deedle.Indices.IIndex`1.KeySequence">
<summary>
 Returns a lazy sequence that iterates over all keys in the index
</summary>
</member>
<member name="P:Deedle.Indices.IIndex`1.KeyRange">
<summary>
 Returns the minimal and maximal key associated with the index.
 (the operation may fail for unordered indices)
</summary>
</member>
<member name="P:Deedle.Indices.IIndex`1.KeyCount">
<summary>
 Returns the number of keys in the index
</summary>
</member>
<member name="P:Deedle.Indices.IIndex`1.IsOrdered">
<summary>
 Returns `true` if the index is ordered and `false` otherwise
</summary>
</member>
<member name="P:Deedle.Indices.IIndex`1.IsEmpty">
<summary>
 Returns whether the specified index is empty. This is equivalent to 
 testing if `Keys` are empty, but it does not have to evaluate delayed index.
</summary>
</member>
<member name="P:Deedle.Indices.IIndex`1.Comparer">
<summary>
 Returns a comparer associated with the values used by the current index.
</summary>
</member>
<member name="P:Deedle.Indices.IIndex`1.Builder">
<summary>
 Returns an index builder that can be used for constructing new indices of the
 same kind as the current index (e.g. a lazy index returns a lazy index builder)
</summary>
</member>
<member name="P:Deedle.Indices.IIndex`1.AddressingScheme">
<summary>
 Returns the addressing scheme of the index. When creating a series or a frame
 this is compared for equality with the addressing scheme of the vector(s).
</summary>
</member>
<member name="P:Deedle.Indices.IIndex`1.AddressOperations">
<summary>
 Returns the address operations associated with this index. The addresses of the
 index are not necesarilly continuous integers from 0. This provides some operations
 that can be used for implementing generic operations over any kind of indices.
</summary>
</member>
<member name="M:Deedle.Indices.IIndex`1.Lookup(`0,Deedle.Lookup,Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Boolean})">
<summary>
 Find the address associated with the specified key, or with the nearest
 key as specified by the `lookup` argument. The `condition` function is called
 when searching for keys to ask the caller whether the address should be returned
 (or whether to continue searching). This is used when searching for previous element
 in a series (where we need to check if a value at the address is available)
</summary>
</member>
<member name="M:Deedle.Indices.IIndex`1.KeyAt(System.Int64)">
<summary>
 Performs reverse lookup - and returns key for a specified address
</summary>
</member>
<member name="M:Deedle.Indices.IIndex`1.AddressAt(System.Int64)">
<summary>
 Return an address that represents the specified offset
</summary>
</member>
<member name="T:Deedle.Indices.IIndex`1">
<summary>
 An interface that represents index mapping keys of some generic type `T` to locations
 of address `Address`. The `IIndex&lt;K&gt;` contains minimal set of operations that have to
 be supported by an index. This type should be only used directly when
 extending the DataFrame library and adding a new way of storing or loading data.
 Values of this type are constructed using the associated `IIndexBuilder` type.
</summary>
</member>
<member name="T:Deedle.Indices.SeriesConstruction`1">
<summary>
 Represents a pair of index and vector construction 
 (many of the index operations take/return an index together with a construction
 command that builds a vector matching with the index, so this type alias
 makes this more obvious)
</summary>
</member>
<member name="F:Deedle.Indices.Linear.LinearIndexBuilder.indexBuilder">
<summary>
 Instance of the index builder (specialized to Int32 addresses)
</summary>
</member>
<member name="P:Deedle.Indices.Linear.LinearIndexBuilder.Instance">
<summary>
 Provides a global access to an instance of LinearIndexBuilder
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-WithIndex``2(Deedle.Indices.IIndex{``0},Deedle.IVector{``1},Deedle.Vectors.VectorConstruction)">
<summary>
 Build a new index by getting a key for each old key using the specified function
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-Union``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction})">
<summary>
 Union the index with another. For sorted indices, this needs to align the keys;
 for unordered, it appends new ones to the end.
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-Shift``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},System.Int32)">
<summary>
 Shift the values in the series by a specified offset, in a specified direction
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-Search``2(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},Deedle.IVector{``1},``1)">
<summary>
 Search the values of the specified vector &amp; collect keys at the matching indices
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-Resample``3(Deedle.Indices.IIndexBuilder,Deedle.Indices.IIndex{``0},System.Collections.Generic.IEnumerable{``0},Deedle.Direction,Deedle.Vectors.VectorConstruction,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction}},System.Tuple{``1,Deedle.OptionalValue{``2}}})">
<summary>
 Create chunks based on the specified key sequence
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-Reindex``1(Deedle.Indices.IIndex{``0},Deedle.Indices.IIndex{``0},Deedle.Lookup,Deedle.Vectors.VectorConstruction,Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Boolean})">
<summary>
 Reorder elements in the index to match with another index ordering
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-Recreate``1(Deedle.Indices.IIndex{``0})">
<summary>
 Create an index from another index - if the other index is not LinearIndex, 
 it is fully evaluated and we re-create a LinearIndex from its keys.
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-Project``1(Deedle.Indices.IIndex{``0})">
<summary>
 Linear index is always fully evaluated - just return it
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-OrderIndex``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction})">
<summary>
 Order index and build vector transformation 
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-Merge``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction}},Deedle.Vectors.VectorListTransform)">
<summary>
 Merge is similar to union, but it also combines the vectors using the specified
 vector transformation.
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-Intersect``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction})">
<summary>
 Intersect the index with another. This is the same as
 Union, but we filter &amp; only return keys present in both sequences.
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-GetRange``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},System.Tuple{Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,Deedle.Indices.BoundaryBehavior}},Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,Deedle.Indices.BoundaryBehavior}}})">
<summary>
 Get a new index representing a sub-index of the current one
 (together with a transformation that should be applied to a vector)
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-GetAddressRange``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},Deedle.RangeRestriction{System.Int64})">
<summary>
 Get a sub-range of the index keys based on address (rather than keys)
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-DropItem``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},``0)">
<summary>
 Drop the specified item from the index
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-Create``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Create an index from the specified data
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-Create``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Create an index from the specified data
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-AsyncMaterialize``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction})">
<summary>
 Linear index is always fully evaluated - just return it asynchronously
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-Aggregate``3(Deedle.Indices.IIndex{``0},Deedle.Aggregation{``0},Deedle.Vectors.VectorConstruction,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Deedle.DataSegmentKind,System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction}},System.Tuple{``1,Deedle.OptionalValue{``2}}})">
<summary>
 Aggregate ordered index
</summary>
</member>
<member name="T:Deedle.Indices.Linear.LinearIndexBuilder">
<summary>
 Index builder object that is associated with `LinearIndex&lt;K&gt;` type. The builder
 provides operations for manipulating linear indices (and the associated vectors).
</summary>
</member>
<member name="T:Deedle.Indices.Linear.LinearRangeIndex`1">
<summary>
 A virtual index that represents a subrange of a specified index. This is useful for
 windowing operations where we do not want to allocate a new index for each window. 
 This index can be cheaply constructed and it implements many of the standard functions
 without actually allocating the index (e.g. KeyCount, KeyAt, IsEmpty). For more 
 complex index manipulations (including lookup), an actual index is constructed lazily.
</summary>
</member>
<member name="P:Deedle.Indices.Linear.LinearIndex`1.Mappings">
<summary>
 Returns all mappings of the index (key -&gt; address) 
</summary>
</member>
<member name="P:Deedle.Indices.Linear.LinearIndex`1.KeyRange">
<summary>
 Returns the range of keys - makes sense only for ordered index
</summary>
</member>
<member name="P:Deedle.Indices.Linear.LinearIndex`1.KeyCollection">
<summary>
 Exposes keys array for use in the index builder
</summary>
</member>
<member name="P:Deedle.Indices.Linear.LinearIndex`1.IsOrdered">
<summary>
 Are the keys of the index ordered?
</summary>
</member>
<member name="P:Deedle.Indices.Linear.LinearIndex`1.IsEmpty">
<summary>
 Returns whether the specified index is empty
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndex`1.Deedle-Indices-IIndex`1-Lookup(`0,Deedle.Lookup,Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Boolean})">
<summary>
 Get the address for the specified key.
 The &apos;semantics&apos; specifies fancy lookup methods.
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndex`1.Deedle-Indices-IIndex`1-Locate(`0)">
<summary>
 Get the address for the specified key, low on ceremony
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndex`1.Deedle-Indices-IIndex`1-KeyAt(System.Int64)">
<summary>
 Perform reverse lookup and return key for an address
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndex`1.GetHashCode">
<summary>
 Implement structural hashing against another index
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndex`1.Equals(System.Object)">
<summary>
 Implements structural equality check against another index
</summary>
</member>
<member name="T:Deedle.Indices.Linear.LinearIndex`1">
<summary>
 An index that maps keys `K` to offsets `Address`. The keys cannot be duplicated.
 The construction checks if the keys are ordered (using the provided or the default
 comparer for `K`) and disallows certain operations on unordered indices.
</summary>
</member>
<member name="T:Deedle.Indices.Linear.LinearAddressOperations">
<summary>
 Implements address operations for linear addressing 
</summary>
</member>
<member name="P:Deedle.Indices.Virtual.VirtualIndexBuilder.Instance">
<summary>
 Returns an instance of the virtual index builder
</summary>
</member>
<member name="M:Deedle.Indices.Virtual.VirtualIndexBuilder.Deedle-Indices-IIndexBuilder-WithIndex``2(Deedle.Indices.IIndex{``0},Deedle.IVector{``1},Deedle.Vectors.VectorConstruction)">
<summary>
 Replace the index with another index (whose keys are specified by a vector)
</summary>
</member>
<member name="T:Deedle.Indices.Virtual.VirtualIndexBuilder">
<summary>
 Implements `IIndexBuilder` interface for BigDeedle. This directly implements operations that can 
 be implemented on virtual vectors (mostly merging, slicing) and for other operations, it calls
 ordinary `LinearIndexBuilder`. The resulting `VectorConstruction` corresponds to the addressing
 scheme of the returned index (i.e. if we return virtual, we expect to build virtual vector; if
 we materialize, the vector builder also has to materialize).
</summary>
</member>
<member name="P:Deedle.Indices.Virtual.VirtualOrdinalIndex.Source">
<summary>
 Returns the source that is used to identify the index.
</summary>
</member>
<member name="P:Deedle.Indices.Virtual.VirtualOrdinalIndex.Ranges">
<summary>
 Returns the ranges of data mapped in this index
</summary>
</member>
<member name="T:Deedle.Indices.Virtual.VirtualOrdinalIndex">
<summary>
 Represents an ordinal index based on addressing provided by a virtual source.
 The index can be used by BigDeedle virtual frames and series, without accessing
 all data from the data source.
</summary>
</member>
<member name="P:Deedle.Indices.Virtual.VirtualOrderedIndex`1.Source">
<summary>
 Returns the underlying source associated with the index
</summary>
</member>
<member name="M:Deedle.Indices.Virtual.VirtualOrderedIndex`1.GetHashCode">
<summary>
 Implement structural hashing against another index
</summary>
</member>
<member name="M:Deedle.Indices.Virtual.VirtualOrderedIndex`1.Equals(System.Object)">
<summary>
 Implements structural equality check against another index
</summary>
</member>
<member name="T:Deedle.Indices.Virtual.VirtualOrderedIndex`1">
<summary>
 Represents an ordered index based on data provided by a virtual source.
 The index can be used by BigDeedle virtual frames and series, without accessing
 all data from the data source.

 The index only evaluates the full key collection when needed. Most of the actual
 work is delegated to the `IVirtualVectorSource&lt;&apos;K&gt;` value passed in the constructor.
</summary>
</member>
<member name="T:Deedle.Internal.BinomialHeap`1">
<summary>
 Binomial heap stores a list of trees together with custom comparer

 [omit]
</summary>
</member>
<member name="T:Deedle.Internal.ComparisonFailedException">
<summary>
 An internal exception that is used to handle the case when comparison fails
 (even though the type implements IComparable and everything...)

 [omit]
</summary>
</member>
<member name="P:Deedle.Internal.Deque`1.Last">
<summary>
 Gets the element at the end
</summary>
</member>
<member name="P:Deedle.Internal.Deque`1.Item(System.Int32)">
<summary>
 Gets the value at the specified index of the Deque
</summary>
</member>
<member name="P:Deedle.Internal.Deque`1.IsFull">
<summary>
 Gets whether or not the Deque is filled to capacity.
</summary>
</member>
<member name="P:Deedle.Internal.Deque`1.IsEmpty">
<summary>
 Gets whether or not the Deque is empty.
</summary>
</member>
<member name="P:Deedle.Internal.Deque`1.First">
<summary>
 Gets the element at the front
</summary>
</member>
<member name="P:Deedle.Internal.Deque`1.Count">
<summary>
 Gets the number of elements contained in the Deque.
</summary>
</member>
<member name="P:Deedle.Internal.Deque`1.Capacity">
<summary>
 Gets the total number of elements the internal array can hold without resizing.
</summary>
</member>
<member name="M:Deedle.Internal.Deque`1.RemoveLast">
<summary>
 Removes an item from the back of the Deque and returns it.
</summary>
</member>
<member name="M:Deedle.Internal.Deque`1.RemoveFirst">
<summary>
 Removes an item from the front of the Deque and returns it.
</summary>
</member>
<member name="M:Deedle.Internal.Deque`1.Add(`0)">
<summary>
 Adds the provided item to the back of the Deque.
</summary>
</member>
<member name="M:Deedle.Internal.Deque`1.#ctor">
<summary>
 Creates a new Deque with the default capacity
</summary>
</member>
<member name="T:Deedle.Internal.Deque`1">
<summary>
 Mutable double ended queue that holds elements in a circular array.
 The data structure provides O(1) RemoveFirst and RemoveLast. Add is 
 O(1) when the deque has enough internal capacity, otherwise it extends
 the array 2x (so amortized cost is O(1) too).

 [omit]
</summary>
</member>
<member name="T:Deedle.Internal.IFsiFormattable">
<summary>
 [omit]
 An interface implemented by types that support nice formatting for F# Interactive
 (The `FSharp.DataFrame.fsx` file registers an FSI printer using this interface.)
</summary>
</member>
<member name="T:Deedle.Internal.RankedTree`1">
<summary>
 Tree where nodes contain values and zero or more child trees.
 For each node, we store rank - the number of children

 [omit]
</summary>
</member>
<member name="M:Deedle.Internal.AddressingExtensions.AddressRangeExtensions.AsAbsolute(Deedle.RangeRestriction{System.Int64},System.Int64)">
<summary>
 When the address represents an absolute offset, this can be used to turn &apos;Start&apos; 
 and &apos;End&apos; restrictions into the usual &apos;Fixed&apos; restriction. The result is a choice
 with either new absolute range or custom (sequence of addresses)
</summary>
</member>
<member name="T:Deedle.Internal.AddressingExtensions">
<summary>
 [omit]
</summary>
</member>
<member name="M:Deedle.Internal.Array.choosei``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},``0[])">
<summary>
 Returns a new array containing only the elements for which the specified function returns `Some`.
 The predicate is called with the index in the source array and the element.
</summary>
</member>
<member name="M:Deedle.Internal.Array.binarySearchNearestSmaller``1(``0,System.Collections.Generic.IComparer{``0},System.Boolean,System.Collections.ObjectModel.ReadOnlyCollection{``0})">
<summary>
 Returns the index of &apos;key&apos; or the index of immediately preceeding value.
 If the specified key is smaller than all keys in the array, None is returned.

 When &apos;inclusive&apos; is false, the function returns the index of strictry smaller value.
 Note that the function expects that the array contains distinct values
 (which is fine because LinearIndex does not support duplicate keys)
</summary>
</member>
<member name="M:Deedle.Internal.Array.binarySearchNearestGreater``1(``0,System.Collections.Generic.IComparer{``0},System.Boolean,System.Collections.ObjectModel.ReadOnlyCollection{``0})">
<summary>
 Returns the index of &apos;key&apos; or the index of immediately following value.
 If the specified key is greater than all keys in the array, None is returned.

 When &apos;inclusive&apos; is false, the function returns the index of strictry greater value.
 Note that the function expects that the array contains distinct values
 (which is fine because LinearIndex does not support duplicate keys)
</summary>
</member>
<member name="M:Deedle.Internal.Array.binarySearch``1(``0,System.Collections.Generic.IComparer{``0},System.Collections.ObjectModel.ReadOnlyCollection{``0})">
<summary>
 Implementation of binary search
</summary>
</member>
<member name="M:Deedle.Internal.Array.dropRange``1(System.Int32,System.Int32,``0[])">
<summary>
 Drop a specified range from a given array. The operation is inclusive on
 both sides. Given [ 1; 2; 3; 4 ] and indices (1, 2), the result is [ 1; 4 ]
</summary>
</member>
<member name="T:Deedle.Internal.Array">
<summary>
 This module contains additional functions for working with arrays. 
 `Deedle.Internals` is opened, it extends the standard `Array` module.
</summary>
</member>
<member name="M:Deedle.Internal.BinomialHeap.deleteMin``1(Deedle.Internal.BinomialHeap{``0})">
<summary>
 Remove minimal value from the specified binomial heap
 (and return the new heap)
</summary>
</member>
<member name="M:Deedle.Internal.BinomialHeap.removeMin``1(Deedle.Internal.BinomialHeap{``0})">
<summary>
 Remove minimal value from the specified binomial heap
 (and return the value, together with a new heap)
</summary>
</member>
<member name="M:Deedle.Internal.BinomialHeap.findMin``1(Deedle.Internal.BinomialHeap{``0})">
<summary>
 Find minimal value from the specified binomial heap 
</summary>
</member>
<member name="M:Deedle.Internal.BinomialHeap.removeMinTree``1(System.Collections.Generic.IComparer{``0},Microsoft.FSharp.Collections.FSharpList{Deedle.Internal.RankedTree{``0}})">
<summary>
 Remove the  smallest tree from a list of ranked trees.
</summary>
</member>
<member name="M:Deedle.Internal.BinomialHeap.merge``1(Deedle.Internal.BinomialHeap{``0},Deedle.Internal.BinomialHeap{``0})">
<summary>
 Merge two binomial heaps (using the comparer of the first one)
</summary>
</member>
<member name="M:Deedle.Internal.BinomialHeap.mergeTrees``1(System.Collections.Generic.IComparer{``0},Microsoft.FSharp.Collections.FSharpList{Deedle.Internal.RankedTree{``0}},Microsoft.FSharp.Collections.FSharpList{Deedle.Internal.RankedTree{``0}})">
<summary>
 Merge two lists of ranked trees, producing a new list.
</summary>
</member>
<member name="M:Deedle.Internal.BinomialHeap.insert``1(``0,Deedle.Internal.BinomialHeap{``0})">
<summary>
 Insert the specified element to the heap
</summary>
</member>
<member name="M:Deedle.Internal.BinomialHeap.insertTree``1(System.Collections.Generic.IComparer{``0},Deedle.Internal.RankedTree{``0},Microsoft.FSharp.Collections.FSharpList{Deedle.Internal.RankedTree{``0}})">
<summary>
 Inser the specified tree into the list of trees forming binomial heap.
 If the rank of the inserted tree is higher than the rank of the head, 
 then join the trees and add the resulting tree. 
</summary>
</member>
<member name="M:Deedle.Internal.BinomialHeap.link``1(System.Collections.Generic.IComparer{``0},Deedle.Internal.RankedTree{``0},Deedle.Internal.RankedTree{``0})">
<summary>
 Link two tree nodes. The new root is the smaller of the two nodes.
</summary>
</member>
<member name="M:Deedle.Internal.BinomialHeap.root``1(Deedle.Internal.RankedTree{``0})">
<summary>
 Returns the value in the root of the specified tree 
</summary>
</member>
<member name="M:Deedle.Internal.BinomialHeap.rank``1(Deedle.Internal.RankedTree{``0})">
<summary>
 Returns the rank of the specified tree node
</summary>
</member>
<member name="M:Deedle.Internal.BinomialHeap.isEmpty``1(Deedle.Internal.BinomialHeap{``0})">
<summary>
 Returns true when the specified heap is emtpy
</summary>
</member>
<member name="M:Deedle.Internal.BinomialHeap.emptyCustom``1(System.Collections.Generic.IComparer{``0})">
<summary>
 Creates an empty heap using the specified comparer
</summary>
</member>
<member name="M:Deedle.Internal.BinomialHeap.empty``1">
<summary>
 Creates an empty heap that uses the default .NET comparer
</summary>
</member>
<member name="M:Deedle.Internal.BinomialHeap.|LT|GT|EQ|(System.Int32)">
<summary>
 Active pattern that makes it easier to deal with results from IComparer
</summary>
</member>
<member name="T:Deedle.Internal.BinomialHeap">
<summary>
 Module with functions for working with binomial heaps

 [omit]
</summary>
</member>
<member name="M:Deedle.Internal.Convert.canConvertType``1(Deedle.ConversionKind,System.Object)">
<summary>
 A function that returns `true` when `convertType&lt;&apos;T&gt;` is expected
 to succeed on the specified value (this is approximation - it may
 return &apos;true&apos; even if the conversion fails, but not the other way round)
</summary>
</member>
<member name="M:Deedle.Internal.Convert.convertType``1(Deedle.ConversionKind,System.Object)">
<summary>
 Helper function that converts value to a specified type. The conversion
 is done using the specified conversion kind, which specifies the level
 of flexibility (Exact - cast, Safe - according to &apos;sourcesByTarget&apos;, 
 Flexible - anything that System.Convert allows)
</summary>
</member>
<member name="P:Deedle.Internal.Convert.sourcesByTarget">
<summary>
 Dictionary that maps target type (e.g. &apos;float32&apos;) to all the source types that can be
 safely converted to it (e.g. &apos;decimal,int64,unit64,int32,uint32,int16,uint16,int8,uint8&apos;)
</summary>
</member>
<member name="P:Deedle.Internal.Convert.safeConversions">
<summary>
 Conversions that are &quot;safe&quot; as a list of &quot;source -&gt; target&quot; types
</summary>
</member>
<member name="T:Deedle.Internal.Convert">
<summary>
 [omit]
</summary>
</member>
<member name="T:Deedle.Internal.DynamicExtensions.WrappedExpression">
<summary>
 A C# expression tree, embedded in a value (in a quotation)
</summary>
</member>
<member name="M:Deedle.Internal.DynamicExtensions.createGetterAndSetterFromFunc``1(System.Linq.Expressions.Expression,``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.String,System.Object}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit}}})">
<summary>
 This can be used when the setter is a simple non-generic function that 
 takes the name as string &amp; argument as object (and returns nothing)
</summary>
</member>
<member name="M:Deedle.Internal.DynamicExtensions.createPropertyMetaObject``1(System.Linq.Expressions.Expression,``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpFunc{System.Type,Microsoft.FSharp.Quotations.FSharpExpr}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpFunc{System.Type,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr}}}})">
<summary>
 This can be used when getter/setter are generic (in some way) - the caller
 is responsible for generating the right expression tree (this cannot easily
 be done using quotations)
</summary>
</member>
<member name="M:Deedle.Internal.DynamicExtensions.asExpr(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Translate simple F# quotation to C# expression &amp; handle wrapped values
</summary>
</member>
<member name="T:Deedle.Internal.DynamicExtensions">
<summary>
 [omit]
 Module that implements various helpers for supporting C# dynamic type.
 (this takes care of some of the complexity around building `DynamicMetaObject`
 and it is used by `SeriesBuilder` and `Frame`)
</summary>
</member>
<member name="M:Deedle.Internal.ExceptionHelpers.keyNotFound``2(``0)">
<summary>
 Throws `KeyNotFoundException` with a nicely formatted error message for the specified key
</summary>
</member>
<member name="M:Deedle.Internal.ExceptionHelpers.missingVal``2(``0)">
<summary>
 Throws `MissingValueException` with a nicely formatted error message for the specified key
</summary>
</member>
<member name="T:Deedle.Internal.ExceptionHelpers">
<summary>
 Simple helper functions for throwing exceptions

 [omit]
</summary>
</member>
<member name="P:Deedle.Internal.Formatting.EndInlineItemCount">
<summary>
 Maximal number of items to be printed at the end of an inline formatted series/frame
</summary>
</member>
<member name="P:Deedle.Internal.Formatting.StartInlineItemCount">
<summary>
 Maximal number of items to be printed at the beginning of an inline formatted series/frame
</summary>
</member>
<member name="P:Deedle.Internal.Formatting.EndItemCount">
<summary>
 Maximal number of items to be printed at the end of a series/frame
</summary>
</member>
<member name="P:Deedle.Internal.Formatting.StartItemCount">
<summary>
 Maximal number of items to be printed at the beginning of a series/frame
</summary>
</member>
<member name="T:Deedle.Internal.Formatting">
<summary>
 [omit]
 Contains helper functions and configuration constants for pretty printing
</summary>
</member>
<member name="M:Deedle.Internal.List.tryChooseBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Returns an option value that is Some when the specified function &apos;f&apos;
 succeeds for all values from the input list. Otherwise returns None. 
</summary>
</member>
<member name="T:Deedle.Internal.List">
<summary>
 This module contains additional functions for working with lists. 
</summary>
</member>
<member name="M:Deedle.Internal.MatchingHelpers.|Let|``2(``0,``1)">
<summary>
 Helper that lets us define parameters in pattern matching; for example 
 &quot;Let 42 (answer, input)&quot; binds &quot;answer=42&quot; and propagates input
</summary>
</member>
<member name="T:Deedle.Internal.MatchingHelpers">
<summary>
 Pattern matching helpers
 [omit]
</summary>
</member>
<member name="T:Deedle.Internal.MissingValues">
<summary>
 Utility functions for identifying missing values. The `isNA` function 
 can be used to test whether a value represents a missing value - this includes
 the `null` value, `Nullable&lt;T&gt;` value with `HasValue = false` and 
 `Single.NaN` as well as `Double.NaN`.

 The functions in this module are not intended to be called directly.
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.empty``1">
<summary>
 Returns empty readonly collection
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.foldOptional``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.ObjectModel.ReadOnlyCollection{Deedle.OptionalValue{``1}})">
<summary>
 Fold elements of the ReadOnlyCollection, skipping over missing values
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.ObjectModel.ReadOnlyCollection{``1})">
<summary>
 Fold elements of the ReadOnlyCollection
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.reduceOptional``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.ObjectModel.ReadOnlyCollection{Deedle.OptionalValue{``0}})">
<summary>
 Reduce elements of the ReadOnlyCollection, skipping over missing values
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.ObjectModel.ReadOnlyCollection{``0})">
<summary>
 Reduce elements of the ReadOnlyCollection
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.length``1(System.Collections.ObjectModel.ReadOnlyCollection{``0})">
<summary>
 Count elements of the ReadOnlyCollection
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.ObjectModel.ReadOnlyCollection{``0})">
<summary>
 Transform all elements of ReadOnlyCollection using the specified function
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Converts a lazy sequence to fully evaluated ReadOnlyCollection
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.ofArray``1(``0[])">
<summary>
 Converts an array to ReadOnlyCollection. 
</summary>
</member>
<member name="T:Deedle.Internal.ReadOnlyCollection">
<summary>
 Provides helper functions for working with `ReadOnlyCollection&lt;T&gt;` similar to those 
 in the `Array` module. Most importantly, F# 3.0 does not know that array implements
 `IList&lt;T&gt;`.
</summary>
</member>
<member name="T:Deedle.Internal.ReadOnlyCollectionExtensions">
<summary>
 [omit]
</summary>
</member>
<member name="M:Deedle.Internal.Seq.alignAllUnordered``1(System.Collections.ObjectModel.ReadOnlyCollection{``0}[])">
<summary>
 Align N unordered sequences of keys (performs union of the keys)
</summary>
</member>
<member name="M:Deedle.Internal.Seq.alignUnordered``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Boolean)">
<summary>
 Align two unordered sequences of keys. Calls either
 `alignUnorderedUnion` or `alignUnorderedIntersection`, based 
 on the `intersectionOnly` parameter.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.alignUnorderedIntersection``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Collections.ObjectModel.ReadOnlyCollection{``0})">
<summary>
 Align two unordered sequences of keys (performs intersection of the keys)
 The resulting relocations are returned as two-element list for symmetry with other functions
</summary>
</member>
<member name="M:Deedle.Internal.Seq.alignUnorderedUnion``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Collections.ObjectModel.ReadOnlyCollection{``0})">
<summary>
 Align two unordered sequences of keys (performs union of the keys)
 The resulting relocations are returned as two-element list for symmetry with other functions
</summary>
</member>
<member name="M:Deedle.Internal.Seq.alignAllOrdered``1(System.Collections.ObjectModel.ReadOnlyCollection{``0}[],System.Collections.Generic.IComparer{``0})">
<summary>
 Calls either `alignAllOrderedMany` or `alignAllOrderedFew` depending on the number
 of sequences to be aligned. Performance measurements suggest that 150 is the limit
 when the implementation using binomial heap is faster.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.alignAllOrderedFew``1(System.Collections.ObjectModel.ReadOnlyCollection{``0}[],System.Collections.Generic.IComparer{``0})">
<summary>
 Align N ordered sequences of keys (using the specified comparer)
 This is the same as `alignOrdered` but for larger number of key sequences.
 Throws ComparisonFailedException when the comparer fails.
 (This performs union on the specified sequences)
</summary>
</member>
<member name="M:Deedle.Internal.Seq.alignAllOrderedMany``1(System.Collections.ObjectModel.ReadOnlyCollection{``0}[],System.Collections.Generic.IComparer{``0})">
<summary>
 Align N ordered sequences of keys (using the specified comparer)
 This is the same as `alignOrdered` but for larger number of key sequences.
 Throws ComparisonFailedException when the comparer fails.
 (This performs union on the specified sequences)
</summary>
</member>
<member name="M:Deedle.Internal.Seq.alignOrdered``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Collections.Generic.IComparer{``0},System.Boolean)">
<summary>
 Align two ordered sequences of keys (using the specified comparer)
 The resulting relocations are returned as two-element list for symmetry with other functions
 Throws ComparisonFailedException when the comparer fails.

 When `intersectionOnly = true`, the function only adds keys &amp; relocations
 for keys that appear in both sequences (otherwise, it performs union)
</summary>
</member>
<member name="M:Deedle.Internal.Seq.tryFirstAndLast``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Returns the first and the last element from a sequence or &apos;None&apos; if the sequence is empty
</summary>
</member>
<member name="M:Deedle.Internal.Seq.isSorted``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
<summary>
 Returns true if the specified sequence is sorted.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.chunkRangesWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Generate non-verlapping chunks from the input sequence. A chunk is started 
 at the beginning and then immediately after the end of the previous chunk.
 To find the end of the chunk, the function calls the provided argument `f` 
 with the first and the last elements of the chunk as arguments. A chunk 
 ends when `f` returns `false`.
 The function returns the chunks as pairs of their indices.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.windowRangesWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Generate floating windows from the input sequence. New floating window is 
 started for each element. To find the end of the window, the function calls
 the provided argument `f` with the first and the last elements of the window
 as arguments. A window ends when `f` returns `false`.
 The function returns the windows as pairs of their indices.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.chunkRangesWithBounds(System.Int64,Deedle.Boundary,System.Int64)">
<summary>
 Generates addresses of windows in a collection of size &apos;length&apos;. For example, consider
 a collection with 7 elements (and indices 0 .. 6) and the requirement to create windows
 of length 3: 

    0 1 2 3 4 5 6   

 When the `AtEnding` flag is set for `boundary`:

    c c c
          c c c
                d

 The two chunks marked as &apos;c&apos; are returned always. The incomplete chunk at the end is
 returned unless the `Skip` flag is set for `boundary`. When the `AtBeginning` flag is
 set, the incomplete chunk is (when not `Skip`) returned at the beginning:

    d
      c c c 
            c c c 

 The chunks are specified by *inclusive* indices, so, e.g. the first chunk in 
 the second example above is returned as a pair (0, 0).
</summary>
</member>
<member name="M:Deedle.Internal.Seq.windowRangesWithBounds(System.Int64,Deedle.Boundary,System.Int64)">
<summary>
 Generates addresses of chunks in a collection of size &apos;length&apos;. For example, consider
 a collection with 7 elements (and indices 0 .. 6) and the requirement to create chunks
 of length 4: 

    0 1 2 3 4 5 6   

    s
    s s
    s s s
    w w w w
      w w w w
        w w w w
          w w w w
            e e e 
              e e
                e

 The windows &apos;s&apos; are returned when `boundary = Boundary.AtBeginning` and the windows
 &apos;e&apos; are returned when `boundary = Boundary.AtEnding`. The middle is returned always.
 The windows are specified by *inclusive* indices, so, e.g. the first window is returned
 as a pair (0, 0).
</summary>
</member>
<member name="M:Deedle.Internal.Seq.chunkedWithBounds``1(System.Int32,Deedle.Boundary,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Similar to `Seq.windowedWithBounds`, but generates non-overlapping chunks
 rather than floating windows. See that function for detailed documentation.
 The function may iterate over the sequence repeatedly.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.windowedWithBounds``1(System.Int32,Deedle.Boundary,System.Collections.Generic.IEnumerable{``0})">
<summary>
 A version of `Seq.windowed` that allows specifying more complex boundary
 behaviour. The `boundary` argument can specify one of the following options:
 
  * `Boundary.Skip` - only full windows are returned (like `Seq.windowed`)
  * `Boundary.AtBeginning` - incomplete windows (smaller than the required
    size) are returned at the beginning.
  * `Boundary.AtEnding` - incomplete windows are returned at the end.

 The result is a sequence of `DataSegnebt&lt;T&gt;` values, which makes it 
 easy to distinguish between complete and incomplete windows.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.chunkedWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Generate non-verlapping chunks from the input sequence. A chunk is started 
 at the beginning and then immediately after the end of the previous chunk.
 To find the end of the chunk, the function calls the provided argument `f` 
 with the first and the last elements of the chunk as arguments. A chunk 
 ends when `f` returns `false`.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.windowedWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Generate floating windows from the input sequence. New floating window is 
 started for each element. To find the end of the window, the function calls
 the provided argument `f` with the first and the last elements of the window
 as arguments. A window ends when `f` returns `false`.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.startAndEnd``1(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Given a sequence, returns `startCount` number of elements at the beginning 
 of the sequence (wrapped in `Choice1Of3`) followed by one `Choice2Of2()` value
 and then followed by `endCount` number of elements at the end of the sequence
 wrapped in `Choice3Of3`. If the input is shorter than `startCount + endCount`,
 then all values are returned and wrapped in `Choice1Of3`.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.getEnumerator``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Calls the `GetEnumerator` method. Simple function to guide type inference.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.lastFew``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Returns the specified number of elements from the end of the sequence
 Note that this needs to store the specified number of elements in memory
 and it needs to iterate over the entire sequence.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.headOrNone``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 If the input is non empty, returns `Some(head)` where `head` is 
 the first value. Otherwise, returns `None`.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.structuralHash``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Calculate hash code of a sequence, based on the values
</summary>
</member>
<member name="M:Deedle.Internal.Seq.structuralEquals``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Comapre two sequences using the `Equals` method. Returns true
 when all their elements are equal and they have the same size.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.range``1(``0,``0)">
<summary>
 A helper function that generates a sequence for the specified range of
 int or int64 values. This is notably faster than using `lo .. hi`.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.rangeStep``1(``0,``0,``0)">
<summary>
 A helper function that generates a sequence for the specified range of
 int or int64 values. This is notably faster than using `lo .. step .. hi`.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.rangeStepImpl``1(``0,``0,``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}})">
<summary>
 A helper function that generates a sequence for the specified range.
 (This takes the step and also an operator to use for checking at the end)
</summary>
</member>
<member name="M:Deedle.Internal.Seq.skipAtMost``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Skip at most the specified number of elements. This is like
 `Seq.skip`, but it does not throw when the sequence is shorter.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.mapl``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Same as `Seq.map` but passes 64 bit index (l stands for long) to the function
</summary>
</member>
<member name="M:Deedle.Internal.Seq.choosel``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Same as `Seq.choose` but passes 64 bit index (l stands for long) to the function
</summary>
</member>
<member name="M:Deedle.Internal.Seq.unreduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
<summary>
 Generate infinite sequence using the specified function.
 The initial state is returned as the first element.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.lastAndLength``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Returns the last element and the length of a sequence
 (using just a single iteration over the sequence)
</summary>
</member>
<member name="M:Deedle.Internal.Seq.uniqueBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 If the projection returns the same value for all elements, then it
 returns the value. Otherwise it throws an exception.
</summary>
</member>
<member name="T:Deedle.Internal.Seq">
<summary>
 This module contains additional functions for working with sequences. 
 `Deedle.Internals` is opened, it extends the standard `Seq` module.
</summary>
</member>
<member name="M:Deedle.JoinHelpers.createJoinTransformation``1(Deedle.Indices.IIndexBuilder,Deedle.Indices.IIndexBuilder,Deedle.JoinKind,Deedle.Lookup,Deedle.Indices.IIndex{``0},Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction,Deedle.Vectors.VectorConstruction)">
<summary>
 Create transformation on indices/vectors representing the join operation
</summary>
</member>
<member name="M:Deedle.JoinHelpers.fillMissing(Deedle.Vectors.VectorConstruction,Deedle.Lookup)">
<summary>
 When using fancy lookup, first fill values in the vector, before doing the join
</summary>
</member>
<member name="M:Deedle.JoinHelpers.restrictToRowIndex``1(Deedle.Lookup,Deedle.Indices.IIndex{``0},Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction)">
<summary>
 When doing exact join on ordered indices, restrict the new index
 so that we do not have to load all data for lazy indices
</summary>
</member>
<member name="T:Deedle.JoinHelpers">
<summary>
 [omit]
 Implements various helpers that are used by Join operations
</summary>
</member>
<member name="M:Deedle.Keys.SimpleLookup`1.Deedle-ICustomLookup`1-Matches(`0)">
<summary>
 Dynamically tests whether this pattern matches with another key. 
 For example, `[|None, Some 1|]` matches `(42, 1)`, but if the second 
 values differed, then they would not match.
</summary>
</member>
<member name="T:Deedle.Keys.SimpleLookup`1">
<summary>
 Implements a simple lookup that matches any multi-level key against a specified array of
 optional objects (that represent missing/set parts of a key)
</summary>
</member>
<member name="M:Deedle.Keys.CustomKey.Get(System.Object)">
<summary>
 Returns `ICustomKey` instance for the specified key. If the specified key implements
 `ICustomKey`, then it is just returned; if it is a tuple, we use special key for tuples
 otherwise, it must be a primitive key so we just return it
</summary>
</member>
<member name="T:Deedle.Keys.CustomKey">
<summary>
 Helper type that can be used to get `ICustomKey` for any object (including objects
 that actually implement the interface and tuples)
</summary>
</member>
<member name="P:Deedle.Keys.ICustomKey.Levels">
<summary>
 Returns the number of levels of a hierarchical key. For example, a tuple (1, 42) has 2 levels.
 This is used for pretty printing only.
</summary>
</member>
<member name="M:Deedle.Keys.ICustomKey.GetLevels">
<summary>
 Gets values of the key at all levels
</summary>
</member>
<member name="M:Deedle.Keys.ICustomKey.GetLevel(System.Int32)">
<summary>
 Gets a value at the specified level (the levels are indexed from 1). 
 This is used for pretty printing only. If `Levels=1` then this method is not
 called and the pretty printer invokes `ToString` on the whole object instead.
</summary>
</member>
<member name="T:Deedle.Keys.ICustomKey">
<summary>
 Represents a special hierarchical key. This is mainly used in pretty printing (where we want to 
 get parts of the keys based on levels. `CustomKey.Get` provides a way of getting `ICustomKey`.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.LookupAnyOf4``5(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1},Microsoft.FSharp.Core.FSharpOption{``2},Microsoft.FSharp.Core.FSharpOption{``3})">
<summary>
 Creates an arbitrary lookup key that allows matching on elements
 of a four-level hierarchical index. Specify `None` to ignore a level
 or `Some k` to require match on a given level.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.Lookup4Of4``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 fourth element of a four-level hierarchical key.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.Lookup3Of4``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 third element of a four-level hierarchical key.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.Lookup2Of4``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 second element of a four-level hierarchical key.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.Lookup1Of4``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 first element of a four-level hierarchical key.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.LookupAnyOf3``4(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1},Microsoft.FSharp.Core.FSharpOption{``2})">
<summary>
 Creates an arbitrary lookup key that allows matching on elements
 of a three-level hierarchical index. Specify `None` to ignore a level
 or `Some k` to require match on a given level.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.Lookup3Of3``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 third element of a three-level hierarchical key.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.Lookup2Of3``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 second element of a three-level hierarchical key.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.Lookup1Of3``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 first element of a three-level hierarchical key.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.LookupAnyOf2``3(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Creates an arbitrary lookup key that allows matching on elements
 of a two-level hierarchical index. Specify `None` to ignore a level
 or `Some k` to require match on a given level.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.Lookup2Of2``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 second element of a two-level hierarchical key.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.Lookup1Of2``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 first element of a two-level hierarchical key.
</summary>
</member>
<member name="T:Deedle.MultiKeyExtensions">
<summary>
 F#-friendly functions for creating multi-level keys and lookups

 [category:Parameters and results of various operations]
</summary>
</member>
<member name="M:Deedle.OptionalValueModule.defaultArg``1(``0,Deedle.OptionalValue{``0})">
<summary>
 Returns the value `def` when the argument is missing, otherwise returns its value
</summary>
</member>
<member name="M:Deedle.OptionalValueModule.get``1(Deedle.OptionalValue{``0})">
<summary>
 Get the value stored in the specified optional value. If a value is not
 available, throws an exception. (This is equivalent to the `Value` property)
</summary>
</member>
<member name="M:Deedle.OptionalValueModule.|Missing|Present|``1(Deedle.OptionalValue{``0})">
<summary>
 Complete active pattern that can be used to pattern match on `OptionalValue&lt;T&gt;`.
 For example:

     let optVal = OptionalValue(42)
     match optVal with
     | OptionalValue.Missing -&gt; printfn &quot;Empty&quot;
     | OptionalValue.Present(v) -&gt; printfn &quot;Contains %d&quot; v

</summary>
</member>
<member name="M:Deedle.OptionalValueModule.ofOption``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Turns a standard F# `option&lt;T&gt;` value into a corresponding `OptionalValue&lt;T&gt;`
</summary>
</member>
<member name="M:Deedle.OptionalValueModule.asOption``1(Deedle.OptionalValue{``0})">
<summary>
 Turns the `OptionalValue&lt;T&gt;` into a corresponding standard F# `option&lt;T&gt;` value
</summary>
</member>
<member name="M:Deedle.OptionalValueModule.OfNullable``1(System.Nullable{``0})">
<summary>
 Creates `OptionalValue&lt;T&gt;` from a .NET `Nullable&lt;T&gt;` type.
</summary>
</member>
<member name="M:Deedle.OptionalValueModule.OfTuple``1(System.Boolean,``0)">
<summary>
 Creates `OptionalValue&lt;T&gt;` from a tuple of type `bool * &apos;T`. This function
 can be used with .NET methods that use `out` arguments. For example:

     Int32.TryParse(&quot;42&quot;) |&gt; OptionalValue.ofTuple

</summary>
</member>
<member name="M:Deedle.OptionalValueModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Deedle.OptionalValue{``0},Deedle.OptionalValue{``1})">
<summary>
 If both of the arguments contain value, apply the specified function to their
 values and return `OptionalValue&lt;R&gt;` with the result. Otherwise return
 `OptionalValue.Missing`.
</summary>
</member>
<member name="M:Deedle.OptionalValueModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.OptionalValue{``0})">
<summary>
 If the `OptionalValue&lt;T&gt;` does not contain a value, then returns a new 
 `OptionalValue&lt;R&gt;.Empty`. Otherwise, returns the result `OptionalValue&lt;R&gt;`
 containing the result of applying the function `f` to the value contained 
 in the provided optional value.
</summary>
</member>
<member name="M:Deedle.OptionalValueModule.Bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,Deedle.OptionalValue{``1}},Deedle.OptionalValue{``0})">
<summary>
 If the `OptionalValue&lt;T&gt;` does not contain a value, then returns a new 
 `OptionalValue&lt;R&gt;.Empty`. Otherwise, returns the result of applying the 
 function `f` to the value contained in the provided optional value.
</summary>
</member>
<member name="T:Deedle.OptionalValueModule">
<summary>
 Provides various helper functions for using the `OptionalValue&lt;T&gt;` type from F#
 (The functions are similar to those in the standard `Option` module).

 [category:Primitive types and values]
</summary>
</member>
<member name="M:Deedle.Pair.flatten4``4(``0,System.Tuple{``1,System.Tuple{``2,``3}})">
<summary>
 Flatten a two-level nested tuple into a flat tuple of 4 elements
</summary>
</member>
<member name="M:Deedle.Pair.flatten3``3(``0,System.Tuple{``1,``2})">
<summary>
 Flatten a two-level nested tuple into a flat tuple of 3 elements
</summary>
</member>
<member name="M:Deedle.Pair.get4Of4``4(``0,``1,``2,``3)">
<summary>
 Returns the fourth value of a four-level hierarchical tuple
</summary>
</member>
<member name="M:Deedle.Pair.get3Of4``4(``0,``1,``2,``3)">
<summary>
 Returns the third value of a four-level hierarchical tuple
</summary>
</member>
<member name="M:Deedle.Pair.get2Of4``4(``0,``1,``2,``3)">
<summary>
 Returns the second value of a four-level hierarchical tuple
</summary>
</member>
<member name="M:Deedle.Pair.get1Of4``4(``0,``1,``2,``3)">
<summary>
 Returns the first value of a four-level hierarchical tuple
</summary>
</member>
<member name="M:Deedle.Pair.get1And3Of3``3(``0,``1,``2)">
<summary>
 Returns the first and the third value of a three-level hierarchical tuple
</summary>
</member>
<member name="M:Deedle.Pair.get2And3Of3``3(``0,``1,``2)">
<summary>
 Returns the second and the third value of a three-level hierarchical tuple
</summary>
</member>
<member name="M:Deedle.Pair.get1And2Of3``3(``0,``1,``2)">
<summary>
 Returns the first and the second value of a three-level hierarchical tuple
</summary>
</member>
<member name="M:Deedle.Pair.get3Of3``3(``0,``1,``2)">
<summary>
 Returns the third value of a three-level hierarchical tuple
</summary>
</member>
<member name="M:Deedle.Pair.get2Of3``3(``0,``1,``2)">
<summary>
 Returns the second value of a three-level hierarchical tuple
</summary>
</member>
<member name="M:Deedle.Pair.get1Of3``3(``0,``1,``2)">
<summary>
 Returns the first value of a three-level hierarchical tuple
</summary>
</member>
<member name="M:Deedle.Pair.get2Of2``2(``0,``1)">
<summary>
 Returns the second value of a two-level hierarchical tuple
</summary>
</member>
<member name="M:Deedle.Pair.get1Of2``2(``0,``1)">
<summary>
 Returns the first value of a two-level hierarchical tuple
</summary>
</member>
<member name="T:Deedle.Pair">
<summary>
 Module with helper functions for extracting values from hierarchical tuples

 [category:Primitive types and values]
</summary>
</member>
<member name="M:Deedle.RangeRestriction.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.RangeRestriction{``0})">
<summary>
 Transforms all absolute addresses in the specified range restriction
 using the provided function (this is useful for mapping between different
 address spaces).
</summary>
</member>
<member name="T:Deedle.RangeRestriction">
<summary>
 Provides additional operations for working with the `RangeRestriction&lt;&apos;TAddress&gt;` type
</summary>
</member>
<member name="P:Deedle.Ranges.Ranges`1.Length">
<summary>
 Returns the length of the ranges
</summary>
</member>
<member name="P:Deedle.Ranges.Ranges`1.LastKey">
<summary>
 Returns the last key in the range
</summary>
</member>
<member name="P:Deedle.Ranges.Ranges`1.Keys">
<summary>
 Returns a lazy sequence containing all keys
</summary>
</member>
<member name="P:Deedle.Ranges.Ranges`1.FirstKey">
<summary>
 Returns the first key in the range
</summary>
</member>
<member name="M:Deedle.Ranges.Ranges`1.Restrict(Deedle.RangeRestriction{`0})">
<summary>
 Restricts the ranges according to the specified range restriction
</summary>
</member>
<member name="M:Deedle.Ranges.Ranges`1.OffsetOfKey(`0)">
<summary>
 Returns the absolute offset of the key in the ranges
</summary>
</member>
<member name="M:Deedle.Ranges.Ranges`1.MergeWith(System.Collections.Generic.IEnumerable{Deedle.Ranges.Ranges{`0}})">
<summary>
 Merge the current range with other specified ranges
</summary>
</member>
<member name="M:Deedle.Ranges.Ranges`1.Lookup(`0,Deedle.Lookup,System.Func{`0,System.Int64,System.Boolean})">
<summary>
 Searches for a key in the range (see `Ranges.lookup` for more info)
</summary>
</member>
<member name="M:Deedle.Ranges.Ranges`1.KeyAtOffset(System.Int64)">
<summary>
 Returns the key at the specified offset
</summary>
</member>
<member name="T:Deedle.Ranges.Ranges`1">
<summary>
 Represents a sub-range of an ordinal index. The range can consist of 
 multiple blocks, i.e. [ 0..9; 20..29 ]. The pairs represent indices
 of first and last element (inclusively) and we also keep size so that
 we do not have to recalculate it.

 For more information, see also the documentation for the `Ranges` module.
</summary>
</member>
<member name="M:Deedle.Ranges.IRangeKeyOperations`1.ValidateKey(`0,Deedle.Lookup)">
<summary>
 Find the first valid key around the specified `&apos;TKey` value. This is used
 when not all `&apos;TKey` values can appear as keys of the series. If lookup is
 `Exact`, it should just check validity; for other lookups, this should either
 find first smaller or first larger valid key (but not skip any keys).

 This is only called with `lookup = Lookup.Exact`, unless you are also using
 `Ranges.lookup` function inside `IVirtualVectorSource&lt;&apos;T&gt;.LookupValue`.
</summary>
</member>
<member name="M:Deedle.Ranges.IRangeKeyOperations`1.Range(`0,`0)">
<summary>
 Generate keys within the specific range (inclusively). Here, the second
 key _can_ be smaller (in which case the range should be from larger to smaller)
</summary>
</member>
<member name="M:Deedle.Ranges.IRangeKeyOperations`1.IncrementBy(`0,System.Int64)">
<summary>
 Get the n-th next key after the specified key (n is always non-negative)
</summary>
</member>
<member name="M:Deedle.Ranges.IRangeKeyOperations`1.Distance(`0,`0)">
<summary>
 Return distance between two keys - return 0 if the keys are the same 
 (the second key is always larger than the first)
</summary>
</member>
<member name="M:Deedle.Ranges.IRangeKeyOperations`1.Compare(`0,`0)">
<summary>
 Compare two keys. Return +1 if first is larger, -1 if second is larger, 0 otherwise
</summary>
</member>
<member name="T:Deedle.Ranges.IRangeKeyOperations`1">
<summary>
 A set of operations on keys that you need to implement in order to use the
 `Ranges&lt;&apos;TKey&gt;` type. The `&apos;TKey` type is typically the key of a BigDeedle
 series. It can represent different things, such as:

  - `int64` - if you have ordinally indexed series 
  - `Date` (of some sort) - if you have daily time series
  - `DateTimeOffset` - if you have time series with DTO keys

 The operations need to implement the *right* thing based on the logic of the
 keys. So for example if you have one data point every hour, `IncrementBy` should
 add the appropriate number of hours. Or if you have keys as business days, the
 `IncrementBy` operation should add a number of business days (that is, the 
 operations may be simple numerical addition, but may contain more logic).

</summary>
</member>
<member name="M:Deedle.Ranges.Ranges.lookup``1(``0,Deedle.Lookup,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Boolean}},Deedle.Ranges.Ranges{``0})">
<summary>
 Implements a lookup using the specified semantics &amp; check function.
 For `Exact` match, this is the same as `offsetOfKey`. In other cases,
 we first find the place where the key *would* be and then scan in one
 or the other direction until &apos;check&apos; returns &apos;true&apos; or we find the end.

 Returns the key together with its offset in the range.
</summary>
</member>
<member name="M:Deedle.Ranges.Ranges.length``1(Deedle.Ranges.Ranges{``0})">
<summary>
 Returns the length of the ranges
</summary>
</member>
<member name="M:Deedle.Ranges.Ranges.keys``1(Deedle.Ranges.Ranges{``0})">
<summary>
 Returns a lazy sequence containing all keys
</summary>
</member>
<member name="M:Deedle.Ranges.Ranges.keyRange``1(Deedle.Ranges.Ranges{``0})">
<summary>
 Returns the smallest &amp; greatest overall key
</summary>
</member>
<member name="M:Deedle.Ranges.Ranges.restrictRanges``1(Deedle.RangeRestriction{``0},Deedle.Ranges.Ranges{``0})">
<summary>
 Restricts the ranges according to the specified range restriction
</summary>
</member>
<member name="M:Deedle.Ranges.Ranges.offsetOfKey``1(``0,Deedle.Ranges.Ranges{``0})">
<summary>
 Returns the offset of a given key. For example, given
 ranges [10..12; 30..32], the function defines a mapping:

   10-&gt;0, 11-&gt;1, 12-&gt;2, 30-&gt;3, 31-&gt;4, 32-&gt;5  

 When the key is wrong, returns `Ranges.invalid`
</summary>
</member>
<member name="M:Deedle.Ranges.Ranges.keyAtOffset``1(System.Int64,Deedle.Ranges.Ranges{``0})">
<summary>
 Returns the key at a given offset. For example, given
 ranges [10..12; 30..32], the function defines a mapping:

   0-&gt;10, 1-&gt;11, 2-&gt;12, 3-&gt;30, 4-&gt;31, 5-&gt;32

 When the offset is wrong, throws `IndexOutOfRangeException`
</summary>
</member>
<member name="P:Deedle.Ranges.Ranges.invalid">
<summary>
 Represents invalid offset
</summary>
</member>
<member name="M:Deedle.Ranges.Ranges.combine``1(System.Collections.Generic.IEnumerable{Deedle.Ranges.Ranges{``0}})">
<summary>
 Combine ranges - the arguments don&apos;t have to be sorted, but must not overlap
 (they can be aligned, in which case ranges are merged)
</summary>
</member>
<member name="M:Deedle.Ranges.Ranges.create``1(Deedle.Ranges.IRangeKeyOperations{``0},System.Collections.Generic.IEnumerable{System.Tuple{``0,``0}})">
<summary>
 Create a range from a sequence of low-high pairs
 and an explicitly specified range key operations
</summary>
</member>
<member name="M:Deedle.Ranges.Ranges.inlineCreate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int64,``0}},System.Collections.Generic.IEnumerable{System.Tuple{``0,``0}})">
<summary>
 Create a range from a sequence of low-high pairs
 (range key operations used standard arithmetic)
</summary>
</member>
<member name="T:Deedle.Ranges.Ranges">
<summary>
 Provides F# functions for working with the `Ranges&lt;&apos;T&gt;` type. Note that 
 most of the functions are also exposed as members. The terminology in the
 functions below is:

  - **offset** refers to an absolute `int64` offset of a key in the range
  - **key** refers to a key value of type `&apos;T`
 
 Say, you have daily range `[ (2015-01-01, 2015-01-10); (2015-02-01, 2015-02-10) ]`.
 Then, the keys are the dates and the offsets are 0 .. 9 for the first part and
 10 .. 19 for the second part.
</summary>
</member>
<member name="T:Deedle.Reflection.ConvertRecordHelper">
<summary>
 Helper that makes it possible to call convertRecordSequence on untyped enumerable
</summary>
</member>
<member name="M:Deedle.Reflection.convertRecordSequenceUntyped(System.Collections.IEnumerable)">
<summary>
 Calls `convertRecordSequence` with a type argument based on the
 type of an implemented `seq&lt;&apos;T&gt;` interface (works when a collection
 implements the interface, but we do not know it statically)
</summary>
</member>
<member name="M:Deedle.Reflection.convertRecordSequence``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Convert a sequence of records to a data frame - automatically
 get the columns based on information available using reflection
</summary>
</member>
<member name="M:Deedle.Reflection.getRecordConvertorExprs(System.Type)">
<summary>
 Given type &apos;T that represents some .NET object, generate an array of
 functions that take seq&lt;&apos;T&gt; and generate IVector with each column:

     vectorBuilder.Create(&lt;input&gt;.Select(fun (recd:&apos;T) -&gt;
       recd.&lt;field&gt;).ToArray()) : IVector&lt;&apos;F&gt;

</summary>
</member>
<member name="M:Deedle.Reflection.expandVector``1(System.Boolean,Deedle.IVector{``0})">
<summary>
 Given a single vector, expand its values into multiple vectors. This may be:
 - `IDictionary` is expanded based on keys/values
 - `ISeries&lt;string&gt;` is expanded
 - .NET types with readable properties are expanded
</summary>
</member>
<member name="P:Deedle.Reflection.getCachedCompileProjection">
<summary>
 Compile all projections from the type, so that we can run them fast
 and cache the results with Type as the key, so that we don&apos;t have to recompile
</summary>
</member>
<member name="M:Deedle.Reflection.expandDictionary(System.Object)">
<summary>
 Given value, return names, types and values of all its IDictionary contents (or None)
</summary>
</member>
<member name="M:Deedle.Reflection.getMemberProjections(System.Type)">
<summary>
 Given System.Type for some .NET object, get a sequence of projections
 that return the values of all readonly properties (together with their name &amp; type)
</summary>
</member>
<member name="P:Deedle.Reflection.createTypedVector">
<summary>
 Helper function used when building frames from data tables
</summary>
</member>
<member name="P:Deedle.Reflection.customExpanders">
<summary>
 Custom expanders that override default behavior
</summary>
</member>
<member name="P:Deedle.Reflection.nonFlattenedTypes">
<summary>
 Mutable collections of interfaces that we want to ignore
</summary>
</member>
<member name="P:Deedle.Reflection.additionalPrimitiveTypes">
<summary>
 Mutable collection of additional primitive types that we want to skip
</summary>
</member>
<member name="M:Deedle.Reflection.getDictionaryValues``2(System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Helper function that returns contents of IDictionary&lt;&apos;K, &apos;V&gt;
</summary>
</member>
<member name="M:Deedle.Reflection.createTypedVectorHelper``1(System.Collections.Generic.IEnumerable{Deedle.OptionalValue{System.Object}})">
<summary>
 Helper function that creates IVector&lt;&apos;T&gt; and casts it to IVector
</summary>
</member>
<member name="M:Deedle.SeriesModule.ZipInto``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Deedle.Series{``3,``0},Deedle.Series{``3,``1})">
<summary>
 Align and zip two series using inner join and exact key matching (use `zipAlignInto`
 for more options). The function calls the specified function `op` to combine values 
 from the two series

 ## Parameters
  - `op` - A function that combines values from the two series. 
  - `series1` - The first (left) series to be aligned
  - `series2` - The second (right) series to be aligned

 [category:Joining, merging and zipping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.ZipAlignInto``4(Deedle.JoinKind,Deedle.Lookup,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},Microsoft.FSharp.Core.FSharpOption{``2}}},Deedle.Series{``3,``0},Deedle.Series{``3,``1})">
<summary>
 Align and zip two series using the specified joining mechanism and key matching.
 The function calls the specified function `op` to combine values from the two series

 ## Parameters
  - `kind` specifies the kind of join you want to use (left, right, inner or outer).
    For inner join, it is better to use `zipInner` instead.
  - `lookup` specifies how matching keys are found when left or right join is used
    on a sorted series. Use this to find the nearest smaller or nearest greater key
    in the other series.
    Supported values are `Lookup.Exact`, `Lookup.ExactOrSmaller` and `Lookup.ExactOrGreater`.
  - `op` - A function that combines values from the two series. In case of left, right
    or outer join, some of the values may be missing. The function can also return 
    `None` to indicate a missing result.
  - `series1` - The first (left) series to be aligned
  - `series2` - The second (right) series to be aligned

 [category:Joining, merging and zipping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.ZipInner``3(Deedle.Series{``0,``1},Deedle.Series{``0,``2})">
<summary>
 Align and zip two series using inner join and exact key matching. The function returns
 a series of tuples with values from the two series.

 [category:Joining, merging and zipping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.ZipAlign``3(Deedle.JoinKind,Deedle.Lookup,Deedle.Series{``0,``1},Deedle.Series{``0,``2})">
<summary>
 Align and zip two series using the specified joining mechanism and key matching.
 The function returns a series of tuples where both elements may be missing. As a result, 
 it is often easier to use join on frames instead.

 ## Parameters
  - `kind` specifies the kind of join you want to use (left, right, inner or outer).
    For inner join, it is better to use `zipInner` instead.
  - `lookup` specifies how matching keys are found when left or right join is used
    on a sorted series. Use this to find the nearest smaller or nearest greater key
    in the other series.
    Supported values are `Lookup.Exact`, `Lookup.ExactOrSmaller` and `Lookup.ExactOrGreater`.
  - `series1` - The first (left) series to be aligned
  - `series2` - The second (right) series to be aligned

 [category:Joining, merging and zipping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Zip``3(Deedle.Series{``0,``1},Deedle.Series{``0,``2})">
<summary>
 Align and zip two series using outer join and exact key matching. The function returns
 a series of tuples where both elements may be missing. As a result, it is often easier
 to use join on frames instead.

 [category:Joining, merging and zipping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.MergeAll``2(System.Collections.Generic.IEnumerable{Deedle.Series{``0,``1}})">
<summary>
 Merge multiple series with distinct keys. When the same key with a value occurs in two
 of the series, an exception is thrown. This function is efficient even when the number
 of series to be merged is large.

 [category:Joining, merging and zipping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.MergeUsing``2(Deedle.UnionBehavior,Deedle.Series{``0,``1},Deedle.Series{``0,``1})">
<summary>
 Merge two series with possibly overlapping keys. The `behavior` parameter specifies
 how to handle situation when a value is definedin both series.

 ## Parameters
  - `behavior` specifies how to handle values available in both series.
    You can use `UnionBehavior.Exclusive` to throw an exception, or 
    `UnionBehavior.PreferLeft` and `UnionBehavior.PreferRight` to prefer values
    from the first or the second series, respectively.
 - `series1` - the first (left) series to be merged
 - `series2` - the second (right) series to be merged

 [category:Joining, merging and zipping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Merge``2(Deedle.Series{``0,``1},Deedle.Series{``0,``1})">
<summary>
 Merge two series with distinct keys. When the same key with a value occurs in both
 series, an exception is thrown. In that case, you can use `mergeUsing`, which allows
 specifying merging behavior.

 [category:Joining, merging and zipping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.lookupTimeAt``2(``0,System.TimeSpan,Deedle.Direction,Deedle.Lookup,Deedle.Series{``0,``1})">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting at the specified `start` time, using the specified `interval`
 and then finds values close to such keys using the specified `lookup` and `dir`.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `start` - The initial time to be used for sampling
  - `interval` - The interval between the individual samples 
  - `dir` - Specifies how the keys should be generated. `Direction.Forward` means that the 
    key is the smallest value of each chunk (and so first key of the series is returned and 
    the last is not, unless it matches exactly _start + k*interval_); `Direction.Backward`
    means that the first key is skipped and sample is generated at, or just before the end 
    of interval and at the end of the series.
  - `lookup` - Specifies how the lookup based on keys is performed. `Exact` means that the
    values at exact keys will be returned; `NearestGreater` returns the nearest greater key value
    (starting at the first key) and `NearestSmaller` returns the nearest smaller key value
    (starting at most `interval` after the end of the series)
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Sampling, resampling and advanced lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.lookupTime``2(System.TimeSpan,Deedle.Direction,Deedle.Lookup,Deedle.Series{``0,``1})">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting from the smallest key of the original series, using the specified `interval`
 and then finds values close to such keys using the specified `lookup` and `dir`.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
  - `dir` - Specifies how the keys should be generated. `Direction.Forward` means that the 
    key is the smallest value of each chunk (and so first key of the series is returned and 
    the last is not, unless it matches exactly _start + k*interval_); `Direction.Backward`
    means that the first key is skipped and sample is generated at, or just before the end 
    of interval and at the end of the series.
  - `lookup` - Specifies how the lookup based on keys is performed. `Exact` means that the
    values at exact keys will be returned; `NearestGreater` returns the nearest greater key value
    (starting at the first key) and `NearestSmaller` returns the nearest smaller key value
    (starting at most `interval` after the end of the series)
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Sampling, resampling and advanced lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.sampleTimeAt``2(``0,System.TimeSpan,Deedle.Direction,Deedle.Series{``0,``1})">
<summary>
 Performs sampling by time and returns chunks obtained by time-sampling as a nested  
 series. The operation generates keys starting at the given `start` time, using the 
 specified `interval` and then obtains chunks based on these
 keys in a fashion similar to the `Series.resample` function.

 ## Parameters
  - `series` - An input series to be resampled
  - `start` - The initial time to be used for sampling
  - `interval` - The interval between the individual samples 
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Sampling, resampling and advanced lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.sampleTime``2(System.TimeSpan,Deedle.Direction,Deedle.Series{``0,``1})">
<summary>
 Performs sampling by time and returns chunks obtained by time-sampling as a nested  
 series. The operation generates keys starting at the first key in the source series,
 using the specified `interval` and then obtains chunks based on these
 keys in a fashion similar to the `Series.resample` function.

 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Sampling, resampling and advanced lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.sampleTimeAtInto``3(``0,System.TimeSpan,Deedle.Direction,Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``1},``2},Deedle.Series{``0,``1})">
<summary>
 Performs sampling by time and aggregates chunks obtained by time-sampling into a single
 value using a specified function. The operation generates keys starting at the given
 `start` time, using the specified `interval` and then obtains chunks based on these
 keys in a fashion similar to the `Series.resample` function.

 ## Parameters
  - `series` - An input series to be resampled
  - `start` - The initial time to be used for sampling
  - `interval` - The interval between the individual samples 
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.
  - `f` - A function that is called to aggregate each chunk into a single value.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Sampling, resampling and advanced lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.sampleTimeInto``3(System.TimeSpan,Deedle.Direction,Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``1},``2},Deedle.Series{``0,``1})">
<summary>
 Performs sampling by time and aggregates chunks obtained by time-sampling into a single
 value using a specified function. The operation generates keys starting at the first
 key in the source series, using the specified `interval` and then obtains chunks based on 
 these keys in a fashion similar to the `Series.resample` function.

 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.
  - `f` - A function that is called to aggregate each chunk into a single value.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Sampling, resampling and advanced lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.resampleUniform``3(Deedle.Lookup,Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``1},Deedle.Series{``0,``2})">
<summary>
 Resample the series based on equivalence class on the keys and also generate values 
 for all keys of the target space that are between the minimal and maximal key of the
 specified series (e.g. generate value for all days in the range covered by the series).
 A specified function `keyProj` is used to project keys to another space and `nextKey`
 is used to generate all keys in the range. Then return the chunks as nested series.

 When there are no values for a (generated) key, then the function behaves according to
 `fillMode`. It can look at the greatest value of previous chunk or smallest value of the
 next chunk, or it produces an empty series.

 ## Parameters
  - `series` - An input series to be resampled
  - `fillMode` - When set to `Lookup.NearestSmaller` or `Lookup.NearestGreater`, 
     the function searches for a nearest available observation in an neighboring chunk.
     Otherwise, the function `f` is called with an empty series as an argument.
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)
  - `nextKey` - A function that gets the next key in the transformed space
    
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 

 [category:Sampling, resampling and advanced lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.resampleUniformInto``4(Deedle.Lookup,Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``1},Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``2},``3},Deedle.Series{``0,``2})">
<summary>
 Resample the series based on equivalence class on the keys and also generate values 
 for all keys of the target space that are between the minimal and maximal key of the
 specified series (e.g. generate value for all days in the range covered by the series).
 A specified function `keyProj` is used to project keys to another space and `nextKey`
 is used to generate all keys in the range. The chunk is then aggregated using `f`.

 When there are no values for a (generated) key, then the function behaves according to
 `fillMode`. It can look at the greatest value of previous chunk or smallest value of the
 next chunk, or it produces an empty series.

 ## Parameters
  - `series` - An input series to be resampled
  - `fillMode` - When set to `Lookup.ExactOrSmaller` or `Lookup.ExactOrGreater`, 
     the function searches for a nearest available observation in an neighboring chunk.
     Otherwise, the function `f` is called with an empty series as an argument.
     Values `Lookup.Smaller` and `Lookup.Greater` are not supported.
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)
  - `nextKey` - A function that gets the next key in the transformed space
  - `f` - A function that is used to collapse a generated chunk into a 
    single value. The function may be called on empty series when `fillMode` is
    `Lookup.Exact`.
    
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 

 [category:Sampling, resampling and advanced lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.resampleEquiv``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``0,``2})">
<summary>
 Resample the series based on equivalence class on the keys. A specified function
 `keyProj` is used to project keys to another space and the observations for which the 
 projected keys are equivalent are grouped into chunks. The chunks are then returned
 as nested series.

 ## Parameters
  - `series` - An input series to be resampled
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)

 ## Remarks
 This function is similar to `Series.chunkBy`, with the exception that it transforms
 keys to a new space.

 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. For unordered
 series, similar functionality can be implemented using `Series.groupBy`.

 [category:Sampling, resampling and advanced lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.resampleEquivInto``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``2},``3},Deedle.Series{``0,``2})">
<summary>
 Resample the series based on equivalence class on the keys. A specified function
 `keyProj` is used to project keys to another space and the observations for which the 
 projected keys are equivalent are grouped into chunks. The chunks are then transformed
 to values using the provided function `f`.

 ## Parameters
  - `series` - An input series to be resampled
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)
  - `f` - A function that is used to collapse a generated chunk into a 
    single value. 

 ## Remarks
 This function is similar to `Series.chunkBy`, with the exception that it transforms
 keys to a new space.

 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. For unordered
 series, similar functionality can be implemented using `Series.groupBy`.

 [category:Sampling, resampling and advanced lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.resample``2(System.Collections.Generic.IEnumerable{``0},Deedle.Direction,Deedle.Series{``0,``1})">
<summary>
 Resample the series based on a provided collection of keys. The values of the series
 are aggregated into chunks based on the specified keys. Depending on `direction`, the 
 specified key is either used as the smallest or as the greatest key of the chunk (with
 the exception of boundaries that are added to the first/last chunk).
 Such chunks are then returned as nested series.

 ## Parameters
  - `series` - An input series to be resampled
  - `keys` - A collection of keys to be used for resampling of the series
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered.

 [category:Sampling, resampling and advanced lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.resampleInto``3(System.Collections.Generic.IEnumerable{``0},Deedle.Direction,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``1},``2}},Deedle.Series{``0,``1})">
<summary>
 Resample the series based on a provided collection of keys. The values of the series
 are aggregated into chunks based on the specified keys. Depending on `direction`, the 
 specified key is either used as the smallest or as the greatest key of the chunk (with
 the exception of boundaries that are added to the first/last chunk).
 Such chunks are then aggregated using the provided function `f`.

 ## Parameters
  - `series` - An input series to be resampled
  - `keys` - A collection of keys to be used for resampling of the series
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.
  - `f` - A function that is used to collapse a generated chunk into a 
    single value. Note that this function may be called with empty series.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered.

 [category:Sampling, resampling and advanced lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.IndexWith``3(System.Collections.Generic.IEnumerable{``0},Deedle.Series{``1,``2})">
<summary>
 Returns a new series containing the specified keys mapped to the original values of the series.
 When the sequence contains _fewer_ keys, the values from the series are dropped. When it 
 contains _more_ keys, the values for additional keys are missing.

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.SeriesModule.IndexOrdinally``2(Deedle.Series{``0,``1})">
<summary>
 Return a new series containing the same values as the original series, but with 
 ordinal index formed by `int` values starting from 0.
 
 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Realign``2(System.Collections.Generic.IEnumerable{``0},Deedle.Series{``0,``1})">
<summary>
 Given an original series and a sequence of keys, returns a new series that contains
 the matching value for each of the specified keys. The `KeyCount` of the returned 
 sequence is the length of `keys`. If there is no value for the specified keys in the
 input sequence, the returned series will contain a missing value.

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Reverse``2(Deedle.Series{``0,``1})">
<summary>
 Returns a new series, containing the observations of the original series in a reverse order.

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Sort``2(Deedle.Series{``0,``1})">
<summary>
 Returns a new series, containing the observations of the original series sorted based
 on the default ordering defined on the values of the series.

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.SeriesModule.SortByKey``2(Deedle.Series{``0,``1})">
<summary>
 Returns a new series whose observations are sorted according to keys of the index.

 ## Parameters
  - `series` - An input series to be sorted

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.SeriesModule.SortBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``2,``0})">
<summary>
 Returns a new series, containing the observations of the original series sorted by 
 values returned by the specified projection function.

 ## Parameters
  - `series` - An input series whose values are sorter
  - `proj` - A projection function that returns a value to be compared for each
    value contained in the original input series.

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.SeriesModule.SortWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},Deedle.Series{``1,``0})">
<summary>
 Returns a new series, containing the observations of the original series sorted using
 the specified comparison function.

 ## Parameters
  - `series` - An input series whose values are sorter
  - `comparer` - A comparer function on the series values. The function should return
    negative integer when the first value is smaller, positive when it is greater and 
    0 when the values are equal.

 [category:Sorting and index manipulation]
</summary>
</member>
<member name="M:Deedle.SeriesModule.sortByCommand``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``2,``0})">
<summary>
 [omit]
</summary>
</member>
<member name="M:Deedle.SeriesModule.sortWithCommand``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},Deedle.Series{``1,``0})">
<summary>
 [omit]
</summary>
</member>
<member name="M:Deedle.SeriesModule.FillMissingInside``2(Deedle.Direction,Deedle.Series{``0,``1})">
<summary>
 Fill missing values only between the first and last non-missing values.

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.SeriesModule.FillMissingBetween``2(``0,``0,Deedle.Direction,Deedle.Series{``0,``1})">
<summary>
 Fill missing values only between `startKey` and `endKey`, inclusive.
 
 ## Parameters
  - `series` - An input series that is to be filled
  - `direction` - Specifies the direction used when searching for 
    the nearest available value. `Backward` means that we want to
    look for the first value with a smaller key while `Forward` searches
    for the nearest greater key.
  - `startKey` - the lower bound at which values should be filled
  - `endKey` - the upper bound at which values should be filled

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.SeriesModule.FillMissing``2(Deedle.Direction,Deedle.Series{``0,``1})">
<summary>
 Fill missing values in the series with the nearest available value
 (using the specified direction). Note that the series may still contain
 missing values after call to this function. This operation can only be
 used on ordered series.

 ## Parameters
  - `series` - An input series that is to be filled
  - `direction` - Specifies the direction used when searching for 
    the nearest available value. `Backward` means that we want to
    look for the first value with a smaller key while `Forward` searches
    for the nearest greater key.

 ## Example

     let sample = Series.ofValues [ Double.NaN; 1.0; Double.NaN; 3.0 ]

     // Returns a series consisting of [1; 1; 3; 3]
     sample |&gt; Series.fillMissing Direction.Backward

     // Returns a series consisting of [&lt;missing&gt;; 1; 1; 3]
     sample |&gt; Series.fillMissing Direction.Forward 

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.SeriesModule.FillMissingWith``3(``0,Deedle.Series{``1,``2})">
<summary>
 Fill missing values in the series with a constant value.

 ## Parameters
  - `series` - An input series that is to be filled
  - `value` - A constant value that is used to fill all missing values

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.SeriesModule.FillMissingUsing``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``0,``1})">
<summary>
 Fill missing values in the series using the specified function.
 The specified function is called with all keys for which the series
 does not contain value and the result of the call is used in place 
 of the missing value. 

 ## Parameters
  - `series` - An input series that is to be filled
  - `f` - A function that takes key `K` and generates a value to be
    used in a place where the original series contains a missing value.

 ## Remarks
 This function can be used to implement more complex interpolation.
 For example see [handling missing values in the tutorial](../frame.html#missing)

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.SeriesModule.DropMissing``2(Deedle.Series{``0,``1})">
<summary>
 Drop missing values from the specified series. The returned series contains 
 only those keys for which there is a value available in the original one.

 ## Parameters
  - `series` - An input series to be filtered

 ## Example

     let s = series [ 1 =&gt; 1.0; 2 =&gt; Double.NaN ]
     s |&gt; Series.dropMissing 
     [fsi:val it : Series&lt;int,float&gt; = series [ 1 =&gt; 1]

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.SeriesModule.WithMissingFrom``3(Deedle.Series{``0,``1},Deedle.Series{``0,``2})">
<summary>
 Returns the current series with the same index but with values missing wherever the 
 corresponding key exists in the other series index with an associated missing value.

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.SeriesModule.groupBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Deedle.Series{``0,``1})">
<summary>
 Groups a series (ordered or unordered) using the specified key selector (`keySelector`) 
 and then returns a series of (nested) series as the result. The outer series is indexed by
 the newly produced keys, the nested series are indexed with the original keys.

 ## Parameters
  - `keySelector` - Generates a new key that is used for aggregation, based on the original 
    key and value. The new key must support equality testing.
  - `series` - An input series to be grouped. 

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.SeriesModule.groupInto``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``1},``3}},Deedle.Series{``0,``1})">
<summary>
 Groups a series (ordered or unordered) using the specified key selector (`keySelector`) 
 and then aggregates each group into a single value, returned in the resulting series,
 using the provided `f` function.

 ## Parameters
  - `keySelector` - Generates a new key that is used for aggregation, based on the original 
    key and value. The new key must support equality testing.
  - `f` - A function to aggregate each group of collected elements.
  - `series` - An input series to be grouped. 

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.SeriesModule.PairwiseWith``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``1,``1},``2}},Deedle.Series{``0,``1})">
<summary>
 Aggregates the input into pairs containing the predecessor and an element for each input, except
 for the first one. Then calls the specified aggregation function `f` with a tuple and a key.
 The returned series is one key shorter (it does not contain a  value for the first key).

 ## Parameters
  - `f` - A function that is called for each pair to produce result in the final series.
  - `series` - The input series to be aggregated.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Pairwise``2(Deedle.Series{``0,``1})">
<summary>
 Returns a series containing the predecessor and an element for each input, except
 for the first one. The returned series is one key shorter (it does not contain a 
 value for the first key).

 ## Parameters
  - `series` - The input series to be aggregated.

 ## Example

     let input = series [ 1 =&gt; &apos;a&apos;; 2 =&gt; &apos;b&apos;; 3 =&gt; &apos;c&apos;]
     let res = input |&gt; Series.pairwise
     res = series [2 =&gt; (&apos;a&apos;, &apos;b&apos;); 3 =&gt; (&apos;b&apos;, &apos;c&apos;) ]

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Chunk``2(System.Int32,Deedle.Series{``0,``1})">
<summary>
 Aggregates the input into a series of adacent chunks and returns the produced chunks as
 a nested series. The key in the new series is the last key of the chunk. This function
 skips incomplete chunks - you can use `Series.chunkSize` for more options.

 ## Parameters
  - `size` - The size of the chunk.
  - `series` - The input series to be aggregated.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.SeriesModule.ChunkInto``3(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``1},``2},Deedle.Series{``0,``1})">
<summary>
 Aggregates the input into a series of adacent chunks and then applies the provided 
 value selector `f` on each chunk to produce the result which is returned as a new series. 
 The key in the new series is the last key of the chunk. This function
 skips incomplete chunks - you can use `Series.chunkSizeInto` for more options.

 ## Parameters
  - `size` - The size of the chunk.
  - `series` - The input series to be aggregated.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Window``2(System.Int32,Deedle.Series{``0,``1})">
<summary>
 Creates a sliding window using the specified size and returns the produced windows as 
 a nested series. The key in the new series is the last key of the window. This function
 skips incomplete chunks - you can use `Series.windowSize` for more options.

 ## Parameters
  - `size` - The size of the sliding window.
  - `series` - The input series to be aggregated.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.SeriesModule.WindowInto``3(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``1},``2},Deedle.Series{``0,``1})">
<summary>
 Creates a sliding window using the specified size and then applies the provided 
 value selector `f` on each window to produce the result which is returned as a new series. 
 This function skips incomplete chunks - you can use `Series.windowSizeInto` for more options.

 ## Parameters
  - `size` - The size of the sliding window.
  - `series` - The input series to be aggregated.
  - `f` - A function that is called on each created window.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.SeriesModule.ChunkWhile``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},Deedle.Series{``0,``1})">
<summary>
 Aggregates the input into a series of adacent chunks based on a condition on keys. A chunk is started 
 once the specified `cond` function returns `false` when called on  the first and the last key of the 
 previous chunk. The chunks are then returned as a nested series.
 The key of each chunk is the key of the first element in the chunk.

 ## Parameters
  - `cond` - A function that is called on the first and the last key of a chunk
    to determine when a window should end.
  - `series` - The input series to be aggregated.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.SeriesModule.ChunkWhileInto``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``1},``2},Deedle.Series{``0,``1})">
<summary>
 Aggregates the input into a series of adacent chunks based on a condition on keys. A chunk is started 
 once the specified `cond` function returns `false` when called on  the first and the last key of the 
 previous chunk. Each chunk is then aggregated into a value using the
 specified function `f`. The key of each chunk is the key of the first element in the chunk.

 ## Parameters
  - `cond` - A function that is called on the first and the last key of a chunk
    to determine when a window should end.
  - `f` - A value selector that is called to aggregate each chunk.
  - `series` - The input series to be aggregated.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.SeriesModule.ChunkDistance``3(``0,Deedle.Series{``1,``2})">
<summary>
 Aggregates the input into a series of adacent chunks. A chunk is started once
 the distance between the first and the last key of a previous chunk is greater
 than the specified `distance`. The chunks are then returned as a nested series.
 The key of each chunk is the key of the first element in the chunk.

 ## Parameters
  - `distance` - The maximal allowed distance between keys of a chunk. Note that this
    is an inline function - there must be `-` operator defined between `distance` and the
    keys of the series.
  - `series` - The input series to be aggregated.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.SeriesModule.ChunkDistanceInto``4(``0,Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``1,``2},``3},Deedle.Series{``1,``2})">
<summary>
 Aggregates the input into a series of adacent chunks. A chunk is started once
 the distance between the first and the last key of a previous chunk is greater
 than the specified `distance`. Each chunk is then aggregated into a value using the
 specified function `f`. The key of each chunk is the key of the first element in the chunk.

 ## Parameters
  - `distance` - The maximal allowed distance between keys of a chunk. Note that this
    is an inline function - there must be `-` operator defined between `distance` and the
    keys of the series.
  - `f` - A value selector that is called to aggregate each chunk.
  - `series` - The input series to be aggregated.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.SeriesModule.ChunkSize``2(System.Int32,Deedle.Boundary,Deedle.Series{``0,``1})">
<summary>
 Aggregates the input into a series of adacent chunks using the specified size and boundary behavior and returns
 the produced chunks as a nested series. The key is the first key of the chunk, unless
 boundary behavior has `Boundary.AtBeginning` flag (in which case it is the last key).

 ## Parameters
  - `bounds` - Specifies the chunk size and bounary behavior. The boundary behavior
    can be `Boundary.Skip` (meaning that no incomplete chunks are produced), 
    `Boundary.AtBeginning` (meaning that incomplete chunks are produced at the beginning)
    or `Boundary.AtEnding` (to produce incomplete chunks at the end of series)
  - `series` - The input series to be aggregated.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.SeriesModule.ChunkSizeInto``3(System.Int32,Deedle.Boundary,Microsoft.FSharp.Core.FSharpFunc{Deedle.DataSegment{Deedle.Series{``0,``1}},``2},Deedle.Series{``0,``1})">
<summary>
 Aggregates the input into a series of adacent chunks using the specified size and boundary behavior and then
 applies the provided value selector `f` on each chunk to produce the result
 which is returned as a new series. The key is the first key of the chunk, unless
 boundary behavior has `Boundary.AtBeginning` flag (in which case it is the last key).

 ## Parameters
  - `bounds` - Specifies the chunk size and bounary behavior. The boundary behavior
    can be `Boundary.Skip` (meaning that no incomplete chunks are produced), 
    `Boundary.AtBeginning` (meaning that incomplete chunks are produced at the beginning)
    or `Boundary.AtEnding` (to produce incomplete chunks at the end of series)
  - `f` - A value selector that is called to aggregate each chunk.
  - `series` - The input series to be aggregated.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.SeriesModule.WindowWhile``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},Deedle.Series{``0,``1})">
<summary>
 Creates a sliding window based on a condition on keys. A window is started at each
 input element and ends once the specified `cond` function returns `false` when called on 
 the first and the last key of the window. The windows are then returned as a nested series.
 The key of each window is the key of the first element in the window.

 ## Parameters
  - `cond` - A function that is called on the first and the last key of a window
    to determine when a window should end.
  - `series` - The input series to be aggregated.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.SeriesModule.WindowWhileInto``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``1},``2},Deedle.Series{``0,``1})">
<summary>
 Creates a sliding window based on a condition on keys. A window is started at each
 input element and ends once the specified `cond` function returns `false` when called on 
 the first and the last key of the window. Each window is then aggregated into a value using the
 specified function `f`. The key of each window is the key of the first element in the window.

 ## Parameters
  - `cond` - A function that is called on the first and the last key of a window
    to determine when a window should end.
  - `f` - A function that is used to aggregate each window into a single value.
  - `series` - The input series to be aggregated.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.SeriesModule.WindowDistance``3(``0,Deedle.Series{``1,``2})">
<summary>
 Creates a sliding window based on distance between keys. A window is started at each
 input element and ends once the distance between the first and the last key is greater
 than the specified `distance`. The windows are then returned as a nested series.
 The key of each window is the key of the first element in the window.

 ## Parameters
  - `distance` - The maximal allowed distance between keys of a window. Note that this
    is an inline function - there must be `-` operator defined between `distance` and the
    keys of the series.
  - `series` - The input series to be aggregated.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.SeriesModule.WindowDistanceInto``4(``0,Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``1,``2},``3},Deedle.Series{``1,``2})">
<summary>
 Creates a sliding window based on distance between keys. A window is started at each
 input element and ends once the distance between the first and the last key is greater
 than the specified `distance`. Each window is then aggregated into a value using the
 specified function `f`. The key of each window is the key of the first element in the window.

 ## Parameters
  - `distance` - The maximal allowed distance between keys of a window. Note that this
    is an inline function - there must be `-` operator defined between `distance` and the
    keys of the series.
  - `f` - A function that is used to aggregate each window into a single value.
  - `series` - The input series to be aggregated.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.SeriesModule.WindowSize``2(System.Int32,Deedle.Boundary,Deedle.Series{``0,``1})">
<summary>
 Creates a sliding window using the specified size and boundary behavior and returns
 the produced windows as a nested series. The key is the last key of the window, unless
 boundary behavior is `Boundary.AtEnding` (in which case it is the first key).

 ## Parameters
  - `bounds` - Specifies the window size and bounary behavior. The boundary behavior
    can be `Boundary.Skip` (meaning that no incomplete windows are produced), 
    `Boundary.AtBeginning` (meaning that incomplete windows are produced at the beginning)
    or `Boundary.AtEnding` (to produce incomplete windows at the end of series)
  - `series` - The input series to be aggregated.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.SeriesModule.WindowSizeInto``3(System.Int32,Deedle.Boundary,Microsoft.FSharp.Core.FSharpFunc{Deedle.DataSegment{Deedle.Series{``0,``1}},``2},Deedle.Series{``0,``1})">
<summary>
 Creates a sliding window using the specified size and boundary behavior and then
 applies the provided value selector `f` on each window to produce the result
 which is returned as a new series. The key is the last key of the window, unless
 boundary behavior is `Boundary.AtEnding` (in which case it is the first key).

 ## Parameters
  - `bounds` - Specifies the window size and bounary behavior. The boundary behavior
    can be `Boundary.Skip` (meaning that no incomplete windows are produced), 
    `Boundary.AtBeginning` (meaning that incomplete windows are produced at the beginning)
    or `Boundary.AtEnding` (to produce incomplete windows at the end of series)
  - `f` - A value selector that is called to aggregate each window.
  - `series` - The input series to be aggregated.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.SeriesModule.AggregateInto``4(Deedle.Aggregation{``0},Microsoft.FSharp.Core.FSharpFunc{Deedle.DataSegment{Deedle.Series{``0,``1}},``2},Microsoft.FSharp.Core.FSharpFunc{Deedle.DataSegment{Deedle.Series{``0,``1}},Deedle.OptionalValue{``3}},Deedle.Series{``0,``1})">
<summary>
 Aggregates an ordered series using the method specified by `Aggregation&lt;K&gt;` and then
 applies the provided value selector `f` on each window or chunk to produce the result
 which is returned as a new series. A key for each window or chunk is
 selected using the specified `keySelector`.

 ## Parameters
  - `aggregation` - Specifies the aggregation method using `Aggregation&lt;K&gt;`. This is
    a discriminated union listing various chunking and windowing conditions.
  - `keySelector` - A function that is called on each chunk to obtain a key.
  - `f` - A value selector function that is called to aggregate each chunk or window.
  - `series` - The input series to be aggregated.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Aggregate``3(Deedle.Aggregation{``0},Microsoft.FSharp.Core.FSharpFunc{Deedle.DataSegment{Deedle.Series{``0,``1}},``2},Deedle.Series{``0,``1})">
<summary>
 Aggregates an ordered series using the method specified by `Aggregation&lt;K&gt;` and 
 returns the windows or chunks as nested series. A key for each window or chunk is
 selected using the specified `keySelector`.

 ## Parameters
  - `aggregation` - Specifies the aggregation method using `Aggregation&lt;K&gt;`. This is
    a discriminated union listing various chunking and windowing conditions.
  - `keySelector` - A function that is called on each chunk to obtain a key.
  - `series` - The input series to be aggregated.

 [category:Grouping, windowing and chunking]
</summary>
</member>
<member name="M:Deedle.SeriesModule.ReduceLevel``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``2,``2}},Deedle.Series{``0,``2})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `level` and then aggregates elements in each group
 using the specified function `op`. The result is a new series containing
 the aggregates of each group. 

 This operation is designed to be used with [hierarchical indexing](../frame.html#indexing).

 ## Parameters
  - `series` - An input series to be aggregated
  - `op` - A function that is used to aggregate elements of each group
  - `level` - A delegate that returns a new group key, based on the key in the input series

 [category:Hierarchical index operations]
</summary>
</member>
<member name="M:Deedle.SeriesModule.ApplyLevelOptional``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``2},Microsoft.FSharp.Core.FSharpOption{``3}},Deedle.Series{``0,``2})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `level` and then aggregates series representing each group
 using the specified function `op`. The result is a new series containing
 the aggregates of each group. The result of a group may be None, in which
 case the group will have no representation in the resulting series. 

 This operation is designed to be used with [hierarchical indexing](../frame.html#indexing).

 ## Parameters
  - `series` - An input series to be aggregated
  - `op` - A function that takes a series and produces an optional aggregated result
  - `level` - A delegate that returns a new group key, based on the key in the input series

 [category:Hierarchical index operations]
</summary>
</member>
<member name="M:Deedle.SeriesModule.ApplyLevel``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``2},``3},Deedle.Series{``0,``2})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `level` and then aggregates series representing each group
 using the specified function `op`. The result is a new series containing
 the aggregates of each group. 

 This operation is designed to be used with [hierarchical indexing](../frame.html#indexing).

 ## Parameters
  - `series` - An input series to be aggregated
  - `op` - A function that takes a series and produces an aggregated result
  - `level` - A delegate that returns a new group key, based on the key in the input series

 [category:Hierarchical index operations]
</summary>
</member>
<member name="M:Deedle.SeriesModule.fillErrorsWith``2(``0,Deedle.Series{``1,Deedle.TryValue{``0}})">
<summary>
 Givnen a series of `tryval&lt;&apos;V&gt;` values, returns a new series where all `Error` 
 values are filled with the specified constant value.

 [category:Processing series with exceptions]
</summary>
</member>
<member name="M:Deedle.SeriesModule.trySuccesses``2(Deedle.Series{``0,Deedle.TryValue{``1}})">
<summary>
 Given a series of `tryval&lt;&apos;V&gt;` values, returns a series that contains all values
 contained in the source series. The input elements containing exceptions are ignored.

 [category:Processing series with exceptions]
</summary>
</member>
<member name="M:Deedle.SeriesModule.tryErrors``2(Deedle.Series{``0,Deedle.TryValue{``1}})">
<summary>
 Given a series of `tryval&lt;&apos;V&gt;` values, returns a series that contains all exceptions
 contained in the source series. The exceptions are returned as a series.

 [category:Processing series with exceptions]
</summary>
</member>
<member name="M:Deedle.SeriesModule.tryValues``2(Deedle.Series{``0,Deedle.TryValue{``1}})">
<summary>
 Obtains values from a series of `tryval&lt;&apos;T&gt;` values. When the series contains
 one or more failures, the operation throws `AggregateException`. Otherwise, it
 returns a series containing values.

 [category:Processing series with exceptions]
</summary>
</member>
<member name="M:Deedle.SeriesModule.tryMap``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Deedle.Series{``0,``1})">
<summary>
 Returns a new series by applying the specified transformation to all values 
 of the input series. The result contains `Error(e)` when the projection fails
 with an exception `e` or `Success(v)` containing a value `v` otherwise.

 [category:Processing series with exceptions]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Shift``2(System.Int32,Deedle.Series{``0,``1})">
<summary>
 Returns a series with values shifted by the specified offset. When the offset is 
 positive, the values are shifted forward and first `offset` keys are dropped. When the
 offset is negative, the values are shifted backwards and the last `offset` keys are dropped.
 Expressed in pseudo-code:

     result[k] = series[k - offset]

 ## Parameters
  - `offset` - Can be both positive and negative number.
  - `series` - The input series to be shifted.

 ## Remarks
 If you want to calculate the difference, e.g. `s - (Series.shift 1 s)`, you can
 use `Series.diff` which will be a little bit faster.

 [category:Series transformations]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Diff``2(System.Int32,Deedle.Series{``0,``1})">
<summary>
 Returns a series containing difference between a value in the original series and 
 a value at the specified offset. For example, calling `Series.diff 1 s` returns a 
 series where previous value is subtracted from the current one. In pseudo-code, the
 function behaves as follows:

     result[k] = series[k] - series[k - offset]

 ## Parameters
  - `offset` - When positive, subtracts the past values from the current values;
    when negative, subtracts the future values from the current values.
  - `series` - The input series, containing values that support the `-` operator.

 [category:Series transformations]
</summary>
</member>
<member name="M:Deedle.SeriesModule.FoldValues``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Deedle.Series{``2,``1})">
<summary>
 Aggregates the values of the specified series using a function that can combine
 individual values. The folding starts with the specified initial value.

 ## Parameters
  - `series` - An input series to be aggregated
  - `init` - An initial value for the aggregation
  - `op` - A function that is used to aggregate elements of the series with the current state

 [category:Series transformations]
</summary>
</member>
<member name="M:Deedle.SeriesModule.ReduceValues``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Deedle.Series{``1,``0})">
<summary>
 Aggregates the values of the specified series using a function that can combine
 individual values. Fails if the series contains no values.

 ## Parameters
  - `series` - An input series to be aggregated
  - `op` - A function that is used to aggregate elements of the series

 [category:Series transformations]
</summary>
</member>
<member name="M:Deedle.SeriesModule.ScanAllValues``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},Microsoft.FSharp.Core.FSharpOption{``0}}},Microsoft.FSharp.Core.FSharpOption{``0},Deedle.Series{``2,``1})">
<summary>
 Applies a folding function starting with some initial optional value and the first optional value of 
 the series, and continues to &quot;scan&quot; along the series, saving all values produced from the first function 
 application, and yielding a new series having the original index and newly produced values.

 ## Parameters
  - `foldFunc` - A folding function 
  - `init` - An initial value
  - `series` - The series over whose values to scan

 [category:Series transformations]
</summary>
</member>
<member name="M:Deedle.SeriesModule.ScanValues``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Deedle.Series{``2,``1})">
<summary>
 Applies a folding function starting with some initial value and the first value of the series,
 and continues to &quot;scan&quot; along the series, saving all values produced from the first function 
 application, and yielding a new series having the original index and newly produced values.
 Any application involving a missing value yields a missing value.

 ## Parameters
  - `foldFunc` - A folding function 
  - `init` - An initial value
  - `series` - The series over whose values to scan

 [category:Series transformations]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Force``2(Deedle.Series{``0,``1})">
<summary>
 Returns a new fully evaluated series. If the source series contains a lazy index or
 lazy vectors, these are forced to evaluate and the resulting series is fully loaded in memory.
 [category:Series transformations]
</summary>
</member>
<member name="M:Deedle.SeriesModule.SkipLast``2(System.Int32,Deedle.Series{``0,``1})">
<summary>
 Returns a series that contains the data from the original series,
 except for the last `count` keys.

 ## Parameters
  - `count` - Number of keys to skip; must be smaller or equal to the original number of keys
  - `series` - Input series from which the keys are taken

 [category:Series transformations]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Skip``2(System.Int32,Deedle.Series{``0,``1})">
<summary>
 Returns a series that contains the data from the original series,
 except for the first `count` keys.

 ## Parameters
  - `count` - Number of keys to skip; must be smaller or equal to the original number of keys
  - `series` - Input series from which the keys are taken

 [category:Series transformations]
</summary>
</member>
<member name="M:Deedle.SeriesModule.TakeLast``2(System.Int32,Deedle.Series{``0,``1})">
<summary>
 Returns a series that contains the specified number of keys from the 
 original series. The keys are taken from the end of the series. 

 ## Parameters
  - `count` - Number of keys to take; must be smaller or equal to the original number of keys
  - `series` - Input series from which the keys are taken

 [category:Series transformations]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Take``2(System.Int32,Deedle.Series{``0,``1})">
<summary>
 Returns a series that contains the specified number of keys from the original series. 

 ## Parameters
  - `count` - Number of keys to take; must be smaller or equal to the original number of keys
  - `series` - Input series from which the keys are taken

 [category:Series transformations]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Flatten``2(Deedle.Series{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
<summary>
 Given a series containing optional values, flatten the option values.
 That is, `None` values become missing values of the series and `Some` values
 become ordinary values in the resulting series.

 [category:Series transformations]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Convert``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``0},Deedle.Series{``2,``0})">
<summary>
 Retruns a new series whose values are converted using the specified conversion function.
 This operation is like `mapValues`, but it requires a pair of function that converts 
 the values in _both ways_. 

 ## Parameters
  - `forward` - Function that converts original values to the new
  - `backward` - Function that converts new values back to the original

 ## Remarks
 This operation is only interesting when working with virtualized data sources. Using the
 `convert` function makes it possible to perfom additional operations on the resulting
 series - for example lookup - by converting the new value back and using the lookup of
 the underlying virtualized source.
</summary>
</member>
<member name="M:Deedle.SeriesModule.MapKeys``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``0,``2})">
<summary>
 Returns a new series whose keys are the results of applying the given function to
 keys of the original series. 

 [category:Series transformations]
</summary>
</member>
<member name="M:Deedle.SeriesModule.MapAll``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},Microsoft.FSharp.Core.FSharpOption{``2}}},Deedle.Series{``0,``1})">
<summary>
 Returns a new series whose values are the results of applying the given function to
 values of the original series. This specified function is called even when the value
 is missing. It returns `option&lt;&apos;T&gt;` so that it can create/eliminate missing values in
 the result.

 [category:Series transformations]
</summary>
</member>
<member name="M:Deedle.SeriesModule.MapValues``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``2,``0})">
<summary>
 Returns a new series whose values are the results of applying the given function to
 values of the original series. This function skips over missing values and call the
 function with just values. It is also aliased using the `$` operator so you can write
 `series $ func` for `series |&gt; Series.mapValues func`.

 [category:Series transformations]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Deedle.Series{``0,``1})">
<summary>
 Returns a new series whose values are the results of applying the given function to
 values of the original series. This function skips over missing values and call the
 function with both keys and values.

 [category:Series transformations]
</summary>
</member>
<member name="M:Deedle.SeriesModule.FilterAll``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},System.Boolean}},Deedle.Series{``0,``1})">
<summary>
 Returns a new series containing only the elements for which the specified predicate
 returns `true`. The predicate is called for missing values as well.

 [category:Series transformations]
</summary>
</member>
<member name="M:Deedle.SeriesModule.FilterValues``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Deedle.Series{``1,``0})">
<summary>
 Returns a new series containing only the elements for which the specified predicate
 returns `true`. The function skips over missing values and calls the predicate with
 just the value. See also `filterAll` and `filter` for more options.

 [category:Series transformations]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Filter``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Deedle.Series{``0,``1})">
<summary>
 Returns a new series containing only the elements for which the specified predicate
 returns `true`. The function skips over missing values. If you want to handle missing
 values, use `filterAll` instead.

 [category:Series transformations]
</summary>
</member>
<member name="M:Deedle.SeriesModule.GetKeys``2(Deedle.Series{``0,``1})">
<summary>
 Returns the keys of the series as a sequence
 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.GetAllValues``2(Deedle.Series{``0,``1})">
<summary>
 Returns the series values (both missing and present) as a sequence
 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.GetValues``2(Deedle.Series{``0,``1})">
<summary>
 Returns the (non-missing) values of the series as a sequence
 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.TryGetFirstValue``2(Deedle.Series{``0,``1})">
<summary>
 Returns the last value of the series if one exists.
 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.GetFirstValue``2(Deedle.Series{``0,``1})">
<summary>
 Returns the first value of the series. This fails if the first value is missing.
 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.TryGetLastValue``2(Deedle.Series{``0,``1})">
<summary>
 Returns the last value of the series if one exists.
 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.GetLastValue``2(Deedle.Series{``0,``1})">
<summary>
 Returns the last value of the series. This fails if the last value is missing.
 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.GetFirstKey``2(Deedle.Series{``0,``1})">
<summary>
 Returns the first key of the series, or throws exception if one doesn&apos;t exist
 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.GetLastKey``2(Deedle.Series{``0,``1})">
<summary>
 Returns the last key of the series, or throws exception if one doesn&apos;t exist
 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.HasNot``2(``0,Deedle.Series{``0,``1})">
<summary>
 Returns true when the series does not contains value for the specified key
 (This is useful for checking prior to performing a computation)

 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Has``2(``0,Deedle.Series{``0,``1})">
<summary>
 Returns true when the series contains value for the specified key
 (This is useful for checking prior to performing a computation)

 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.HasNone``2(System.Collections.Generic.IEnumerable{``0},Deedle.Series{``0,``1})">
<summary>
 Returns true when the series does not contains value for any of the specified keys
 (This is useful for checking prior to performing a computation)

 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.HasSome``2(System.Collections.Generic.IEnumerable{``0},Deedle.Series{``0,``1})">
<summary>
 Returns true when the series contains value for some of the specified keys
 (This is useful for checking prior to performing a computation)

 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.HasAll``2(System.Collections.Generic.IEnumerable{``0},Deedle.Series{``0,``1})">
<summary>
 Returns true when the series contains value for all of the specified keys
 (This is useful for checking prior to performing a computation)

 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.CountKeys``2(Deedle.Series{``0,``1})">
<summary>
 Returns the total number of keys in the specified series. This returns
 the total length of the series, including keys for which there is no 
 value available.

 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.CountValues``2(Deedle.Series{``0,``1})">
<summary>
 Returns the total number of values in the specified series. This excludes
 missing values or not available values (such as values created from `null`,
 `Double.NaN`, or those that are missing due to outer join etc.).

 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.TryGetAt``2(System.Int32,Deedle.Series{``0,``1})">
<summary>
 Returns the value at the specified (integer) offset, or `None` if the value is missing.

 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.TryGet``2(``0,Deedle.Series{``0,``1})">
<summary>
 Get the value for the specified key. Returns `None` when the key does not exist
 or the value is missing.
 Uses exact lookup semantics for key lookup - use `tryLookup` for more options

 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.TryLookupObservation``2(``0,Deedle.Lookup,Deedle.Series{``0,``1})">
<summary>
 Attempts to get an observation (key value pair) based on the specified key.
 The search uses the specified lookup semantics and so the returned key
 may differ from the key searched for. If the value is not
 available, `None` is returned.

 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.TryLookup``2(``0,Deedle.Lookup,Deedle.Series{``0,``1})">
<summary>
 Attempts to get the value for the specified key. If the value is not
 available, `None` is returned.
 Use the specified lookup semantics - for exact matching, use `tryGet`.

 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.GetAt``2(System.Int32,Deedle.Series{``0,``1})">
<summary>
 Returns the value at the specified (integer) offset.

 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Get``2(``0,Deedle.Series{``0,``1})">
<summary>
 Get the value for the specified key.
 Uses exact lookup semantics for key lookup - use `lookup` for more options

 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Lookup``2(``0,Deedle.Lookup,Deedle.Series{``0,``1})">
<summary>
 Get the value for the specified key.
 Use the specified lookup semantics - for exact matching, use `get`

 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.GetObservations``2(System.Collections.Generic.IEnumerable{``0},Deedle.Series{``0,``1})">
<summary>
 Create a new series that contains values for all provided keys.
 Uses exact lookup semantics for key lookup - use `lookupAll` for more options

 ## Parameters
  - `keys` - A sequence of keys that will form the keys of the retunred sequence

 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Sample``2(System.Collections.Generic.IEnumerable{``0},Deedle.Series{``0,``1})">
<summary>
 Sample an (ordered) series by finding the value at the exact or closest prior key 
 for some new sequence of keys. 

 ## Parameters
  - `keys` - A sequence of keys that will form the keys of the retunred sequence

 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.LookupAll``2(System.Collections.Generic.IEnumerable{``0},Deedle.Lookup,Deedle.Series{``0,``1})">
<summary>
 Create a new series that contains values for all provided keys.
 Use the specified lookup semantics - for exact matching, use `getAll`

 ## Parameters
  - `keys` - A sequence of keys that will form the keys of the retunred sequence
  - `lookup` - Lookup behavior to use when the value at the specified key does not exist

 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.GetAllObservations``2(Deedle.Series{``0,``1})">
<summary>
 Returns all keys from the sequence, together with the associated (optional) values. 

 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.GetObservations``2(Deedle.Series{``0,``1})">
<summary>
 Return observations with available values. The operation skips over 
 all keys with missing values (such as values created from `null`,
 `Double.NaN`, or those that are missing due to outer join etc.).

 [category:Accessing series data and lookup]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Implementation.lookupTimeInternal``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpOption{``0},``1,Deedle.Direction,Deedle.Lookup,Deedle.Series{``0,``2})">
<summary>
 Given a specified starting time and time span, generates all keys that fit in the
 range of the series (and one additional, if `dir = Backward`) and then performs lookup
 for each key using the specified direction
</summary>
</member>
<member name="M:Deedle.SeriesModule.Implementation.sampleTimeIntoInternal``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpOption{``0},``1,Deedle.Direction,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``2},``3}},Deedle.Series{``0,``2})">
<summary>
 Given a specified starting time and time span, generates all keys that fit in the
 range of the series (and one additional, if `dir = Backward`) and then performs
 sampling using `resampleInto`.
</summary>
</member>
<member name="T:Deedle.SeriesModule.Implementation">
<summary>
 [omit]
 Module that contains an implementation of sampling for `sampleTime` and 
 `sampleTimeInto`. For technical reasons (`inline`) this is public..
</summary>
</member>
<member name="T:Deedle.SeriesModule">
<summary>
 The `Series` module provides an F#-friendly API for working with data and time series. 
 The API follows the usual design for collection-processing in F#, so the functions work
 well with the pipelining (`|&gt;`) operator. For example, given a series with ages,
 we can use `Series.filterValues` to filter outliers and then `Stats.mean` to calculate
 the mean:

     ages
     |&gt; Series.filterValues (fun v -&gt; v &gt; 0.0 &amp;&amp; v &lt; 120.0)
     |&gt; Stats.mean

 The module provides comprehensive set of functions for working with series. The same
 API is also exposed using C#-friendly extension methods. In C#, the above snippet could
 be written as:

     [lang=csharp]
     ages
       .Where(kvp =&gt; kvp.Value &gt; 0.0 &amp;&amp; kvp.Value &lt; 120.0)
       .Mean()
 
 For more information about similar frame-manipulation functions, see the `Frame` module.
 For more information about C#-friendly extensions, see `SeriesExtensions`. The functions 
 in the `Series` module are grouped in a number of categories and documented below.

 Accessing series data and lookup
 --------------------------------

 Functions in this category provide access to the values in the series.

  - The term _observation_ is used for a key value pair in the series. 
  - When working with a sorted series, it is possible to perform lookup using
    keys that are not present in the series - you can specify to search for the
    previous or next available value using _lookup behavior_.
  - Functions such as `get` and `getAll` have their counterparts `lookup` and
    `lookupAll` that let you specify lookup behavior.
  - For most of the functions that may fail, there is a `try[Foo]` variant that
    returns `None` instead of failing.
  - Functions with a name ending with `At` perform lookup based on the absolute
    integer offset (and ignore the keys of the series)

 Series transformations 
 ----------------------

 Functions in this category perform standard transformations on series including
 projections, filtering, taking some sub-series of the series, aggregating values
 using scanning and so on.

 Projection and filtering functions generally skip over missing values, but there
 are variants `filterAll` and `mapAll` that let you handle missing values explicitly.
 Keys can be transformed using `mapKeys`. When you do not need to consider the keys,
 and only care about values, use `filterValues` and `mapValues` (which is also aliased
 as the `$` operator). 

 Series supports standard set of folding functions including `reduce` and `fold` (to
 reduce series values into a single value) as well as the `scan[All]` function, which 
 can be used to fold values of a series into a series of intermeidate folding results.

 The functions `take[Last]` and `skip[Last]` can be used to take a sub-series of the
 original source series by skipping a specified number of elements. Note that this 
 does not require an ordered series and it ignores the index - for index-based lookup
 use slicing, such as `series.[lo .. hi]`, instead.

 Finally the `shift` function can be used to obtain a series with values shifted by 
 the specified offset. This can be used e.g. to get previous value for each key using
 `Series.shift 1 ts`. The `diff` function calculates difference from previous value using
 `ts - (Series.shift offs ts)`.

 Processing series with exceptions
 ---------------------------------
 
 The functions in this group can be used to write computations over series that may fail.
 They use the type `tryval&lt;&apos;T&gt;` which is defined as a discriminated union:

     type tryval&lt;&apos;T&gt; = 
       | Success of &apos;T
       | Error of exn

 The function `tryMap` lets you create `Series&lt;&apos;K, tryval&lt;&apos;T&gt;&gt;` by mapping over values
 of an original series. You can then extract values using `tryValues`, which throws 
 `AggregateException` if there were any errors. Functions `tryErrors` and `trySuccesses`
 give series containing only errors and successes. You can fill failed values with
 a constant using `fillErrorsWith`.
 
 Hierarchical index operations
 -----------------------------

 When the key of a series is tuple, the elements of the tuple can be treated
 as multiple levels of a index. For example `Series&lt;&apos;K1 * &apos;K2, &apos;V&gt;` has two 
 levels with keys of types `&apos;K1` and `&apos;K2` respectively.

 The functions in this cateogry provide a way for aggregating values in the 
 series at one of the levels. For example, given a series `input` indexed by
 two-element tuple, you can calculate mean for different first-level values as
 follows:

     input |&gt; applyLevel fst Stats.mean

 Note that the `Stats` module provides helpers for typical statistical operations,
 so the above could be written just as `input |&gt; Stats.levelMean fst`.
 
 Grouping, windowing and chunking
 --------------------------------

 This category includes functions that group data from a series in some way. Two key
 concepts here are _window_ and _chunk_. Window refers to (overlapping) sliding windows
 over the input series while chunk refers to non-overlapping blocks of the series.

 The boundary behavior can be specified using the `Boundary` flags. The value 
 `Skip` means that boundaries (incomplete windows or chunks) should be skipped. The value
 `AtBeginning` and `AtEnding` can be used to define at which side should the boundary be
 returned (or skipped). For chunking, `AtBeginning ||| Skip` makes sense and it means that
 the incomplete chunk at the beginning should be skipped (aligning the last chunk with the end).

 The behavior may be specified in a number of ways (which is reflected in the name):
  - `dist` - using an absolute distance between the keys
  - `while` - using a condition on the first and last key
  - `size` - by specifying the absolute size of the window/chunk

 The functions ending with `Into` take a function to be applied to the window/chunk. 
 The functions `window`, `windowInto` and `chunk`, `chunkInto` are simplified versions
 that take a size. There is also `pairwise` function for sliding window of size two.

 Missing values
 --------------

 This group of functions provides a way of working with missing values in a series.
 The `dropMissing` function drops all keys for which there are no values in the series.
 The `withMissingFrom` function lets you copy missing values from another series.
 The remaining functions provide different mechanism for filling the missing values.

  * `fillMissingWith` fills missing values with a specified constant
  * `fillMissingUsing` calls a specified function for every missing value
  * `fillMissing` and variants propagates values from previous/later keys

 Sorting and index manipulation
 ------------------------------
 
 A series that is sorted by keys allows a number of additional operations (such as lookup
 using the `Lookp.ExactOrSmaller` lookup behavior). However, it is also possible to sort 
 series based on the values - although the functions for manipulation with series do not
 guarantee that the order will be preserved.

 To sort series by keys, use `sortByKey`. Other sorting functions let you sort the series
 using a specified comparer function (`sortWith`), using a projection function (`sortBy`)
 and using the default comparison (`sort`).

 In addition, you can also replace the keys of a series with other keys using `indexWith` 
 or with integers using `indexOrdinally`. To pick and reorder series values using to match
 a list of keys use `realign`.

 Sampling, resampling and advanced lookup
 ----------------------------------------

 Given a (typically) time series sampling or resampling makes it possible to 
 get time series with representative values at lower or uniform frequency.
 We use the following terminology:

  - `lookup` and `sample` functions find values at specified key; if a key is not
    available, they can look for value associated with the nearest smaller or 
    the nearest greater key.
 
  - `resample` function aggregate values values into chunks based
    on a specified collection of keys (e.g. explicitly provided times), or 
    based on some relation between keys (e.g. date times having the same date).
 
  - `resampleUniform` is similar to resampling, but we specify keys by
    providing functions that generate a uniform sequence of keys (e.g. days),
    the operation also fills value for days that have no corresponding 
    observations in the input sequence.

 Joining, merging and zipping
 ----------------------------

 Given two series, there are two ways to combine the values. If the keys in the series
 are not overlapping (or you want to throw away values from one or the other series), 
 then you can use `merge` or `mergeUsing`. To merge more than 2 series efficiently, use 
 the `mergeAll` function, which has been optimized for large number of series.

 If you want to align two series, you can use the _zipping_ operation. This aligns
 two series based on their keys and gives you tuples of values. The default behavior
 (`zip`) uses outer join and exact matching. For ordered series, you can specify 
 other forms of key lookups (e.g. find the greatest smaller key) using `zipAlign`.
 functions ending with `Into` are generally easier to use as they call a specified
 function to turn the tuple (of possibly missing values) into a new value.

 For more complicated behaviors, it is often convenient to use joins on frames instead
 of working with series. Create two frames with single columns and then use the join
 operation. The result will be a frame with two columns (which is easier to use than
 series of tuples).

 [category:Frame and series operations]
</summary>
</member>
<member name="T:Deedle.StatsHelpers.Moments">
<summary>
 Represents the moments as calculated during online processing
 (`nobs` is the count, `sum` is the sum, `M1` to `M4` are moments)
</summary>
</member>
<member name="T:Deedle.StatsHelpers.Sums">
<summary>
 When calculating moments, this record is used to keep track of the 
 count (`nobs`), sum of values (`sum`), sum of squares (`sum2`),
 sum of values to the power of 3 and 3 (`sum3` and `sum4`)
</summary>
</member>
<member name="M:Deedle.StatsHelpers.quickSelectInplace(System.Int32,System.Double[])">
<summary>
 Returns the nth smallest element from the specified array.
 (QuickSelect implementation based on: http://en.wikipedia.org/wiki/Quickselect)
</summary>
</member>
<member name="M:Deedle.StatsHelpers.trySeriesExtreme``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Deedle.Series{``1,``0})">
<summary>
 Calculates minimum or maximum using the specified function &apos;f&apos;
 Returns None when there are no values or Some.
</summary>
</member>
<member name="M:Deedle.StatsHelpers.valuesAllOpt``2(Deedle.Series{``0,``1})">
<summary>
 Returns all values of a series as an array of `OptionalValue`s
</summary>
</member>
<member name="M:Deedle.StatsHelpers.expandingMinMaxHelper(Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Boolean}},System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpOption{System.Double}})">
<summary>
 Calculates minimum or maximum over an expanding window
</summary>
</member>
<member name="M:Deedle.StatsHelpers.applyExpandingMomentsTransform``1(Microsoft.FSharp.Core.FSharpFunc{Deedle.StatsHelpers.Moments,System.Double},Deedle.Series{``0,System.Double})">
<summary>
 Given a series, calculates expanding moments (using online `updateMoments`)
 The specified `proj` function is used to calculate the resulting value
</summary>
</member>
<member name="M:Deedle.StatsHelpers.updateMomentsSparse(Deedle.StatsHelpers.Moments,Deedle.OptionalValue{System.Double})">
<summary>
 Updates the moments using `updateMoments`, but skips over missing values
</summary>
</member>
<member name="M:Deedle.StatsHelpers.updateMoments(Deedle.StatsHelpers.Moments,System.Double)">
<summary>
 Updates the moments using the Knuth/Welford algorithm for online stats updating
 (See: http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Online_algorithm)
</summary>
</member>
<member name="M:Deedle.StatsHelpers.expandingWindowFn``3(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,``2},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Helper for expanding window calculations

 ## Parameters
  - `initState` is the initial state of the computation
</summary>
</member>
<member name="M:Deedle.StatsHelpers.movingMinMaxHelper(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Boolean}},System.Collections.Generic.IEnumerable{Deedle.OptionalValue{System.Double}})">
<summary>
 O(n) moving min/max calculator

 Keeps double-ended queue of values sorted acording to the specified order,
 such that the front is the min/max value. During the iteration, new value is
 added to the end (and all values that are greater/smaller than the new value
 are removed before it is appended).
</summary>
</member>
<member name="M:Deedle.StatsHelpers.kurtSums(Deedle.StatsHelpers.Sums)">
<summary>
 Calculate kurtosis from `Sums`; requires `moment=4`
</summary>
</member>
<member name="M:Deedle.StatsHelpers.skewSums(Deedle.StatsHelpers.Sums)">
<summary>
 Calculate skewness from `Sums`; requires `moment=3`
</summary>
</member>
<member name="M:Deedle.StatsHelpers.varianceSums(Deedle.StatsHelpers.Sums)">
<summary>
 Calculate variance from `Sums`; requires `moment=2`
</summary>
</member>
<member name="M:Deedle.StatsHelpers.applyMovingSumsTransform``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{Deedle.StatsHelpers.Sums,System.Double},Deedle.Series{``0,System.Double})">
<summary>
 Apply moving window transformation based on `Sums` calculation. The `proj` function
 calculates the statistics from `Sums` value and the `moment` specifies which of the
 `Sums` properties are calculated during the processing.
</summary>
</member>
<member name="M:Deedle.StatsHelpers.updateSumsSparse(System.Int32,Deedle.StatsHelpers.Sums,Deedle.OptionalValue{System.Double},Deedle.OptionalValue{System.Double})">
<summary>
 Update `Sums` value using `updateSumsDense`, but handle the case
 when removing/adding value that is missing (`OptionalValue.Missing`)
</summary>
</member>
<member name="M:Deedle.StatsHelpers.initSumsSparse(System.Int32,Deedle.OptionalValue{System.Double}[])">
<summary>
 Pick only available values from the input array and call `initSumsDense`
 (no need to handle `nan` values, because those are returned as Missing by Deedle)
</summary>
</member>
<member name="M:Deedle.StatsHelpers.updateSumsDense(System.Int32,Deedle.StatsHelpers.Sums,System.Double,System.Double)">
<summary>
 Given an existing `state` of type `Sums`, new incoming element and
 an old outgoing element, update the sums value
 (only required elements of `Sums` are calculated based on `moment`)
</summary>
</member>
<member name="M:Deedle.StatsHelpers.initSumsDense(System.Int32,System.Double[])">
<summary>
 Given an initial array of values, calculate the initial `Sums` value
 (only required elements of `Sums` are calculated based on `moment`)
</summary>
</member>
<member name="M:Deedle.StatsHelpers.movingWindowFn``2(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0[],``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1}}},Microsoft.FSharp.Core.FSharpFunc{``1,System.Double},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Helper for moving window calculations (adopted from `Seq.windowed` in F# code base)
 When calling `finit`, we do not copy the array - this is fine, because the function
 is internal (and the only use in `applyMovingSumsTransform` is correct)

 # Parameters
   - `winSize` - The size of the window to create
   - `finit` takes the first fully populated window array to an initial state
   - `fupdate` takes the current state, incoming observation, 
      and out-going observation to the next state
   - `ftransf` takes the current state to the current output
</summary>
</member>
<member name="M:Deedle.StatsHelpers.applySeriesProj``1(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{Deedle.OptionalValue{System.Double}},System.Double[]},Deedle.Series{``0,System.Double})">
<summary>
 Apply transformation on series elements. The projection function `proj` always
 returns `float`, but may return `nan` to indicate that the value is not available.
 The resulting sequence should have the same number of values as the input sequence
</summary>
</member>
<member name="T:Deedle.VectorHelpers.mapFrameRowVector">
<summary>
 Helper object called by createTypedVector via reflection
</summary>
</member>
<member name="M:Deedle.VectorHelpers.TryValuesHelper.TryValues``1(Deedle.IVector{Deedle.TryValue{``0}})">
<summary>
 Turns IVector&lt;TryValue&lt;&apos;T&gt;&gt; into TryValue&lt;IVector&lt;&apos;T&gt;&gt; by aggregating all exceptions
 (used via reflection by the `tryValues` function below)
</summary>
</member>
<member name="T:Deedle.VectorHelpers.TryValuesHelper">
<summary>
 Helper type that is used via reflection
</summary>
</member>
<member name="T:Deedle.VectorHelpers.RowReaderVector`1">
<summary>
 A virtual vector for reading &quot;row&quot; of a data frame. The virtual vector accesses
 internal representation of the frame (specified by `data` and `columnCount`).
 The type is generic and automatically converts the values from the underlying
 (untyped) vector to the specified type.
</summary>
</member>
<member name="P:Deedle.VectorHelpers.NaryTransform.AtMostOne">
<summary>
 A generic transformation that works when at most one value is defined
</summary>
</member>
<member name="M:Deedle.VectorHelpers.NaryTransform.Create``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Deedle.OptionalValue{``0}},Deedle.OptionalValue{``0}})">
<summary>
 Creates a transformation that applies the specified function on `&apos;T` values list
</summary>
</member>
<member name="P:Deedle.VectorHelpers.BinaryTransform.RightIfAvailable">
<summary>
 A generic transformation that prefers the left value (if it is not missing)
</summary>
</member>
<member name="P:Deedle.VectorHelpers.BinaryTransform.LeftIfAvailable">
<summary>
 A generic transformation that prefers the left value (if it is not missing)
</summary>
</member>
<member name="P:Deedle.VectorHelpers.BinaryTransform.AtMostOne">
<summary>
 A generic transformation that works when at most one value is defined
</summary>
</member>
<member name="M:Deedle.VectorHelpers.BinaryTransform.CreateLifted``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}})">
<summary>
 Creates a transformation that applies the specified function on `&apos;T` values 
</summary>
</member>
<member name="M:Deedle.VectorHelpers.BinaryTransform.Create``1(Microsoft.FSharp.Core.FSharpFunc{Deedle.OptionalValue{``0},Microsoft.FSharp.Core.FSharpFunc{Deedle.OptionalValue{``0},Deedle.OptionalValue{``0}}})">
<summary>
 Creates a transformation that applies the specified function on `&apos;T` values 
</summary>
</member>
<member name="T:Deedle.VectorHelpers.BinaryTransform">
<summary>
 A type that implements common vector value transformations and 
 a helper method for creating transformation on values of known types
</summary>
</member>
<member name="T:Deedle.VectorHelpers.ValueCallSite`1">
<summary>
 Represents a generic function `\forall.&apos;T.(&apos;T -&gt; &apos;R)`. The function can be 
 generically invoked on an argument of type `obj` using `createValueDispatcher`
</summary>
</member>
<member name="T:Deedle.VectorHelpers.IWrappedVector`1">
<summary>
 Used to mark vectors that are just light-weight wrappers over some computation
 When vector builders perform operations on those, they might want to use the
 fully evaluated unwrapped value so that they can e.g. check for 
 interface implementations
</summary>
</member>
<member name="T:Deedle.VectorHelpers.IBoxedVector">
<summary>
 Represents a vector containing objects, that has been created by &quot;boxing&quot; a vector
 containing values of any (likely more specific type). Given a boxed vector, we can 
 get the original vector containing original values via the &apos;UnboxedVector&apos; property
</summary>
</member>
<member name="M:Deedle.VectorHelpers.|CombinedRelocations|_|(Deedle.Vectors.VectorConstruction)">
<summary>
 Matches when the vector command represents a combination
 of N relocated vectors (that is Combine [Relocate ..; Relocate ..; ...])
</summary>
</member>
<member name="M:Deedle.VectorHelpers.substitute(System.Int32,Deedle.Vectors.VectorConstruction)">
<summary>
 Substitute variable hole for another in a vector construction
</summary>
</member>
<member name="M:Deedle.VectorHelpers.createTypedRowReader``1(Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Core.FSharpFunc{System.String,System.Int64},System.Int64,Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Int64},Deedle.IVector{Deedle.IVector})">
<summary>
 Creates a typed vector of `IVector&lt;&apos;TRow&gt;` for a given interface `&apos;TRow`
 (which is expected to have only read-only properties). 
</summary>
</member>
<member name="M:Deedle.VectorHelpers.createTypedRowCreator``1(Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Uses Reflection.Emit to create an efficient implementation of the `&apos;TRow` interface.
</summary>
</member>
<member name="P:Deedle.VectorHelpers.createdTypedRowsCache">
<summary>
 Cache for optimizing &apos;createTypedRowBuilder&apos; 
</summary>
</member>
<member name="P:Deedle.VectorHelpers.typeCounter">
<summary>
 Counter of generated types to avoid name clashes
</summary>
</member>
<member name="P:Deedle.VectorHelpers.typedRowModule">
<summary>
 Dynamic assembly &amp; module for storing generated types
</summary>
</member>
<member name="M:Deedle.VectorHelpers.mapFrameRowVector``1(System.Func{Deedle.IVector[],System.Int64,``0},System.Int64,Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Int64},Deedle.IVector[])">
<summary>
 Creates a vector of typed rows `IVector&lt;&apos;TRow&gt;` from frame data `IVector&lt;IVector&gt;`.
 The returned vector uses the specified delegate `ctor` to construct `&apos;TRow` values.
 (the `ctor` function takes data and address of the row to be wrapped)
</summary>
</member>
<member name="M:Deedle.VectorHelpers.createInferredTypeVector(Deedle.Vectors.IVectorBuilder,System.Object[])">
<summary>
 Given object array, create a typed vector of the best possible type
</summary>
</member>
<member name="M:Deedle.VectorHelpers.findCommonSupertype``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Find common super type of the specified .NET types
 (This also allows implicit conversions between primitive values, so casting values
 to the common super type would fail, but Convert.changeType will work fine)
</summary>
</member>
<member name="M:Deedle.VectorHelpers.createTypedVector(Deedle.Vectors.IVectorBuilder,System.Type,System.Object[])">
<summary>
 Given object array, create a typed vector of the best possible type
</summary>
</member>
<member name="M:Deedle.VectorHelpers.toArray2D``1(System.Int32,System.Int32,Deedle.IVector{Deedle.IVector},System.Lazy{``0})">
<summary>
 Return data from a (column-major) vector of vectors as 2D array of a specified type
 If value is missing, `defaultValue` is used (which may throw an exception)
</summary>
</member>
<member name="M:Deedle.VectorHelpers.tryValues(Deedle.IVector)">
<summary>
 Given an IVector, check if the vector contains `&apos;T tryval` values and if it does,
 turn that into a vector of just `&apos;T` values, or return aggregated exception
</summary>
</member>
<member name="M:Deedle.VectorHelpers.createObjRowReader(Deedle.IVector{Deedle.IVector},Deedle.Vectors.IVectorBuilder,System.Int64,Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Int64})">
<summary>
 The same as `createRowReader`, but returns `obj` vector as the result
</summary>
</member>
<member name="M:Deedle.VectorHelpers.createRowReader``1(Deedle.IVector{Deedle.IVector},Deedle.Vectors.IVectorBuilder,System.Int64,Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Int64})">
<summary>
 Creates a virtual vector for reading &quot;row&quot; of a data frame. 
</summary>
</member>
<member name="M:Deedle.VectorHelpers.|AsFloatVector|_|(Deedle.IVector)">
<summary>
 Active pattern that calls the `tryChangeType&lt;float&gt;` function
</summary>
</member>
<member name="M:Deedle.VectorHelpers.unboxVector(Deedle.IVector)">
<summary>
 Given a vector, check whether it is `IBoxedVector` and if so, return the 
 underlying unboxed vector (see `IBoxedVector` for more information)
</summary>
</member>
<member name="M:Deedle.VectorHelpers.VectorListTransform.GetFunction``1(Deedle.Vectors.VectorListTransform)">
<summary>
 Returns a function that can aggregate a list of values. This is either the
 original N-ary reduce function or binary function extended using List.reduce
</summary>
</member>
<member name="M:Deedle.VectorHelpers.createValueDispatcher``1(Deedle.VectorHelpers.ValueCallSite{``0})">
<summary>
 Creates a function `obj -&gt; &apos;R` that dynamically invokes to 
 a generic `Invoke` method of the provided `ValueCallSite&lt;&apos;R&gt;`
</summary>
</member>
<member name="P:Deedle.VectorHelpers.stringCode">
<summary>
 Type code of the `string` type for efficient type equality test
</summary>
</member>
<member name="P:Deedle.VectorHelpers.intCode">
<summary>
 Type code of the `int` type for efficient type equality test
</summary>
</member>
<member name="P:Deedle.VectorHelpers.doubleCode">
<summary>
 Type code of the `float` type for efficient type equality test
</summary>
</member>
<member name="M:Deedle.VectorHelpers.lazyMapVector``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.IVector{``0})">
<summary>
 Creates a vector that lazily applies the specified projection `f` on 
 the values of the source `vector`. In general, Deedle does not secretly delay
 computations, so this should be used with care. Currently, we only use this
 to avoid allocations in `df.Rows`.
</summary>
</member>
<member name="M:Deedle.VectorHelpers.createBoxedVector``1(Deedle.IVector{``0})">
<summary>
 Creates a boxed vector - returns IBoxedVector that delegates all functionality to 
 the vector specified as an argument and boxes all values on the fly
</summary>
</member>
<member name="M:Deedle.VectorHelpers.prettyPrintVector``1(Deedle.IVector{``0})">
<summary>
 Pretty printer for vectors. This uses the &apos;Data&apos; property
</summary>
</member>
<member name="T:Deedle.VectorHelpers.Reflection">
<summary>
 Helper module with various MemberInfo and similar values
</summary>
</member>
<member name="M:Deedle.VectorHelpers.Inference.commonSupertype(System.Type,System.Type)">
<summary>
 Given two types, find their common supertype
</summary>
</member>
<member name="P:Deedle.VectorHelpers.Inference.Top">
<summary>
 System.Type representing top
</summary>
</member>
<member name="P:Deedle.VectorHelpers.Inference.Bottom">
<summary>
 System.Type representing bottom
</summary>
</member>
<member name="M:Deedle.VectorHelpers.Inference.|Top|_|(System.Type)">
<summary>
 Classsify type as one of the supported primitives
</summary>
</member>
<member name="T:Deedle.VectorHelpers.Inference">
<summary>
 Helper functions and active patterns for type inference
</summary>
</member>
<member name="M:Deedle.VectorHelpers.RangeRestriction.ofSeq(System.Int64,System.Collections.Generic.IEnumerable{System.Int64})">
<summary>
 Creates a `Custom` range from a sequence of indices
</summary>
</member>
<member name="T:Deedle.VectorHelpers">
<summary>
 A module with various utilities for working with vectors. 
</summary>
</member>
<member name="P:Deedle.Vectors.IBinaryTransform.IsMissingUnit">
<summary>
 Assuming `*` is the result of `GetFunction`, this property returns true when 
 for all `x` it is the case that `Missing * x = x = x * Missing`. This enables
 certain optimizations (as we do not have to call `*` when one argument is N/A)
</summary>
</member>
<member name="M:Deedle.Vectors.IBinaryTransform.GetFunction``1">
<summary>
 Returns a function that combines two values stored in vectors into a new vector value.
 Although generic, this function will only be called with the `T` set to the
 type of vector that is being built. Since `VectorConstruction` is not generic,
 the type cannot be statically propagated.
</summary>
</member>
<member name="T:Deedle.Vectors.IBinaryTransform">
<summary>
 Represent a transformation that is applied when combining two vectors (because 
 we are combining untyped `IVector` values, the transformation is also untyped)
</summary>
</member>
<member name="M:Deedle.Vectors.INaryTransform.GetFunction``1">
<summary>
 Returns a function that combines N values stored in vectors into a new vector value
</summary>
</member>
<member name="T:Deedle.Vectors.INaryTransform">
<summary>
 Represent a tranformation that is applied when combining N vectors
 (This follows exactly the same pattern as `IBinaryTransform`)
</summary>
</member>
<member name="T:Deedle.Vectors.IRowReaderTransform">
<summary>
 When an `INaryTransform` implements this interface, it is a special well-known
 transformation that creates a _row reader_ vector to be used in `frame.Rows`.
 (See the implementation in the `Build` operation in `ArrayVector.fs`)
</summary>
</member>
<member name="M:Deedle.Vectors.IVectorBuilder.CreateMissing``1(Deedle.OptionalValue{``0}[])">
<summary>
 Create a vector from an array containing values that may be missing. 
 Even if a value is passed, it may be a missing value such as `Double.NaN`
 or `null`. The vector builder should hanlde this.
</summary>
</member>
<member name="M:Deedle.Vectors.IVectorBuilder.Create``1(``0[])">
<summary>
 Create a vector from an array containing values. The values may 
 still represent missing values and the vector should handle this.
 For example `Double.NaN` or `null` should be turned into a missing
 value in the returned vector.
</summary>
</member>
<member name="M:Deedle.Vectors.IVectorBuilder.Build``1(Deedle.Addressing.IAddressingScheme,Deedle.Vectors.VectorConstruction,Deedle.IVector{``0}[])">
<summary>
 Apply a vector construction to a given vector. The second parameter
 is an array of arguments (&quot;variables&quot;) that may be referenced from the
 `VectorConstruction` using the `Return 0` construct.
</summary>
</member>
<member name="M:Deedle.Vectors.IVectorBuilder.AsyncBuild``1(Deedle.Addressing.IAddressingScheme,Deedle.Vectors.VectorConstruction,Deedle.IVector{``0}[])">
<summary>
 Asynchronous version of `Build` operation. This is mainly used for 
 `AsyncMaterialize` and it does not handle fully general vector constructions (yet)
</summary>
</member>
<member name="T:Deedle.Vectors.IVectorBuilder">
<summary>
 Represents an object that can construct vector values by processing 
 the &quot;mini-DSL&quot; representation `VectorConstruction`.
</summary>
</member>
<member name="T:Deedle.Vectors.KnownLocation">
<summary>
 An `IVectorLocation` created from a known address and offset
 (typically used in LinearIndex/ArrayVector where both are the same)
</summary>
</member>
<member name="M:Deedle.Vectors.Vector.CreateMissing``1(System.Collections.Generic.IEnumerable{System.Nullable{``0}})">
<summary>
 Creates a vector that stores the specified data in an array.
 Values such as `null` and `Double.NaN` are turned into missing values.
</summary>
</member>
<member name="M:Deedle.Vectors.Vector.CreateMissing``1(System.Collections.Generic.IEnumerable{Deedle.OptionalValue{``0}})">
<summary>
 Creates a vector that stores the specified data in an array.
 Values such as `null` and `Double.NaN` are turned into missing values.
</summary>
</member>
<member name="M:Deedle.Vectors.Vector.Create``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a vector that stores the specified data in an array.
 Values such as `null` and `Double.NaN` are turned into missing values.
</summary>
</member>
<member name="M:Deedle.Vectors.Vector.Create``1(``0[])">
<summary>
 Creates a vector that stores the specified data in an array.
 Values such as `null` and `Double.NaN` are turned into missing values.
</summary>
</member>
<member name="T:Deedle.Vectors.Vector">
<summary>
 Type that provides access to creating vectors (represented as arrays)
</summary>
</member>
<member name="T:Deedle.Vectors.VectorConstruction.AsyncCustomCommand">
<summary>
 Same as `CustomCommand` with the difference that the resulting vector is returned
 asynchronously (this is useful for lazy loading and it is used by `AsyncBuild`).
</summary>
</member>
<member name="T:Deedle.Vectors.VectorConstruction.CustomCommand">
<summary>
 Apply a custom command to a vector - this can be used by special indices (e.g. index
 for a lazy vector) to provide a custom operations to be used. The first parameter
 is a list of sub-vectors to be combined (if as in e.g. `Append`) and the
 second argument is a function that will be called with evaluated vectors and is
 supposed to create the new vector.
</summary>
</member>
<member name="T:Deedle.Vectors.VectorConstruction.FillMissing">
<summary>
 Create a vector that has missing values filled using the specified direction
 (forward means that n-th value will contain (n-i)-th value where (n-i) is the
 first index that contains a value).
</summary>
</member>
<member name="T:Deedle.Vectors.VectorConstruction.Combine">
<summary>
 Combine N aligned vectors. The `IVectorValueListTransform` object
 specifies how to merge values (in case there is a value at a given address
 in more than one of the vectors).
</summary>
</member>
<member name="T:Deedle.Vectors.VectorConstruction.Append">
<summary>
 Append two vectors after each other
</summary>
</member>
<member name="T:Deedle.Vectors.VectorConstruction.GetRange">
<summary>
 Get the specified range of addresses from the vector and return it as a new vector
</summary>
</member>
<member name="T:Deedle.Vectors.VectorConstruction.DropRange">
<summary>
 Drop the specified range of addresses from the vector 
 and return a new vector that excludes the range
</summary>
</member>
<member name="T:Deedle.Vectors.VectorConstruction.Relocate">
<summary>
 Reorders elements of the vector. Carries a new required vector length and a list
 of relocations (each pair of addresses specifies that an element at a new address 
 should be filled with an element from an old address). The addresses may be out of 
 range!
</summary>
</member>
<member name="T:Deedle.Vectors.VectorConstruction.Empty">
<summary>
 Creates an empty vector of the requested type and size
 The returned vector is filled with missing values.
</summary>
</member>
<member name="T:Deedle.Vectors.VectorConstruction.Return">
<summary>
 When constructing vectors, we get an array of vectors to be used as &quot;variables&quot;
 - this element represent getting one of the variables.
</summary>
</member>
<member name="T:Deedle.Vectors.VectorConstruction">
<summary>
 A &quot;mini-DSL&quot; that describes construction of a vector. Vector can be constructed
 from various range operations (relocate, drop, slicing, appending), by combination
 of two vectors or by taking a vector from a list of variables.

 Notably, vectors can only be constructed from other vectors of the same type 
 (the `Combine` operation requires this - even though that one could be made more general).
 This is an intentional choice to make the representation simpler.

 Logically, when we apply some index operation, we should get back a polymorphic vector
 construction (`\forall T. VectorConstruction&lt;T&gt;`) that can be applied to variuous 
 different vector types. That would mean adding some more types, so we just model vector
 construction as an untyped operation and the typing is resquired by the `Build` method
 of the vector builder.
</summary>
</member>
<member name="T:Deedle.Vectors.VectorData`1">
<summary>
 Provides a way to get the data of an arbitrary vector. This is a concrete type used 
 by functions that operate on vectors (like `Series.sum`, etc.). The vector may choose
 to return the data as `ReadOnlyCollection` (with or without N/A values) which is more
 efficient to use or as a lazy sequence (slower, but more general).
</summary>
</member>
<member name="T:Deedle.Vectors.VectorFillMissing">
<summary>
 Specifies how to fill missing values in a vector (when using the 
 `VectorConstruction.FillMissing` command). This can only fill missing
 values using strategy that does not require access to index keys - 
 either using constant or by propagating values.
</summary>
</member>
<member name="T:Deedle.Vectors.VectorHole">
<summary>
 Representes a &quot;variable&quot; in the mini-DSL below
</summary>
</member>
<member name="T:Deedle.Vectors.VectorListTransform">
<summary>
 A transformation on vector(s) can specified as binary or as N-ary. A binary transformation
 can be applied to N elements using `List.reduce`, but allows optimizations.
</summary>
</member>
<member name="T:Deedle.Vectors.ArrayVector.ArrayVector`1">
<summary>
 --------------------------------------------------------------------------------------
 Vector that stores data in an array. The data is stored using the
 `ArrayVectorData&lt;&apos;T&gt;` type (discriminated union)
</summary>
</member>
<member name="F:Deedle.Vectors.ArrayVector.ArrayVectorBuilder.vectorBuilder">
<summary>
 Instance of the vector builder
</summary>
</member>
<member name="P:Deedle.Vectors.ArrayVector.ArrayVectorBuilder.Instance">
<summary>
 Provides a global access to an instance of the `ArrayVectorBuilder`
</summary>
</member>
<member name="M:Deedle.Vectors.ArrayVector.ArrayVectorBuilder.buildArrayVector``1(Deedle.Vectors.VectorConstruction,Deedle.IVector{``0}[])">
<summary>
 Builds a vector using the specified commands, ensures that the
 returned vector is ArrayVector (if no, it converts it) and then
 returns the internal representation of the vector
</summary>
</member>
<member name="M:Deedle.Vectors.ArrayVector.ArrayVectorBuilder.Deedle-Vectors-IVectorBuilder-Build``1(Deedle.Addressing.IAddressingScheme,Deedle.Vectors.VectorConstruction,Deedle.IVector{``0}[])">
<summary>
 Given a vector construction command(s) produces a new IVector
 (the result is typically ArrayVector, but this is not guaranteed)
</summary>
</member>
<member name="M:Deedle.Vectors.ArrayVector.ArrayVectorBuilder.Deedle-Vectors-IVectorBuilder-AsyncBuild``1(Deedle.Addressing.IAddressingScheme,Deedle.Vectors.VectorConstruction,Deedle.IVector{``0}[])">
<summary>
 Asynchronous version - limited implementation for AsyncMaterialize
</summary>
</member>
<member name="T:Deedle.Vectors.ArrayVector.ArrayVectorBuilder">
<summary>
 Implements a builder object (`IVectorBuilder`) for creating
 vectors of type `ArrayVector&lt;&apos;T&gt;`. This includes operations such as
 appending, relocating values, creating vectors from arrays etc.
 The vector builder automatically switches between the two possible
 representations of the vector - when a missing value is present, it
 uses `ArrayVectorData.VectorOptional`, otherwise it uses 
 `ArrayVectorData.VectorNonOptional`.
</summary>
</member>
<member name="T:Deedle.Vectors.ArrayVector.ArrayVectorData`1">
<summary>
 Internal representation of the ArrayVector. To make this more 
 efficient, we distinguish between &quot;sparse&quot; vectors that have missing 
 values and &quot;dense&quot; vectors without N/As.
</summary>
</member>
<member name="T:Deedle.Vectors.VectorHelperExtensions.RowReaderTransform">
<summary>
 Transformation that creates a row reader. This also implements the
 `IRowReaderTransform` so that it can be replaced by a more optimial implementation
</summary>
</member>
<member name="M:Deedle.Vectors.VectorHelperExtensions.NaryTransform.RowReader.Static(Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Int64})">
<summary>
 Returns the well-known `IRowReaderTransform` transformation
</summary>
</member>
<member name="M:Deedle.Vectors.VectorHelperExtensions.rowReaderFunc(Microsoft.FSharp.Collections.FSharpList{Deedle.OptionalValue{System.Object}})">
<summary>
 Returns `OptionalValue&lt;obj&gt;` which is a boxed version of `OptionalValue&lt;IVector&lt;obj&gt;&gt;`
 (where the vector contains values from the specified list of values)
</summary>
</member>
<member name="P:Deedle.Vectors.Virtual.VirtualVectorBuilder.Instance">
<summary>
 Returns an instance of VirtualVectorBuilder  
</summary>
</member>
<member name="T:Deedle.Vectors.Virtual.VirtualVectorBuilder">
<summary>
 Implements a builder object (`IVectorBuilder`) for creating vectors of type `VirtualVector&lt;&apos;T&gt;`.
 This can do a few things without evaluating vectors (merging, slicing). For other operations
 the builder needs to materialize the vector and call `ArrayVectorBuilder`.
</summary>
</member>
<member name="P:Deedle.Vectors.Virtual.VirtualVector`1.Source">
<summary>
 Returns the wrapped source of the vector
</summary>
</member>
<member name="T:Deedle.Vectors.Virtual.VirtualVector`1">
<summary>
 Creates an `IVector&lt;&apos;T&gt;` implementation that provides operations for accessing
 data in `IVirtualVectorSource`. This mostly just calls `ValueAt` to read data.
</summary>
</member>
<member name="T:Deedle.Vectors.Virtual.DelayedLocation">
<summary>
 Represents a vector location that calculates the offset using
 address operations as needed (typically, we want to avoid this
 because it might be slow)
</summary>
</member>
<member name="P:Deedle.Vectors.Virtual.RangesAddressOperations`1.Ranges">
<summary>
 Provides access to the underlying ranges  
</summary>
</member>
<member name="T:Deedle.Vectors.Virtual.RangesAddressOperations`1">
<summary>
 In BigDeedle, we often use `Ranges&lt;&apos;T&gt;` to represent the address range obtained as a result
 of slicing and merging frames &amp; series. This implements `IAddressOperations` for `Ranges&lt;&apos;T&gt;`.

 ## Parameters
  - `ranges` - ranges containing any key that we are wrapping
  - `asAddress` - converts the key to an address
  - `ofAddress` - converts address to a key

</summary>
</member>
<member name="T:Deedle.Vectors.Virtual.VirtualAddressingScheme">
<summary>
 Represents an addressing scheme associated to virtual vectors. The addresses
 may be partitioned differently (for different data sources), so this carries
 an &quot;id&quot; of the data source (to make sure we don&apos;t try to mix mismatching data
 sources)
</summary>
</member>
<member name="M:Deedle.Vectors.Virtual.IVirtualVectorSource`1.ValueAt(Deedle.IVectorLocation)">
<summary>
 Returns the value at the specifid address. We assume that the address is in range 
 [0L, Length-1L] and that each location has a value (or has a missing value, but is valid)
</summary>
</member>
<member name="M:Deedle.Vectors.Virtual.IVirtualVectorSource`1.MergeWith(System.Collections.Generic.IEnumerable{Deedle.Vectors.Virtual.IVirtualVectorSource{`0}})">
<summary>
 Merge the current source with a list of other sources
 (used by functions such as `Frame.merge` and `Frame.mergeAll`)
</summary>
</member>
<member name="M:Deedle.Vectors.Virtual.IVirtualVectorSource`1.LookupValue(`0,Deedle.Lookup,System.Func{System.Int64,System.Boolean})">
<summary>
 Find the address associated with the specified value. This is used by the 
 index and it has the same signature as `IIndex&lt;&apos;K&gt;.Lookup` (see `Index.fs`).
</summary>
</member>
<member name="M:Deedle.Vectors.Virtual.IVirtualVectorSource`1.LookupRange(`0)">
<summary>
 Find a range (continuous or a sequence of indices) such that all values in the range are 
 the specified value. This is used, for example, when filtering frame based on column
 value (say column &quot;PClass&quot; has a value &quot;1&quot;).

 If the data source has some &quot;clever&quot; representation of the range, it can return
 `Custom of IVectorRange` - which is then passed to `GetSubVector`.
</summary>
</member>
<member name="M:Deedle.Vectors.Virtual.IVirtualVectorSource`1.GetSubVector(Deedle.RangeRestriction{System.Int64})">
<summary>
 Returns a virtual source for the specified range (used when performing splicing on the 
 frame/series, both using address or using keys - which are obtained using Lookup)
</summary>
</member>
<member name="T:Deedle.Vectors.Virtual.IVirtualVectorSource`1">
<summary>
 Represents a data source for Big Deedle. The interface is used both as a representation
 of data source for `VirtualVector` (this file) and `VirtualIndex` (another file). The 
 index uses `Length` and `ValueAt` to perform binary search when looking for a key; the
 vector simply provides an access to values using `ValueAt`. 
</summary>
</member>
<member name="P:Deedle.Vectors.Virtual.IVirtualVectorSource.Length">
<summary>
 Returns the length of the source - by design, Big Deedle always 
 needs to know the length of the source (e.g. for binary search)
</summary>
</member>
<member name="P:Deedle.Vectors.Virtual.IVirtualVectorSource.ElementType">
<summary>
 Returns the type of elements - essentially typeof&lt;&apos;V&gt; for IVirtualVectorSource&lt;&apos;V&gt;
</summary>
</member>
<member name="P:Deedle.Vectors.Virtual.IVirtualVectorSource.AddressingSchemeID">
<summary>
 Identifies the addressing scheme associated with this source. This should be shared
 by all sources for which the same addresses are valid (e.g. all columns in the same table)
</summary>
</member>
<member name="P:Deedle.Vectors.Virtual.IVirtualVectorSource.AddressOperations">
<summary>
 Returns the addressing implementation associated with this vector source
</summary>
</member>
<member name="M:Deedle.Vectors.Virtual.IVirtualVectorSource.Invoke``1(Deedle.Vectors.Virtual.IVirtualVectorSourceOperation{``0})">
<summary>
 Invoke a generic operation (wrapped in an interface) 
 that takes a generic version of this type
</summary>
</member>
<member name="T:Deedle.Vectors.Virtual.IVirtualVectorSource">
<summary>
 Non-generic part of the `IVirtualVectorSource&lt;&apos;V&gt;` interface, which 
 provides some basic information about the virtualized data source
</summary>
</member>
<member name="M:Deedle.Vectors.Virtual.IVirtualVectorSourceOperation`1.Invoke``1(Deedle.Vectors.Virtual.IVirtualVectorSource{``0})">
<summary>
 Generic method that is invoked by the non-generic interface with the correct `&apos;T`
</summary>
</member>
<member name="T:Deedle.Vectors.Virtual.IVirtualVectorSourceOperation`1">
<summary>
 A helper type used by non-generic `IVirtualVectorSource` to invoke generic 
 operations that require generic `IVirtualVectorSource&lt;&apos;T&gt;` as an argument.
</summary>
</member>
<member name="T:Deedle.Vectors.Virtual.VirtualVectorSource.IMappedVectorSource`2">
<summary>
 Marks IVirtualVectorSource that has been created by mapping from source
</summary>
</member>
<member name="T:Deedle.Vectors.Virtual.VirtualVectorSource.ICombinedVectorSource`1">
<summary>
 Marks IVirtualVectorSource that has been created by combining another sources
</summary>
</member>
<member name="T:Deedle.Vectors.Virtual.VirtualVectorSource.IBoxedVectorSource`1">
<summary>
 Marks IVirtualVectorSource that has been created by boxing another source
</summary>
</member>
<member name="M:Deedle.Vectors.Virtual.VirtualVectorSource.createRowReader``1(Microsoft.FSharp.Core.FSharpFunc{Deedle.Vectors.Virtual.IVirtualVectorSource{``0},Deedle.IVector},Deedle.Vectors.IVectorBuilder,Deedle.Vectors.IRowReaderTransform,Deedle.IVector{Deedle.IVector},Microsoft.FSharp.Collections.FSharpList{Deedle.Vectors.Virtual.IVirtualVectorSource{``0}})">
<summary>
 Creates a &quot;row reader vector&quot; - that is a vector that provides source for the series
 returned by frame.Rows. This is combined from a number of sources, but we do not
 fully materialize anything to create the vector. The first parameter is a ctor
 for `VirtualVector` which is defined below in the file.
</summary>
</member>
<member name="M:Deedle.Vectors.Virtual.VirtualVectorSource.map``2(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{Deedle.IVectorLocation,Microsoft.FSharp.Core.FSharpFunc{Deedle.OptionalValue{``1},Deedle.OptionalValue{``0}}},Deedle.Vectors.Virtual.IVirtualVectorSource{``1})">
<summary>
 Creates a new vector that transforms source values using a given function
 The result also implements IMappedVectorSource
</summary>
</member>
<member name="M:Deedle.Vectors.Virtual.VirtualVectorSource.combine``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Deedle.OptionalValue{``0}},Deedle.OptionalValue{``1}},Microsoft.FSharp.Collections.FSharpList{Deedle.Vectors.Virtual.IVirtualVectorSource{``0}})">
<summary>
 Creates a new vector that combines (zips) vectors using a given function
 The result also implements ICombinedVectorSource
</summary>
</member>
<member name="M:Deedle.Vectors.Virtual.VirtualVectorSource.boxSource``1(Deedle.Vectors.Virtual.IVirtualVectorSource{``0})">
<summary>
 Creates a new vector source that boxes all values
 The result also implements IBoxedVectorSource
</summary>
</member>
<member name="T:Deedle.Vectors.Virtual.VirtualVectorSource">
<summary>
 Module that implements various helper operations over `IVirtualVectorSource` type
</summary>
</member>
<member name="M:Deedle.Virtual.Virtual.CreateSeries``2(Deedle.Vectors.Virtual.IVirtualVectorSource{``0},Deedle.Vectors.Virtual.IVirtualVectorSource{``1})">
<summary>
 Create a virtual series with an index and values specified by two `IVirtualVectorSource` values.
 The index source should support lookup (which is used for series lookup, slicing etc.)
 The value source does not need to implement lookup - mainly `ValueAt`, merging and getting sub-source
</summary>
</member>
<member name="M:Deedle.Virtual.Virtual.CreateOrdinalSeries``1(Deedle.Vectors.Virtual.IVirtualVectorSource{``0})">
<summary>
 Creates a virtual series with ordinal index. The parameter is `IVirtualVectorSource`
 that specifies how to access values in the series (and is also used to determine the size
 of the series index)
</summary>
</member>
<member name="M:Deedle.Virtual.Virtual.CreateOrdinalFrame``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{Deedle.Vectors.Virtual.IVirtualVectorSource})">
<summary>
 Create a frame with ordinal index, containing the specified sources as columns.
</summary>
</member>
<member name="M:Deedle.Virtual.Virtual.CreateFrame``2(Deedle.Vectors.Virtual.IVirtualVectorSource{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{Deedle.Vectors.Virtual.IVirtualVectorSource})">
<summary>
 Create a frame with ordinal index, containing the specified sources as columns.
 The index source should support lookup (which is used for series lookup, slicing etc.)
 The value source does not need to implement lookup - mainly `ValueAt`, merging and getting sub-source
</summary>
</member>
<member name="T:Deedle.Virtual.Virtual">
<summary>
 Provides static methods for creating virtual series and virtual frames.
 Those provide necessary wrapping around `IVirtualVectorSource` values
</summary>
</member>
<member name="T:Deedle.Virtual.VirtualVectorHelper">
<summary>
 [omit]

 Helper that is invoked via Reflection to create generic virtual vectors.
</summary>
</member>
<member name="M:Deedle.Virtual.IndexUtils.BinarySearch(System.Int64,System.Func{System.Int64,System.Int64},System.Int64,Deedle.Lookup,System.Func{System.Int64,System.Boolean})">
<summary>
 See the comment for `IndexUtilsModule.binarySearch`
</summary>
</member>
<member name="T:Deedle.Virtual.IndexUtils">
<summary>
 Helpers that can be used when implementing Lookup
</summary>
</member>
<member name="M:Deedle.Virtual.IndexUtilsModule.binarySearch``1(System.Int64,System.Func{System.Int64,``0},``0,Deedle.Lookup,System.Func{System.Int64,System.Boolean})">
<summary>
 Binary search in range [ 0L .. count ]. The function is generic in ^T and 
 is &apos;inline&apos; so that the comparison on ^T is optimized.

  - `count` specifies the upper bound for the binary search
  - `valueAt` is a function that returns value ^T at the specified location
  - `value` is the ^T value that we are looking for
  - `lookup` is the lookup semantics as used in Deedle
  - `check` is a function that tests whether we want a given location
    (if no, we scan - this can be used to find the first available value in a series)

</summary>
</member>
</members>
</doc>
