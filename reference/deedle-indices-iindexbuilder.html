<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>IIndexBuilder - Deedle</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="BlueMountain Capital">

    <script src="http://code.jquery.com/jquery-1.8.0.js"></script>
    <script src="http://code.jquery.com/ui/1.8.23/jquery-ui.js"></script>
    <script src="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <link href="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet">

    <link type="text/css" rel="stylesheet" href="http://bluemountaincapital.github.io/Deedle/content/style.css" />
    <script type="text/javascript" src="http://bluemountaincapital.github.io/Deedle/content/tips.js"></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="masthead">
        <ul class="nav nav-pills pull-right">
          <li><a href="http://fsharp.org">fsharp.org</a></li>
          <li><a href="http://github.com/BlueMountainCapital/Deedle">github page</a></li>
          <li><a href="http://fsharp.github.io/FSharp.Charting/">F# Charting</a></li>
          <li><a href="http://bluemountaincapital.github.io/FSharpRProvider">R Type Provider</a></li>
          <li><a href="http://fsharp.github.io/FSharp.Data/">F# Data</a></li>
        </ul>
        <h3 class="muted">Deedle</h3>
      </div>
      <hr />
      <div class="row">
        <div class="span9" id="main">
          



<h1>IIndexBuilder</h1>
<div class="xmldoc">
<p>A builder represents various ways of constructing index, either from keys or from
other indices. The operations that build a new index from an existing index also 
build <code>VectorConstruction</code> which specifies how to transform vectors aligned with the
previous index to match the new index. The methods generally take <code>VectorConstruction</code>
as an input, apply necessary transformations to it and return a new <code>VectorConstruction</code>.</p>
        <h2>Example</h2>
<p>For example, given <code>index</code>, we can say:</p>

<pre><code>// Create an index that excludes the value 42
let newIndex, vectorCmd = indexBuilder.DropItem(index, 42, VectorConstruction.Return(0))

// Now we can transform multiple vectors (e.g. all frame columns) using 'vectorCmd'
// (the integer '0' in `Return` is an offset in the array of vector arguments)
let newVector = vectorBuilder.Build(vectorCmd, [| vectorToTransform |])
</code></pre>
</div>
  <h3>Instance members</h3>
  <table class="table table-bordered member-list">
    <thead>
      <tr><td>Instance member</td><td>Description</td></tr>
    </thead>
    <tbody>
      <tr>
        <td class="member-name">

          <code onmouseout="hideTip(event, '320', 320)" onmouseover="showTip(event, '320', 320)">
            iIndexBuilder.Aggregate(...)
          </code>
          <div class="tip" id="320">
            <strong>Signature:</strong>(index:IIndex&lt;&#39;K&gt; * aggregation:Aggregation&lt;&#39;K&gt; * source:VectorConstruction * valueSelector:(DataSegmentKind * SeriesConstruction&lt;&#39;K&gt; -&gt; OptionalValue&lt;&#39;R&gt;) * keySelector:(DataSegmentKind * SeriesConstruction&lt;&#39;K&gt; -&gt; &#39;TNewKey)) -&gt; IIndex&lt;&#39;TNewKey&gt; * IVector&lt;&#39;R&gt;<br />
              <strong>Modifiers:</strong> abstract<br />
                          <strong>Type parameters:</strong> 'K, 'R, 'TNewKey          </div>
        </td>
        <td class="xmldoc"><p>Aggregate an ordered index into floating windows or chunks.</p>

<h2>Parameters</h2>

<ul>
<li><code>index</code> - Specifies the index to be aggregated</li>
<li><code>aggregation</code> - Defines the kind of aggregation to apply (the type 
is a discriminated union with a couple of cases)</li>
<li><code>source</code> - Source vector construction to be transformed</li>
<li><code>valueSelector</code> - Given information about window/chunk (including 
vector construction that can be used to build the data chunk), return
a new value for the returned vector.</li>
<li><code>keySelector</code> - Given information about window/chunk (including 
vector construction that can be used to build the data chunk), return a key of the chunk/window.</li>
</ul>
</td>
      </tr>
      <tr>
        <td class="member-name">

          <code onmouseout="hideTip(event, '339', 339)" onmouseover="showTip(event, '339', 339)">
            iIndexBuilder.Append(arg1, arg2, arg3)
          </code>
          <div class="tip" id="339">
            <strong>Signature:</strong>(SeriesConstruction&lt;&#39;K&gt; * SeriesConstruction&lt;&#39;K&gt; * IVectorValueTransform) -&gt; IIndex&lt;&#39;K&gt; * VectorConstruction<br />
              <strong>Modifiers:</strong> abstract<br />
                          <strong>Type parameters:</strong> 'K          </div>
        </td>
        <td class="xmldoc"><p>Append two indices and builds corresponding vector transformations
for both vectors that match the left and the right index. If the indices
are ordered, the ordering should be preserved (the keys should be aligned).
The specified <code>IVectorValueTransform</code> defines how to deal with the case when
a key is defined in both indices (i.e. which value should be in the new vector).</p>
</td>
      </tr>
      <tr>
        <td class="member-name">

          <code onmouseout="hideTip(event, '340', 340)" onmouseover="showTip(event, '340', 340)">
            iIndexBuilder.AsyncMaterialize(arg1)
          </code>
          <div class="tip" id="340">
            <strong>Signature:</strong>SeriesConstruction&lt;&#39;K&gt; -&gt; AsyncSeriesConstruction&lt;&#39;K&gt;<br />
              <strong>Modifiers:</strong> abstract<br />
                          <strong>Type parameters:</strong> 'K          </div>
        </td>
        <td class="xmldoc"><p>Given an index and vector construction, return a new index asynchronously
to allow composing evaluation of lazy series. The command to be applied to
vectors can be applied asynchronously using <code>vectorBuilder.AsyncBuild</code></p>
</td>
      </tr>
      <tr>
        <td class="member-name">

          <code onmouseout="hideTip(event, '341', 341)" onmouseover="showTip(event, '341', 341)">
            iIndexBuilder.Create(arg1, arg2)
          </code>
          <div class="tip" id="341">
            <strong>Signature:</strong>(seq&lt;&#39;K&gt; * Option&lt;bool&gt;) -&gt; IIndex&lt;&#39;K&gt;<br />
              <strong>Modifiers:</strong> abstract<br />
                          <strong>Type parameters:</strong> 'K          </div>
        </td>
        <td class="xmldoc"><p>Create a new index using the specified keys. Optionally, the caller can specify
if the index keys are ordered or not. When the value is not set, the construction
should check and infer this from the data.</p>
</td>
      </tr>
      <tr>
        <td class="member-name">

          <code onmouseout="hideTip(event, '342', 342)" onmouseover="showTip(event, '342', 342)">
            iIndexBuilder.DropItem(arg1, arg2)
          </code>
          <div class="tip" id="342">
            <strong>Signature:</strong>(SeriesConstruction&lt;&#39;K&gt; * &#39;K) -&gt; SeriesConstruction&lt;&#39;K&gt;<br />
              <strong>Modifiers:</strong> abstract<br />
                          <strong>Type parameters:</strong> 'K          </div>
        </td>
        <td class="xmldoc"><p>Drop an item associated with the specified key from the index.</p>
</td>
      </tr>
      <tr>
        <td class="member-name">

          <code onmouseout="hideTip(event, '343', 343)" onmouseover="showTip(event, '343', 343)">
            iIndexBuilder.GetRange(...)
          </code>
          <div class="tip" id="343">
            <strong>Signature:</strong>(IIndex&lt;&#39;K&gt; * (&#39;K * BoundaryBehavior) option * (&#39;K * BoundaryBehavior) option * VectorConstruction) -&gt; SeriesConstruction&lt;&#39;K&gt;<br />
              <strong>Modifiers:</strong> abstract<br />
                          <strong>Type parameters:</strong> 'K          </div>
        </td>
        <td class="xmldoc"><p>Create a new index that represents sub-range of an existing index. The range is specified
as a pair of options (when <code>None</code>, the original left/right boundary should be used) 
that contain boundary behavior and the boundary key.</p>
</td>
      </tr>
      <tr>
        <td class="member-name">

          <code onmouseout="hideTip(event, '344', 344)" onmouseover="showTip(event, '344', 344)">
            iIndexBuilder.GroupBy(...)
          </code>
          <div class="tip" id="344">
            <strong>Signature:</strong>(IIndex&lt;&#39;K&gt; * keySelector:(&#39;K -&gt; OptionalValue&lt;&#39;TNewKey&gt;) * VectorConstruction * valueSelector:(&#39;TNewKey * SeriesConstruction&lt;&#39;K&gt; -&gt; OptionalValue&lt;&#39;R&gt;)) -&gt; IIndex&lt;&#39;TNewKey&gt; * IVector&lt;&#39;R&gt;<br />
              <strong>Modifiers:</strong> abstract<br />
                          <strong>Type parameters:</strong> 'K, 'TNewKey, 'R          </div>
        </td>
        <td class="xmldoc"><p>Group a (possibly unordered) index using the specified <code>keySelector</code> function.
The operation builds a new index with the selected keys and a matching vector
with values produced by the <code>valueSelector</code> function.</p>
</td>
      </tr>
      <tr>
        <td class="member-name">

          <code onmouseout="hideTip(event, '345', 345)" onmouseover="showTip(event, '345', 345)">
            iIndexBuilder.Intersect(arg1, arg2)
          </code>
          <div class="tip" id="345">
            <strong>Signature:</strong>(SeriesConstruction&lt;&#39;K&gt; * SeriesConstruction&lt;&#39;K&gt;) -&gt; IIndex&lt;&#39;K&gt; * VectorConstruction * VectorConstruction<br />
              <strong>Modifiers:</strong> abstract<br />
                          <strong>Type parameters:</strong> 'K          </div>
        </td>
        <td class="xmldoc"><p>Creates an interesection of two indices and builds corresponding vector transformations
for both vectors that match the left and the right index.</p>
</td>
      </tr>
      <tr>
        <td class="member-name">

          <code onmouseout="hideTip(event, '346', 346)" onmouseover="showTip(event, '346', 346)">
            iIndexBuilder.LookupLevel(arg1, arg2)
          </code>
          <div class="tip" id="346">
            <strong>Signature:</strong>(SeriesConstruction&lt;&#39;K&gt; * ICustomLookup&lt;&#39;K&gt;) -&gt; SeriesConstruction&lt;&#39;K&gt;<br />
              <strong>Modifiers:</strong> abstract<br />
                          <strong>Type parameters:</strong> 'K          </div>
        </td>
        <td class="xmldoc"><p>Get items associated with the specified key from the index. This method takes
<code>ICustomLookup&lt;K&gt;</code> which provides an implementation of <code>ICustomKey&lt;K&gt;</code>. This 
is used for custom equality testing (for example, when getting a level of a hierarchical index)</p>
</td>
      </tr>
      <tr>
        <td class="member-name">

          <code onmouseout="hideTip(event, '347', 347)" onmouseover="showTip(event, '347', 347)">
            iIndexBuilder.OrderIndex(arg1)
          </code>
          <div class="tip" id="347">
            <strong>Signature:</strong>SeriesConstruction&lt;&#39;K&gt; -&gt; SeriesConstruction&lt;&#39;K&gt;<br />
              <strong>Modifiers:</strong> abstract<br />
                          <strong>Type parameters:</strong> 'K          </div>
        </td>
        <td class="xmldoc"><p>Order (possibly unordered) index and return transformation that reorders vector</p>
</td>
      </tr>
      <tr>
        <td class="member-name">

          <code onmouseout="hideTip(event, '348', 348)" onmouseover="showTip(event, '348', 348)">
            iIndexBuilder.Project(arg1)
          </code>
          <div class="tip" id="348">
            <strong>Signature:</strong>IIndex&lt;&#39;K&gt; -&gt; IIndex&lt;&#39;K&gt;<br />
              <strong>Modifiers:</strong> abstract<br />
                          <strong>Type parameters:</strong> 'K          </div>
        </td>
        <td class="xmldoc"><p>When we perform some projection on the vector (e.g. <code>Series.map</code>), then we may also
need to perform some transformation on the index (because it will typically turn delayed
index into an evaluated index). This operation represents that - it should return 
(evaluated) index with the same keys.</p>
</td>
      </tr>
      <tr>
        <td class="member-name">

          <code onmouseout="hideTip(event, '349', 349)" onmouseover="showTip(event, '349', 349)">
            iIndexBuilder.Reindex(...)
          </code>
          <div class="tip" id="349">
            <strong>Signature:</strong>(IIndex&lt;&#39;K&gt; * IIndex&lt;&#39;K&gt; * Lookup * VectorConstruction * (Address -&gt; bool)) -&gt; VectorConstruction<br />
              <strong>Modifiers:</strong> abstract<br />
                          <strong>Type parameters:</strong> 'K          </div>
        </td>
        <td class="xmldoc"><p>Given an old index and a new index, build a vector transformation that reorders
elements from a vector associated with the old index so that they match the new
index. When finding element location in the new index, the provided <code>Lookup</code> strategy
is used. This is used, for example, when doing left/right join (to align the new data
with another index) or when selecting multiple keys (<code>Series.lookupAll</code>).</p>

<p>The proivded <code>condition</code> is used when searching for a value in the old index
(when lookup is not exact). It is called to check that the address contains an
appropriate value (e.g. when we need to skip over missing values).</p>
</td>
      </tr>
      <tr>
        <td class="member-name">

          <code onmouseout="hideTip(event, '350', 350)" onmouseover="showTip(event, '350', 350)">
            iIndexBuilder.Resample(...)
          </code>
          <div class="tip" id="350">
            <strong>Signature:</strong>(IIndex&lt;&#39;K&gt; * seq&lt;&#39;K&gt; * Direction * source:VectorConstruction * valueSelector:(&#39;TNewKey * SeriesConstruction&lt;&#39;K&gt; -&gt; OptionalValue&lt;&#39;R&gt;) * keySelector:(&#39;K * SeriesConstruction&lt;&#39;K&gt; -&gt; &#39;TNewKey)) -&gt; IIndex&lt;&#39;TNewKey&gt; * IVector&lt;&#39;R&gt;<br />
              <strong>Modifiers:</strong> abstract<br />
                          <strong>Type parameters:</strong> 'K, 'TNewKey, 'R          </div>
        </td>
        <td class="xmldoc"><p>Aggregate data into non-overlapping chunks by aligning them to the
specified keys. The second parameter specifies the direction. If it is
<code>Direction.Forward</code> than the key is the first element of a chunk; for 
<code>Direction.Backward</code>, the key is the last element (note that this does not 
hold at the boundaries where values before/after the key may also be included)</p>
</td>
      </tr>
      <tr>
        <td class="member-name">

          <code onmouseout="hideTip(event, '351', 351)" onmouseover="showTip(event, '351', 351)">
            iIndexBuilder.Union(arg1, arg2)
          </code>
          <div class="tip" id="351">
            <strong>Signature:</strong>(SeriesConstruction&lt;&#39;K&gt; * SeriesConstruction&lt;&#39;K&gt;) -&gt; IIndex&lt;&#39;K&gt; * VectorConstruction * VectorConstruction<br />
              <strong>Modifiers:</strong> abstract<br />
                          <strong>Type parameters:</strong> 'K          </div>
        </td>
        <td class="xmldoc"><p>Creates a union of two indices and builds corresponding vector transformations
for both vectors that match the left and the right index.</p>
</td>
      </tr>
      <tr>
        <td class="member-name">

          <code onmouseout="hideTip(event, '352', 352)" onmouseover="showTip(event, '352', 352)">
            iIndexBuilder.WithIndex(...)
          </code>
          <div class="tip" id="352">
            <strong>Signature:</strong>(IIndex&lt;&#39;K&gt; * (Address -&gt; OptionalValue&lt;&#39;TNewKey&gt;) * VectorConstruction) -&gt; SeriesConstruction&lt;&#39;TNewKey&gt;<br />
              <strong>Modifiers:</strong> abstract<br />
                          <strong>Type parameters:</strong> 'K, 'TNewKey          </div>
        </td>
        <td class="xmldoc"><p>Create a new index by picking a new key value for each key in the original index
(used e.g. when we have a frame and want to use specified column as a new index).</p>
</td>
      </tr>
    </tbody>
  </table>

        </div>
        <div class="span3">
          <a href="https://nuget.org/packages/Deedle">
            <img src="http://bluemountaincapital.github.io/Deedle/images/logo.png" style="width:140px;height:140px;margin:10px 0px 0px 35px;border-style:none;" />
          </a>

          <ul class="nav nav-list" id="menu">
            <li class="nav-header">Deedle</li>
            <li><a href="http://bluemountaincapital.github.io/Deedle/index.html">Home page</a></li>
            <li class="divider"></li>
            <li><a href="https://nuget.org/packages/Deedle">Get Library via NuGet</a></li>
            <li><a href="http://github.com/BlueMountainCapital/Deedle">Source Code on GitHub</a></li>
            <li><a href="http://github.com/BlueMountainCapital/Deedle/blob/master/LICENSE.md">License (BSD)</a></li>
            <li><a href="http://github.com/BlueMountainCapital/Deedle/blob/master/RELEASE_NOTES.md">Release Notes</a></li>
            <li><a href="http://bluemountaincapital.github.io/Deedle/design.html">Design notes</a></li>
            
            <li class="nav-header">Using from F#</li>
            <li>
              <a href="http://bluemountaincapital.github.io/Deedle/tutorial.html">Quick start tutorial</a>
              <ul class="nav nav-list">
                <li><a href="http://bluemountaincapital.github.io/Deedle/tutorial.html#creating">Creating data frames</a></li>
                <li><a href="http://bluemountaincapital.github.io/Deedle/tutorial.html#reindexing-and-joins">Using index & joining</a></li>
                <li><a href="http://bluemountaincapital.github.io/Deedle/tutorial.html#selecting">Reading values, slicing</a></li>
                <li><a href="http://bluemountaincapital.github.io/Deedle/tutorial.html#timeseries">Ordered time series</a></li>
                <li><a href="http://bluemountaincapital.github.io/Deedle/tutorial.html#projections">Projection and filtering</a></li>
                <li><a href="http://bluemountaincapital.github.io/Deedle/tutorial.html#grouping">Aggregating groups</a></li>
              </ul>
            </li>
            <li>
              <a href="http://bluemountaincapital.github.io/Deedle/features.html">Data frame features</a>
              <ul class="nav nav-list">
                <li><a href="http://bluemountaincapital.github.io/Deedle/features.html#creating">Creating & loading</a></li>
                <li><a href="http://bluemountaincapital.github.io/Deedle/features.html#dataframe">Frame manipulation</a></li>
                <li><a href="http://bluemountaincapital.github.io/Deedle/features.html#slicing">Advanced slicing</a></li>
                <li><a href="http://bluemountaincapital.github.io/Deedle/features.html#grouping">Grouping data</a></li>
                <li><a href="http://bluemountaincapital.github.io/Deedle/features.html#indexing">Hierarchical indexing</a></li>
                <li><a href="http://bluemountaincapital.github.io/Deedle/features.html#missing">Missing values</a></li>
              </ul>
            </li>
            <li>
              <a href="http://bluemountaincapital.github.io/Deedle/timeseries.html">Time series features</a>
              <ul class="nav nav-list">
                <li><a href="http://bluemountaincapital.github.io/Deedle/timeseries.html#alignment">Alignment & joining</a></li>
                <li><a href="http://bluemountaincapital.github.io/Deedle/timeseries.html#windowing">Windows and chunks</a></li>
                <li><a href="http://bluemountaincapital.github.io/Deedle/timeseries.html#sampling">Lookup and resampling</a></li>
                <li><a href="http://bluemountaincapital.github.io/Deedle/timeseries.html#stats">Statistics & math</a></li>
              </ul>
            </li>

            <li class="nav-header">Documentation</li>
            <li><a href="http://bluemountaincapital.github.io/Deedle/reference/index.html">API Reference</a></li>

            <li class="nav-header">Samples</li>
            <li><a href="http://bluemountaincapital.github.io/Deedle/lazysource.html">Lazy data loading</a></li>
            <li><a href="http://bluemountaincapital.github.io/Deedle/samples/volatility.html">Price volatility</a></li>
            <li><a href="http://bluemountaincapital.github.io/Deedle/samples/titanic.html">Titanic survivors</a></li>
          </ul>
        </div>
      </div>
    </div>
    <a href="http://github.com/BlueMountainCapital/Deedle"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"></a>
  </body>
  </html>