<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Deedle</name></assembly>
<members>
<member name="M:Deedle.Aggregation.WindowWhile``1(System.Func{``0,``0,System.Boolean})">
<summary>
 Aggregate data into floating windows where each window ends as soon
 as the specified function returns `false` when called with the 
 first key and the current key as arguments.

 ## Parameters

  - `condition` - A delegate that specifies when to end the current window
    (e.g. `(k1, k2) =&gt; k2 - k1 &lt; 10` means that the difference between keys
    in each window will be less than 10.
</summary>
</member>
<member name="M:Deedle.Aggregation.WindowSize``1(System.Int32,Deedle.Boundary)">
<summary>
 Aggregate data into floating windows of a specified size 
 and the provided handling of boundary elements.

 ## Parameters

  - `size` - Specifies the size of the floating window. Depending on the
    boundary behavior, the actual created windows may be smaller.
  - `boundary` - Specifies how to handle boundaries (when there is not
    enough data to create an entire window). 
</summary>
</member>
<member name="M:Deedle.Aggregation.ChunkWhile``1(System.Func{``0,``0,System.Boolean})">
<summary>
 Aggregate data into non-overlapping chunks where each chunk ends as soon
 as the specified function returns `false` when called with the 
 first key and the current key as arguments.

 ## Parameters

  - `condition` - A delegate that specifies when to end the current chunk
    (e.g. `(k1, k2) =&gt; k2 - k1 &lt; 10` means that the difference between keys
    in each chunk will be less than 10.
</summary>
</member>
<member name="M:Deedle.Aggregation.ChunkSize``1(System.Int32,Deedle.Boundary)">
<summary>
 Aggregate data into non-overlapping chunks of a specified size 
 and the provided handling of boundary elements.

 ## Parameters

  - `size` - Specifies the size of the floating window. Depending on the
    boundary behavior, the actual created windows may be smaller.
  - `boundary` - Specifies how to handle boundaries (when there is not
    enough data to create an entire window). 
</summary>
</member>
<member name="T:Deedle.Aggregation">
<summary>
 A non-generic type that simplifies the construction of `Aggregation&lt;K&gt;` values
 from C#. It provides methods for constructing different kinds of aggregation
 strategies for ordered series.
</summary>
</member>
<member name="T:Deedle.Aggregation`1.ChunkWhile">
<summary>
 Aggregate data into non-overlapping chunks where each chunk ends as soon
 as the specified function returns `false` when called with the 
 first key and the current key as arguments.
</summary>
</member>
<member name="T:Deedle.Aggregation`1.WindowWhile">
<summary>
 Aggregate data into floating windows where each window ends as soon
 as the specified function returns `false` when called with the 
 first key and the current key as arguments.
</summary>
</member>
<member name="T:Deedle.Aggregation`1.ChunkSize">
<summary>
 Aggregate data into non-overlapping chunks of a specified size 
 and the provided handling of boundary elements.
</summary>
</member>
<member name="T:Deedle.Aggregation`1.WindowSize">
<summary>
 Aggregate data into floating windows of a specified size 
 and the provided handling of boundary elements.
</summary>
</member>
<member name="T:Deedle.Aggregation`1">
<summary>
 Represents a strategy for aggregating data in an ordered series into data segments.
 To create a value of this type from C#, use the non-generic `Aggregation` type.
 Data can be aggregate using floating windows or chunks of a specified size or 
 by specifying a condition on two keys (i.e. end a window/chunk when the condition
 no longer holds).
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.Boundary">
<summary>
 Represents boundary behaviour for operations such as floating window. The type
 specifies whether incomplete windows (of smaller than required length) should be
 produced at the beginning (`AtBeginning`) or at the end (`AtEnding`) or
 skipped (`Skip`). For chunking, combinations are allowed too - to skip incomplete
 chunk at the beginning, use `Boundary.Skip ||| Boundary.AtBeginning`.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.DataSegmentKind">
<summary>
 Represents a kind of `DataSegment&lt;T&gt;`. See that type for more information.
</summary>
</member>
<member name="">

</member>
<member name="P:Deedle.DataSegment`1.Kind">
<summary>
 Return the kind of this segment
</summary>
</member>
<member name="P:Deedle.DataSegment`1.Data">
<summary>
 Returns the data associated with the segment
 (for boundary segment, this may be smaller than the required window size)
</summary>
</member>
<member name="M:Deedle.DataSegment`1.ToString">
<summary>
 Format data segment nicely
</summary>
</member>
<member name="T:Deedle.DataSegment`1">
<summary>
 Represents a segment of a series or sequence. The value is returned from 
 various functions that aggregate data into chunks or floating windows. The 
 `Complete` case represents complete segment (e.g. of the specified size) and
 `Boundary` represents segment at the boundary (e.g. smaller than the required
 size). 

 ## Example

 For example (using internal `windowed` function):

     open Deedle.Internal

     Seq.windowedWithBounds 3 Boundary.AtBeginning [ 1; 2; 3; 4 ]
     [fsi:  [| DataSegment(Incomplete, [| 1 |])         ]
     [fsi:       DataSegment(Incomplete, [| 1; 2 |])    ]
     [fsi:       DataSegment(Complete [| 1; 2; 3 |])    ]
     [fsi:       DataSegment(Complete [| 2; 3; 4 |]) |] ]

 If you do not need to distinguish the two cases, you can use the `Data` property
 to get the array representing the segment data.
</summary>
</member>
<member name="M:Deedle.DelayedSeries.Create``2(``0,``0,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,Deedle.Indices.BoundaryBehavior},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,Deedle.Indices.BoundaryBehavior},Microsoft.FSharp.Control.FSharpAsync{System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}}}}})">
<summary>
 An F#-friendly function that creates lazily loaded series. The method requires
 the overall range of the series (smallest and greatest key) and a function that
 loads the data. The function is called with two tuples that specify lower and upper
 boundary. It returns an asynchronous workflow that produces the data.

 ## Parameters
 
  - `min` - The smallest key that should be present in the created series.
  - `min` - The greatests key that should be present in the created series.
  - `loader` - A function which returns an asynchronous workflow that loads the data in a 
    specified range. The function is called with two tuples consisting of key and 
    `BoundaryBehavior` values. The keys specify lower and upper boundary and 
    `BoundaryBehavior` values can be either `Inclusive` or `Exclusive`.

 ## Remarks

 For more information see the [lazy data loading tutorial](../lazysource.html).
</summary>
</member>
<member name="M:Deedle.DelayedSeries.Create``2(``0,``0,System.Func{``0,Deedle.Indices.BoundaryBehavior,``0,Deedle.Indices.BoundaryBehavior,System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}}}})">
<summary>
 A C#-friendly function that creates lazily loaded series. The method requires
 the overall range of the series (smallest and greatest key) and a function that
 loads the data. In this overload, the function is a `Func` delegate taking 
 information about the requested range and returning `Task&lt;T&gt;` that produces the data.

 ## Parameters
 
  - `min` - The smallest key that should be present in the created series.
  - `min` - The greatests key that should be present in the created series.
  - `loader` - A delegate which returns a task that loads the data in a specified 
    range. The delegate is called with four arguments specifying the minimal and
    maximal key and two `BoundaryBehavior` values specifying whether the low and
    high ranges are inclusive or exclusive.

 ## Remarks

 For more information see the [lazy data loading tutorial](../lazysource.html).
 The operation calls `loader` (and so creates the tasks) on the thread that is
 requesting the result.
</summary>
</member>
<member name="T:Deedle.DelayedSeries">
<summary>
 This type exposes a single static method `DelayedSeries.Create` that can be used for
 constructing data series (of type `Series&lt;K, V&gt;`) with lazily loaded data. You can
 use this functionality to create series that represents e.g. an entire price history
 in a database, but only loads data that are actually needed. For more information
 see the [lazy data loading tutorial](../lazysource.html).
 
 ### Example
 
 Assuming we have a function `generate lo hi` that generates data in the specified
 `DateTime` range, we can create lazy series as follows:

     let ls = DelayedSeries.Create(min, max, fun (lo, lob) (hi, hib) -&gt; 
       async { 
         printfn &quot;Query: %A - %A&quot; (lo, lob) (hi, hib)
         return generate lo hi })

 The arguments `min` and `max` specfify the complete range of the series. The 
 function passed to `Create` is called with minimal and maximal required key
 (`lo` and `hi`) and with two values that specify boundary behaviour.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.Direction">
<summary>
 Specifies in which direction should we look when performing operations such as
 `Series.Pairwise`. 

 ## Example

     let abc = 
       [ 1 =&gt; &quot;a&quot;; 2 =&gt; &quot;b&quot;; 3 =&gt; &quot;c&quot; ]
       |&gt; Series.ofObservations

     // Using &apos;Forward&apos; the key of the first element is used
     abc.Pairwise(direction=Direction.Forward)
     [fsi:[ 1 =&gt; (&quot;a&quot;, &quot;b&quot;); 2 =&gt; (&quot;b&quot;, &quot;c&quot;) ]]

     // Using &apos;Backward&apos; the key of the second element is used
     abc.Pairwise(direction=Direction.Backward)
     [fsi:[ 2 =&gt; (&quot;a&quot;, &quot;b&quot;); 3 =&gt; (&quot;b&quot;, &quot;c&quot;) ]]

</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.Frame.ReadCsv(System.IO.Stream,System.Nullable{System.Boolean},System.Boolean,System.Int32,System.String,System.String,System.String,System.Nullable{System.Int32})">
<summary>
 Load data frame from a CSV file. The operation automatically reads column names from the 
 CSV file (if they are present) and infers the type of values for each column. Columns
 of primitive types (`int`, `float`, etc.) are converted to the right type. Columns of other
 types (such as dates) are not converted automatically.

 ## Parameters

  * `stream` - Specifies the input stream, opened at the beginning of CSV data
  * `hasHeaders` - Specifies whether the input CSV file has header row
     (when not set, the default value is `true`)
  * `skipTypeInference` - Specifies whether the method should skip inferring types
    of columns automatically (when set to `true` you need to provide explicit `schema`)
  * `inferRows` - If `inferTypes=true`, this parameter specifies the number of
    rows to use for type inference. The default value is 0, meaninig all rows.
  * `schema` - A string that specifies CSV schema. See the documentation for 
    information about the schema format.
  * `separators` - A string that specifies one or more (single character) separators
    that are used to separate columns in the CSV file. Use for example `&quot;;&quot;` to 
    parse semicolon separated files.
  * `culture` - Specifies the name of the culture that is used when parsing 
    values in the CSV file (such as `&quot;en-US&quot;`). The default is invariant culture. 
</summary>
</member>
<member name="M:Deedle.Frame.ReadCsv(System.String,System.Nullable{System.Boolean},System.Boolean,System.Int32,System.String,System.String,System.String,System.Nullable{System.Int32})">
<summary>
 Load data frame from a CSV file. The operation automatically reads column names from the 
 CSV file (if they are present) and infers the type of values for each column. Columns
 of primitive types (`int`, `float`, etc.) are converted to the right type. Columns of other
 types (such as dates) are not converted automatically.

 ## Parameters

  * `location` - Specifies a file name or an web location of the resource.
  * `hasHeaders` - Specifies whether the input CSV file has header row
     (when not set, the default value is `true`)
  * `skipTypeInference` - Specifies whether the method should skip inferring types
    of columns automatically (when set to `true` you need to provide explicit `schema`)
  * `inferRows` - If `inferTypes=true`, this parameter specifies the number of
    rows to use for type inference. The default value is 0, meaninig all rows.
  * `schema` - A string that specifies CSV schema. See the documentation for 
    information about the schema format.
  * `separators` - A string that specifies one or more (single character) separators
    that are used to separate columns in the CSV file. Use for example `&quot;;&quot;` to 
    parse semicolon separated files.
  * `culture` - Specifies the name of the culture that is used when parsing 
    values in the CSV file (such as `&quot;en-US&quot;`). The default is invariant culture. 
  * `maxRows` - Specifies the maximum number of rows that will be read from the CSV file
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Deedle.Deedle.FrameData.Columns">
<summary>
 Represents the data of the frame as a sequence of columns containing
 type and array with column values. `OptionalValue.Missing` is used to
 represent missing data.
</summary>
</member>
<member name="F:Deedle.Deedle.FrameData.RowKeys">
<summary>
 A sequence of keys for all rows. Individual key is an array
 which contains multiple values for hierarchical indices
</summary>
</member>
<member name="F:Deedle.Deedle.FrameData.ColumnKeys">
<summary>
 A sequence of keys for all column. Individual key is an array
 which contains multiple values for hierarchical indices
</summary>
</member>
<member name="T:Deedle.FrameData">
<summary>
 Represents the underlying (raw) data of the frame in a format that can
 be used for exporting data frame to other formats etc. (DataTable, CSV, Excel)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.FrameExtensions.Where``2(Deedle.Frame{``0,``1},System.Func{System.Collections.Generic.KeyValuePair{``0,Deedle.ObjectSeries{``1}},System.Int32,System.Boolean})">
<summary>
 Filters frame rows using the specified condtion. Returns a new data frame
 that contains rows for which the provided function returned false. The function
 is called with `KeyValuePair` containing the row key as the `Key` and `Value`
 gives access to the row series and a row index.

 ## Parameters

  * `frame` - A data frame to invoke the filtering function on.
  * `condition` - A delegate that specifies the filtering condition.
</summary>
</member>
<member name="M:Deedle.FrameExtensions.Where``2(Deedle.Frame{``0,``1},System.Func{System.Collections.Generic.KeyValuePair{``0,Deedle.ObjectSeries{``1}},System.Boolean})">
<summary>
 Filters frame rows using the specified condtion. Returns a new data frame
 that contains rows for which the provided function returned false. The function
 is called with `KeyValuePair` containing the row key as the `Key` and `Value`
 gives access to the row series.

 ## Parameters

  * `frame` - A data frame to invoke the filtering function on.
  * `condition` - A delegate that specifies the filtering condition.
</summary>
</member>
<member name="M:Deedle.FrameExtensions.Transpose``2(Deedle.Frame{``0,``1})">
<summary>
 Returns a transposed data frame. The rows of the original data frame are used as the
 columns of the new one (and vice versa). Use this operation if you have a data frame
 and you mostly need to access its rows as a series (because accessing columns as a 
 series is more efficient).
 
 ## Parameters
  - `frame` - Source data frame to be transposed.
 
 [category:Data structure manipulation]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.FrameExtensions.SaveCsv``2(Deedle.Frame{``0,``1},System.String,System.Collections.Generic.IEnumerable{System.String},System.Char,System.Globalization.CultureInfo)">
<summary>
 Save data frame to a CSV file or to a `Stream`. When calling the operation,
 you can specify whether you want to save the row keys or not (and headers for the keys)
 and you can also specify the separator (use `\t` for writing TSV files). When specifying
 file name ending with `.tsv`, the `\t` separator is used automatically.

 ## Parameters
  - `path` - Specifies the output file name where the CSV data should be written
  - `keyNames` - Specifies the CSV headers for row key (or keys, for multi-level index)
  - `separator` - Specify the column separator in the file (the default is `\t` for 
    TSV files and `,` for CSV files)
  - `culture` - Specify the `CultureInfo` object used for formatting numerical data

 [category:Input and output]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.SaveCsv``2(Deedle.Frame{``0,``1},System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.String},System.Char,System.Globalization.CultureInfo)">
<summary>
 Save data frame to a CSV file or to a `Stream`. When calling the operation,
 you can specify whether you want to save the row keys or not (and headers for the keys)
 and you can also specify the separator (use `\t` for writing TSV files). When specifying
 file name ending with `.tsv`, the `\t` separator is used automatically.

 ## Parameters
  - `path` - Specifies the output file name where the CSV data should be written
  - `includeRowKeys` - When set to `true`, the row key is also written to the output file
  - `keyNames` - Can be used to specify the CSV headers for row key (or keys, for multi-level index)
  - `separator` - Specify the column separator in the file (the default is `\t` for 
    TSV files and `,` for CSV files)
  - `culture` - Specify the `CultureInfo` object used for formatting numerical data

 [category:Input and output]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.SaveCsv``2(Deedle.Frame{``0,``1},System.IO.Stream,System.Boolean,System.Collections.Generic.IEnumerable{System.String},System.Char,System.Globalization.CultureInfo)">
<summary>
 Save data frame to a CSV file or to a `Stream`. When calling the operation,
 you can specify whether you want to save the row keys or not (and headers for the keys)
 and you can also specify the separator (use `\t` for writing TSV files). When specifying
 file name ending with `.tsv`, the `\t` separator is used automatically.

 ## Parameters
  - `stream` - Specifies the output stream where the CSV data should be written
  - `includeRowKeys` - When set to `true`, the row key is also written to the output file
  - `keyNames` - Can be used to specify the CSV headers for row key (or keys, for multi-level index)
  - `separator` - Specify the column separator in the file (the default is `\t` for 
    TSV files and `,` for CSV files)
  - `culture` - Specify the `CultureInfo` object used for formatting numerical data

 [category:Input and output]
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.FrameExtensions.RealignRows``2(Deedle.Frame{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Align the existing data to a specified collection of row keys. Values in the data frame
 that do not match any new key are dropped, new keys (that were not in the original data 
 frame) are assigned missing values.

 ## Parameters
  - `frame` - Source data frame that is to be realigned.
  - `keys` - A sequence of new row keys. The keys must have the same type as the original
    frame keys (because the rows are realigned).

 [category:Data structure manipulation]
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.FrameExtensions.OrderRows``2(Deedle.Frame{``0,``1})">
<summary>
 Returns a data frame that contains the same data as the input, 
 but whose rows are an ordered series. This allows using operations that are
 only available on indexed series such as alignment and inexact lookup.

 ## Parameters
  - `frame` - Source data frame to be ordered.
 
 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.OrderColumns``2(Deedle.Frame{``0,``1})">
<summary>
 Returns a data frame that contains the same data as the input, 
 but whose columns are an ordered series. This allows using operations that are
 only available on indexed series such as alignment and inexact lookup.

 ## Parameters
  - `frame` - Source data frame to be ordered.
 
 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.IndexRowsWith``3(Deedle.Frame{``0,``1},System.Collections.Generic.IEnumerable{``2})">
<summary>
 Replace the row index of the frame with the provided sequence of row keys.
 The rows of the frame are assigned keys according to the current order, or in a
 non-deterministic way, if the current row index is not ordered.

 ## Parameters
  - `frame` - Source data frame whose row index are to be replaced.
  - `keys` - A collection of new row keys.

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.IndexRowsOrdinally``2(Deedle.Frame{``0,``1})">
<summary>
 Replace the row index of the frame with ordinarilly generated integers starting from zero.
 The rows of the frame are assigned index according to the current order, or in a
 non-deterministic way, if the current row index is not ordered.

 ## Parameters
  - `frame` - Source data frame whose row index are to be replaced.

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.IndexColumnsWith``3(Deedle.Frame{``0,``1},System.Collections.Generic.IEnumerable{``2})">
<summary>
 Replace the column index of the frame with the provided sequence of column keys.
 The columns of the frame are assigned keys according to the current order, or in a
 non-deterministic way, if the current column index is not ordered.

 ## Parameters
  - `frame` - Source data frame whose column index are to be replaced.
  - `keys` - A collection of new column keys.

 [category:Data structure manipulation]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.FrameExtensions.GetRows``2(Deedle.Frame{``0,``1},``0[])">
<summary>
 [category:Fancy accessors]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.FrameExtensions.FillMissing``3(Deedle.Frame{``0,``1},System.Func{Deedle.Series{``0,``2},``0,``2})">
<summary>
 Fill missing values in the frame using the specified function. The specified
 function is called with all series and keys for which the frame does not 
 contain value and the result of the call is used in place of the missing value.

 The operation is only applied to columns (series) that contain values of the
 same type as the return type of the provided filling function. The operation 
 does not attempt to convert between numeric values (so a series containing 
 `float` will not be converted to a series of `int`).

 ## Parameters
  - `frame` - An input data frame that is to be filled
  - `f` - A function that takes a series `Series&lt;R, T&gt;` together with a key `K` 
    in the series and generates a value to be used in a place where the original 
    series contains a missing value.

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.FillMissing``2(Deedle.Frame{``0,``1},Deedle.Direction)">
<summary>
 Fill missing values in the data frame with the nearest available value
 (using the specified direction). Note that the frame may still contain
 missing values after call to this function (e.g. if the first value is not available
 and we attempt to fill series with previous values). This operation can only be
 used on ordered frames.

 ## Parameters
  - `frame` - An input data frame that is to be filled
  - `direction` - Specifies the direction used when searching for 
    the nearest available value. `Backward` means that we want to
    look for the first value with a smaller key while `Forward` searches
    for the nearest greater key.

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.FillMissing``3(Deedle.Frame{``0,``1},``2)">
<summary>
 Fill missing values of a given type in the frame with a constant value.
 The operation is only applied to columns (series) that contain values of the
 same type as the provided filling value. The operation does not attempt to 
 convert between numeric values (so a series containing `float` will not be
 converted to a series of `int`).

 ## Parameters
  - `frame` - An input data frame that is to be filled
  - `value` - A constant value that is used to fill all missing values

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.ExpandColumns``1(Deedle.Frame{``0,System.String},System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Creates a new data frame where the specified columns are expanded based on runtime
 structure of the objects they store. A column can be expanded if it is 
 `Series&lt;string, T&gt;` or `IDictionary&lt;K, V&gt;` or if it is any .NET object with readable
 properties. 

 ## Example
 Given a data frame with a series that contains tuples, you can expand the
 tuple members and get a frame with columns `S.Item1` and `S.Item2`:
 
     let df = frame [ &quot;S&quot; =&gt; series [ 1 =&gt; (1, &quot;One&quot;); 2 =&gt; (2, &quot;Two&quot;) ] ]  
     df.ExpandColumns [&quot;S&quot;]

 ## Parameters
  - `names` - Names of columns in the original data frame to be expanded
  - `frame` - Input data frame whose columns will be expanded

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.ExpandColumns``1(Deedle.Frame{``0,System.String},System.Int32,System.Boolean)">
<summary>
 Creates a new data frame where all columns are expanded based on runtime
 structure of the objects they store. The expansion is performed recrusively
 to the specified depth. A column can be expanded if it is `Series&lt;string, T&gt;` 
 or `IDictionary&lt;K, V&gt;` or if it is any .NET object with readable
 properties. 

 ## Parameters
  - `nesting` - The nesting level for expansion. When set to 0, nothing is done.

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.DropSparseRows``2(Deedle.Frame{``0,``1})">
<summary>
 Creates a new data frame that contains only those rows of the original 
 data frame that are _dense_, meaning that they have a value for each column.
 The resulting data frame has the same number of columns, but may have 
 fewer rows (or no rows at all).
 
 ## Parameters
  - `frame` - An input data frame that is to be filtered

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.FrameExtensions.DropSparseColumns``2(Deedle.Frame{``0,``1})">
<summary>
 Creates a new data frame that contains only those columns of the original 
 data frame that are _dense_, meaning that they have a value for each row.
 The resulting data frame has the same number of rows, but may have 
 fewer columns (or no columns at all).

 ## Parameters
  - `frame` - An input data frame that is to be filtered

 [category:Missing values]
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.FrameExtensions.CountRows``2(Deedle.Frame{``0,``1})">
<summary>
 Returns the total number of row keys in the specified frame. This returns
 the total length of the row series, including keys for which there is no 
 value available.
</summary>
</member>
<member name="M:Deedle.FrameExtensions.CountColumns``2(Deedle.Frame{``0,``1})">
<summary>
 Returns the total number of row keys in the specified frame. This returns
 the total length of the row series, including keys for which there is no 
 value available.
</summary>
</member>
<member name="">

</member>
<member name="T:Deedle.FrameExtensions">
<summary>
 Some comment

 ## Data structure manipulation
 Summary 1

 ## Input and output
 Summary 2

 ## Missing values
 Summary 3
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.FrameUtils.fromRows``3(Deedle.Series{``0,``2})">
<summary>
 Create data frame from a series of rows
</summary>
</member>
<member name="M:Deedle.FrameUtils.fromColumns``3(Deedle.Series{``1,``2})">
<summary>
 Create data frame from a series of columns
</summary>
</member>
<member name="M:Deedle.FrameUtils.createRow``3(``0,Deedle.Series{``1,``2})">
<summary>
 Create data frame containing a single row
</summary>
</member>
<member name="M:Deedle.FrameUtils.createColumn``2(``0,Deedle.ISeries{``1})">
<summary>
 Create data frame containing a single column
</summary>
</member>
<member name="M:Deedle.FrameUtils.collapseSeriesSeries``3(Deedle.Series{``0,Deedle.Series{``1,Deedle.ObjectSeries{``2}}})">
<summary>
 Given a series of frames, build a frame with multi-level row index
</summary>
</member>
<member name="M:Deedle.FrameUtils.collapseFrameSeries``3(Deedle.Series{``0,Deedle.Frame{``1,``2}})">
<summary>
 Given a series of frames, build a frame with multi-level row index
</summary>
</member>
<member name="T:Deedle.FrameUtils">
<summary>
 [omit]
 Module with helper functions and operations that are needed by Frame&lt;R, C&gt;, but
 are easier to write in a separate type (having them inside generic type 
 can confuse the type inference in various ways).
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Deedle.Deedle.Frame`2.vectorBuilder">
<summary>
 Vector builder
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Deedle.Frame`2.Item(`1,Deedle.Series{`0,System.Double})">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.Frame`2.op_Subtraction(System.Int32,Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Subtraction(Deedle.Frame{`0,`1},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Subtraction(System.Double,Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Subtraction(Deedle.Frame{`0,`1},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Subtraction(Deedle.Series{`0,System.Int32},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Subtraction(Deedle.Frame{`0,`1},Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Subtraction(Deedle.Series{`0,System.Double},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Subtraction(Deedle.Frame{`0,`1},Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Subtraction(Deedle.Frame{`0,`1},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Multiply(System.Int32,Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Multiply(Deedle.Frame{`0,`1},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Multiply(System.Double,Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Multiply(Deedle.Frame{`0,`1},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Multiply(Deedle.Series{`0,System.Int32},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Multiply(Deedle.Frame{`0,`1},Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Multiply(Deedle.Series{`0,System.Double},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Multiply(Deedle.Frame{`0,`1},Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Multiply(Deedle.Frame{`0,`1},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_DynamicAssignment``3(Deedle.Frame{``0,``1},``1,System.Collections.Generic.IEnumerable{``2})">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_DynamicAssignment``3(Deedle.Frame{``0,``1},``1,Deedle.Series{``0,``2})">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Dynamic``2(Deedle.Frame{``0,``1},``1)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Division(System.Int32,Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Division(Deedle.Frame{`0,`1},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Division(System.Double,Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Division(Deedle.Frame{`0,`1},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Division(Deedle.Series{`0,System.Int32},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Division(Deedle.Frame{`0,`1},Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Division(Deedle.Series{`0,System.Double},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Division(Deedle.Frame{`0,`1},Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Division(Deedle.Frame{`0,`1},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Addition(System.Int32,Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Addition(Deedle.Frame{`0,`1},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Addition(System.Double,Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Addition(Deedle.Frame{`0,`1},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Addition(Deedle.Series{`0,System.Int32},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Addition(Deedle.Frame{`0,`1},Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Addition(Deedle.Series{`0,System.Double},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Addition(Deedle.Frame{`0,`1},Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.op_Addition(Deedle.Frame{`0,`1},Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="">

</member>
<member name="P:Deedle.Frame`2.RowsDense">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:Deedle.Frame`2.Rows">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:Deedle.Frame`2.RowKeys">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Deedle.Frame`2.Item(`1)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="P:Deedle.Frame`2.Item(`1,`0)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:Deedle.Frame`2.IsEmpty">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Deedle.Frame`2.ColumnsDense">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:Deedle.Frame`2.Columns">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:Deedle.Frame`2.ColumnKeys">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.Frame`2.Zip``3(Deedle.Frame{`0,`1},System.Func{``0,``1,``2})">
<summary>
 Aligns two data frames using both column index and row index and apply the specified operation
 on values of a specified type that are available in both data frames. This overload uses
 `JoinKind.Outer` for both columns and rows.

 Once aligned, the call `df1.Zip&lt;T&gt;(df2, f)` applies the specifed function `f` on all `T` values
 that are available in corresponding locations in both frames. For values of other types, the 
 value from `df1` is returned.

 ## Parameters
  - `otherFrame` - Other frame to be aligned and zipped with the current instance
  - `op` - A function that is applied to aligned values. The `Zip` operation is generic
    in the type of this function and the type of function is used to determine which 
    values in the frames are zipped and which are left unchanged.

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.Frame`2.Zip``3(Deedle.Frame{`0,`1},Deedle.JoinKind,Deedle.JoinKind,Deedle.Lookup,System.Func{``0,``1,``2})">
<summary>
 Aligns two data frames using both column index and row index and apply the specified operation
 on values of a specified type that are available in both data frames. The parameters `columnKind`,
 and `rowKind` can be specified to determine how the alginment works (similarly to `Join`).
 Column keys are always matched using `Lookup.Exact`, but `lookup` determines lookup for rows.

 Once aligned, the call `df1.Zip&lt;T&gt;(df2, f)` applies the specifed function `f` on all `T` values
 that are available in corresponding locations in both frames. For values of other types, the 
 value from `df1` is returned.

 ## Parameters
  - `otherFrame` - Other frame to be aligned and zipped with the current instance
  - `columnKind` - Specifies how to align columns (inner, outer, left or right join)
  - `rowKind` - Specifies how to align rows (inner, outer, left or right join)
  - `lookup` - Specifies how to find matching value for a row (when using left or right join on rows)
  - `op` - A function that is applied to aligned values. The `Zip` operation is generic
    in the type of this function and the type of function is used to determine which 
    values in the frames are zipped and which are left unchanged.

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.Frame`2.TryGetRowAt(System.Int32)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Frame`2.Truncate(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Tanh(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Tan(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Sqrt(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Sinh(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Sin(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Sign(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.SeriesApply``1(System.Boolean,System.Func{Deedle.Series{`0,``0},Deedle.ISeries{`0}})">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.SeriesApply``1(System.Func{Deedle.Series{`0,``0},Deedle.ISeries{`0}})">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.Frame`2.Round(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.ReplaceSeries``1(`1,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Mutates the data frame by replacing the specified series with
 a new data sequence . (If the series does not exist, only the new
 series is added.)

 ## Parameters
  - `column` - A key (or name) for the column to be replaced or added
  - `series` - A sequence of values to be added

 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.ReplaceSeries(`1,Deedle.ISeries{`0})">
<summary>
 Mutates the data frame by replacing the specified series with
 a new series. (If the series does not exist, only the new
 series is added.)

 ## Parameters
  - `column` - A key (or name) for the column to be replaced or added
  - `series` - A data series to be used (the row key type has to match)

 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.ReplaceSeries``1(`1,System.Collections.Generic.IEnumerable{``0},Deedle.Lookup)">
<summary>
 Mutates the data frame by replacing the specified series with
 a new data sequence. (If the series does not exist, only the new series is added.) 
 When adding a series, the specified `lookup` parameter is used for filling
 missing values (e.g. `null` or `NaN`). The parameter can only be used for 
 frame with ordered indices.

 ## Parameters
  - `column` - A key (or name) for the column to be replaced or added
  - `series` - A data series to be used (the row key type has to match)
  - `lookup` - Specify how to find value in the added series (look for 
    nearest available value with the smaller/greater key).

 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.ReplaceSeries(`1,Deedle.ISeries{`0},Deedle.Lookup)">
<summary>
 Mutates the data frame by replacing the specified series with
 a new series. (If the series does not exist, only the new series is added.) 
 When adding a series, the specified `lookup` parameter is used for matching 
 keys. The parameter can only be used for frame with ordered indices.

 ## Parameters
  - `column` - A key (or name) for the column to be replaced or added
  - `series` - A data series to be used (the row key type has to match)
  - `lookup` - Specify how to find value in the added series (look for 
    nearest available value with the smaller/greater key).

 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.RenameSeries(System.Func{`1,`1})">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.RenameSeries(`1,`1)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.RenameSeries(System.Collections.Generic.IEnumerable{`1})">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.Pow(System.Double,Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Pow(Deedle.Frame{`0,`1},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.Frame`2.Log10(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Log(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Join``1(`1,Deedle.Series{`0,``0})">
<summary>
 Performs outer join on data frame and a series. The column key for the joined
 series must not occur in the current data frame. The rows are automatically aligned
 and unavailable values are marked as missing.

 ## Parameters
  - `colKey` - Column key to be used for the joined series
  - `series` - Series to be joined with the current data frame

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.Frame`2.Join``1(`1,Deedle.Series{`0,``0},Deedle.JoinKind)">
<summary>
 Join data frame and a series. The column key for the joined series must not occur in the 
 current data frame. The rows are aligned and transformed according to the specified join kind.

 ## Parameters
  - `colKey` - Column key to be used for the joined series
  - `series` - Series to be joined with the current data frame
  - `kind` - Specifies the joining behavior on row indices. Use `JoinKind.Outer` and 
    `JoinKind.Inner` to get the union and intersection of the row keys, respectively.
    Use `JoinKind.Left` and `JoinKind.Right` to use the current key of the left/right
    data frame.

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.Frame`2.Join``1(`1,Deedle.Series{`0,``0},Deedle.JoinKind,Deedle.Lookup)">
<summary>
 Join data frame and a series. The column key for the joined series must not occur in the 
 current data frame. The rows are aligned and transformed according to the specified join kind.
 When the index of both objects is ordered, it is possible to specify `lookup` 
 in order to align indices from other frame to the indices of the main frame
 (typically, to find the nearest key with available value for a key).

 ## Parameters
  - `colKey` - Column key to be used for the joined series
  - `series` - Series to be joined with the current data frame
  - `kind` - Specifies the joining behavior on row indices. Use `JoinKind.Outer` and 
    `JoinKind.Inner` to get the union and intersection of the row keys, respectively.
    Use `JoinKind.Left` and `JoinKind.Right` to use the current key of the left/right
    data frame.
  - `lookup` - When `kind` is `Left` or `Right` and the two frames have ordered row index,
    this parameter can be used to specify how to find value for a key when there is no
    exactly matching key or when there are missing values.

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.Frame`2.Join(Deedle.Frame{`0,`1})">
<summary>
 Performs outer join on two data frames. The columns of the joined frames must not 
 overlap and their rows are aligned. The unavailable values are marked as missing.

 ## Parameters
  - `otherFrame` - Other frame (right) to be joined with the current instance (left)

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.Frame`2.Join(Deedle.Frame{`0,`1},Deedle.JoinKind)">
<summary>
 Join two data frames. The columns of the joined frames must not overlap and their
 rows are aligned and transformed according to the specified join kind.
 For more alignment options on ordered frames, see overload taking `lookup`.

 ## Parameters
  - `otherFrame` - Other frame (right) to be joined with the current instance (left)
  - `kind` - Specifies the joining behavior on row indices. Use `JoinKind.Outer` and 
    `JoinKind.Inner` to get the union and intersection of the row keys, respectively.
    Use `JoinKind.Left` and `JoinKind.Right` to use the current key of the left/right
    data frame.

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.Frame`2.Join(Deedle.Frame{`0,`1},Deedle.JoinKind,Deedle.Lookup)">
<summary>
 Join two data frames. The columns of the joined frames must not overlap and their
 rows are aligned and transformed according to the specified join kind.
 When the index of both frames is ordered, it is possible to specify `lookup` 
 in order to align indices from other frame to the indices of the main frame
 (typically, to find the nearest key with available value for a key).

 ## Parameters
  - `otherFrame` - Other frame (right) to be joined with the current instance (left)
  - `kind` - Specifies the joining behavior on row indices. Use `JoinKind.Outer` and 
    `JoinKind.Inner` to get the union and intersection of the row keys, respectively.
    Use `JoinKind.Left` and `JoinKind.Right` to use the current key of the left/right
    data frame.
  - `lookup` - When `kind` is `Left` or `Right` and the two frames have ordered row index,
    this parameter can be used to specify how to find value for a key when there is no
    exactly matching key or when there are missing values.

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.Frame`2.IndexRows``1(`1)">
<summary>
 Returns a data frame whose rows are indexed based on the specified column of the original
 data frame. The generic type parameter is (typically) needed to specify the type of the 
 values in the required index column.

 ## Parameters
  - `column` - The name of a column in the original data frame that will be used for the new
    index. Note that the values in the column need to be unique.

 [category:Indexing]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.Frame`2.GetSeriesAt``1(System.Int32)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetSeries``1(`1)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetSeries``1(`1,Deedle.Lookup)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetRowKeyAt(System.Int32)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetRowAt(System.Int32)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetRow``1(`0,Deedle.Lookup)">
<summary>
 [category:Fancy accessors]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetRow``1(`0)">
<summary>
 [category:Fancy accessors]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.Frame`2.GetColumns``1">
<summary>
 [category:Fancy accessors]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetAllValues``1(System.Boolean)">
<summary>
 [category:Fancy accessors]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetAllValues``1">
<summary>
 [category:Fancy accessors]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetAllSeries``1(System.Boolean)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.GetAllSeries``1">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.Frame`2.Format">
<summary>
 Shows the data frame content in a human-readable format. The resulting string
 shows all columns, but a limited number of rows. The property is used 
 automatically by F# Interactive.
</summary>
</member>
<member name="M:Deedle.Frame`2.Floor(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Exp(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.Frame`2.DropSeries(`1)">
<summary>
 Mutates the data frame by removing the specified series from the 
 frame columns. The operation throws if the column key is not found.

 ## Parameters
  - `column` - The key (or name) to be dropped from the frame
  - `frame` - Source data frame (which is not mutated by the operation)

 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.Cosh(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Cos(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.Frame`2.Ceiling(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Atan(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Asin(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.Frame`2.Append(Deedle.Frame{`0,`1})">
<summary>
 Append two data frames with non-overlapping values. The operation takes the union of columns
 and rows of the source data frames and then unions the values. An exception is thrown when 
 both data frames define value for a column/row location, but the operation succeeds if one
 frame has a missing value at the location.

 Note that the rows are *not* automatically reindexed to avoid overlaps. This means that when
 a frame has rows indexed with ordinal numbers, you may need to explicitly reindex the row
 keys before calling append.

 ## Parameters
  - `otherFrame` - The other frame to be appended (combined) with the current instance

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.Frame`2.AddSeries``1(`1,Deedle.ISeries{`0},Deedle.Lookup)">
<summary>
 Mutates the data frame by adding an additional data series
 as a new column with the specified column key. The operation 
 uses left join and aligns new series to the existing frame keys.
 A parameter `lookup` can be used to specify how to find a value in the
 added series (if an exact key is not available). The `lookup` parameter
 can only be used with ordered indices.

 ## Parameters
  - `series` - A data series to be added (the row key type has to match)
  - `column` - A key (or name) for the newly added column
  - `lookup` - Specify how to find value in the added series (look for 
    nearest available value with the smaller/greater key).

 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.AddSeries``1(`1,System.Collections.Generic.IEnumerable{``0},Deedle.Lookup)">
<summary>
 Mutates the data frame by adding an additional data series
 as a new column with the specified column key. The sequence is
 aligned to the data frame based on ordering. If it is longer, it is
 trimmed and if it is shorter, missing values will be added.
 A parameter `lookup` can be used to specify how to find a value in the
 added series (if the sequence contains invalid values like `null` or `NaN`). 

 ## Parameters
  - `column` - A key (or name) for the newly added column
  - `series` - A sequence of values to be added
  - `lookup` - Specify how to find value in the added series (look for 
    nearest available value with the smaller/greater key).

 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.AddSeries(`1,Deedle.ISeries{`0})">
<summary>
 Mutates the data frame by adding an additional data series
 as a new column with the specified column key. The operation 
 uses left join and aligns new series to the existing frame keys.

 ## Parameters
  - `series` - A data series to be added (the row key type has to match)
  - `column` - A key (or name) for the newly added column

 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.AddSeries``1(`1,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Mutates the data frame by adding an additional data series
 as a new column with the specified column key. The sequence is
 aligned to the data frame based on ordering. If it is longer, it is
 trimmed and if it is shorter, missing values will be added.

 ## Parameters
  - `column` - A key (or name) for the newly added column
  - `series` - A sequence of values to be added

 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.Frame`2.Acos(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Frame`2.Abs(Deedle.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.Frame`2">
<summary>
 A frame contains one Index, with multiple Vecs
 (because this is dynamic, we need to store them as IVec)

 ## Joining, zipping and appending
 More info


</summary>
</member>
<member name="M:Deedle.ICustomLookup`1.Matches(`0)">
<summary>
 Tests whether a specified key matches the current key (for example, in hierarchical indexing
 based on tuples, if the current key represents a pair (1, _) then the value (1, 42) would match).
</summary>
</member>
<member name="T:Deedle.ICustomLookup`1">
<summary>
 Represents a special lookup. This can be used to support hierarchical or duplicate keys
 in an index. A key type `K` can come with associated `ICustomLookup&lt;K&gt;` to provide 
 customized pattern matching (equality testing) 
</summary>
</member>
<member name="">

</member>
<member name="T:Deedle.IFrame">
<summary>
 An empty interface that is implemented by `Frame&lt;&apos;R, &apos;C&gt;`. The purpose of the
 interface is to allow writing code that works on arbitrary data frames, although
 you 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Deedle.ISeries`1.Vector">
<summary>
 Returns the vector containing data of the series (as an untyped vector)
</summary>
</member>
<member name="P:Deedle.ISeries`1.Index">
<summary>
 Returns the index containing keys of the series 
</summary>
</member>
<member name="M:Deedle.ISeries`1.TryGetObject(`0)">
<summary>
 Attempts to get the value at a specified key and return it as `obj`
</summary>
</member>
<member name="T:Deedle.ISeries`1">
<summary>
 Represents an untyped series with keys of type `K` and values of some unknown type
 (This type should not generally be used directly, but it can be used when you need
 to write code that works on a sequence of series of heterogeneous types).
</summary>
</member>
<member name="P:Deedle.IVector.SuppressPrinting">
<summary>
 When `true`, the formatter in F# Interactive will not attempt to evaluate the
 vector to print it. This is useful when the vector contains lazily loaded data.
</summary>
</member>
<member name="P:Deedle.IVector.ObjectSequence">
<summary>
 Returns all values of the vector as a sequence of optional objects
</summary>
</member>
<member name="P:Deedle.IVector.ElementType">
<summary>
 Returns the type of elements stored in the current vector as `System.Type`.
 This member is mainly used for internal purposes (to invoke a generic function
 represented by `VectorCallSite1&lt;R&gt;` with the typed version of the current 
 vector as an argument.
</summary>
</member>
<member name="M:Deedle.IVector.GetObject(Deedle.Addressing.Address)">
<summary>
 Return value stored in the vector at a specified address. This is simply an
 untyped version of `GetValue` method on a typed vector.
</summary>
</member>
<member name="T:Deedle.IVector">
<summary>
 Represents an (untyped) vector that stores some values and provides access
 to the values via a generic address. This type should be only used directly when
 extending the DataFrame library and adding a new way of storing or loading data.
 To allow invocation via Reflection, the vector exposes type of elements as `System.Type`.
</summary>
</member>
<member name="P:Deedle.IVector`1.Data">
<summary>
 Returns all data of the vector in one of the supported formats. Depending
 on the vector, data may be returned as a continuous block of memory using
 `ReadOnlyCollection&lt;T&gt;` or as a lazy sequence `seq&lt;T&gt;`.
</summary>
</member>
<member name="M:Deedle.IVector`1.SelectMissing``1(Microsoft.FSharp.Core.FSharpFunc{Deedle.OptionalValue{`0},Deedle.OptionalValue{``0}})">
<summary>
 Apply the specified function to all values stored in the vector and return
 a new vector (not necessarily of the same representation) with the results.
 The function handles missing values - it is called with optional values and
 may return a missing value as a result of the transformation.
</summary>
</member>
<member name="M:Deedle.IVector`1.Select``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0})">
<summary>
 Apply the specified function to all values stored in the vector and return
 a new vector (not necessarily of the same representation) with the results.
</summary>
</member>
<member name="M:Deedle.IVector`1.GetValue(Deedle.Addressing.Address)">
<summary>
 Returns value stored in the vector at a specified address. 
</summary>
</member>
<member name="T:Deedle.IVector`1">
<summary>
 A generic, typed vector. Represents mapping from addresses to values of type `T`. 
 The vector provides a minimal interface that is required by series and can be
 implemented in a number of ways to provide vector backed by database or an
 alternative representation of data.
</summary>
</member>
<member name="M:Deedle.Index.CreateUnordered``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Create an index from a sequence of keys and assume they are not sorted
 (the resulting index is also not sorted).
</summary>
</member>
<member name="M:Deedle.Index.Create``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Create an index from a sequence of keys and check if they are sorted or not
</summary>
</member>
<member name="T:Deedle.Index">
<summary>
 Type that provides access to creating indices (represented as `LinearIndex` values)
</summary>
</member>
<member name="F:Deedle.JoinKind.Right">
<summary>
 Take the keys of the right (second) structure and align values from the left (first)
 structure with the keys of the second one. Values for keys not available in the first
 structure will be missing.
</summary>
</member>
<member name="F:Deedle.JoinKind.Left">
<summary>
 Take the keys of the left (first) structure and align values from the right (second)
 structure with the keys of the first one. Values for keys not available in the second
 structure will be missing.
</summary>
</member>
<member name="F:Deedle.JoinKind.Inner">
<summary>
 Take the intersection of the keys available in both structures and align the 
 values of the two structures. The resulting structure cannot contain missing values.
</summary>
</member>
<member name="F:Deedle.JoinKind.Outer">
<summary>
 Combine the keys available in both structures, align the values that
 are available in both of them and mark the remaining values as missing.
</summary>
</member>
<member name="">

</member>
<member name="T:Deedle.JoinKind">
<summary>
 This enumeration specifies joining behavior for `Join` method provided
 by `Series` and `Frame`. Outer join unions the keys (and may introduce
 missing values), inner join takes the intersection of keys; left and
 right joins take the keys of the first or the second series/frame.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Deedle.Lookup.NearestSmaller">
<summary>
 Lookup a value associated with the specified key or with the nearest
 smaller key that has a value available. Fails (or returns missing value)
 only when the specified key is smaller than all available keys.
</summary>
</member>
<member name="F:Deedle.Lookup.NearestGreater">
<summary>
 Lookup a value associated with the specified key or with the nearest
 greater key that has a value available. Fails (or returns missing value)
 only when the specified key is greater than all available keys.
</summary>
</member>
<member name="F:Deedle.Lookup.Exact">
<summary>
 Lookup a value associated with the exact specified key. 
 If the key is not available, then fail or return missing value. 
</summary>
</member>
<member name="">

</member>
<member name="T:Deedle.Lookup">
<summary>
 Represents different behaviors of key lookup in series. For unordered series,
 the only available option is `Lookup.Exact` which finds the exact key - methods
 fail or return missing value if the key is not available in the index. For ordered
 series `Lookup.NearestGreater` finds the first greater key (e.g. later date) with
 a value. `Lookup.NearestSmaller` searches for the first smaller key.
</summary>
</member>
<member name="">

</member>
<member name="P:Deedle.MissingValueException.Key">
<summary>
 The key that has been accessed
</summary>
</member>
<member name="">

</member>
<member name="T:Deedle.MissingValueException">
<summary>
 Thrown when a value at the specified index does not exist in the data frame or series.
 This exception is thrown only when the key is defined, but the value is not available,
 in other situations `KeyNotFoundException` is thrown
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.OptionalValue.OfNullable``1(System.Nullable{``0})">
<summary>
 Creates an `OptionalValue&lt;T&gt;` from a nullable value of type `T?`
</summary>
</member>
<member name="M:Deedle.OptionalValue.Empty``1">
<summary>
 Creates an `OptionalValue&lt;&apos;T&gt;` that does not contain a value
</summary>
</member>
<member name="M:Deedle.OptionalValue.Create``1(``0)">
<summary>
 Creates an `OptionalValue&lt;&apos;T&gt;` that contains a value `v`
</summary>
</member>
<member name="T:Deedle.OptionalValue">
<summary>
 Non-generic type that makes it easier to create `OptionalValue&lt;T&gt;` values
 from C# by benefiting the type inference for generic method invocations.
</summary>
</member>
<member name="M:Deedle.OptionalValueExtensions.OrDefault``1(Deedle.OptionalValue{``0},``0)">
<summary>
 Extension method that returns value in the specified optional value
 or the provided default value (the second argument).
</summary>
</member>
<member name="M:Deedle.OptionalValueExtensions.AsNullable``1(Deedle.OptionalValue{``0})">
<summary>
 Extension method that converts optional value containing a value type
 to a C# friendly `Nullable&lt;T&gt;` or `T?` type.
</summary>
</member>
<member name="T:Deedle.OptionalValueExtensions">
<summary>
 Extension methods for working with optional values from C#. These make
 it easier to provide default values and convert optional values to 
 `Nullable` (when the contained value is value type)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Deedle.OptionalValue`1.ValueOrDefault">
<summary>
 Returns the value stored in the current `OptionalValue&lt;T&gt;` or 
 the default value of the type `T` when a value is not present.
</summary>
</member>
<member name="P:Deedle.OptionalValue`1.Value">
<summary>
 Returns the value stored in the current `OptionalValue&lt;T&gt;`. 
 Exceptions:
   `InvalidOperationException` - Thrown when `HasValue` is `false`.
</summary>
</member>
<member name="P:Deedle.OptionalValue`1.Missing">
<summary>
 Returns a new instance of `OptionalValue&lt;T&gt;` that does not contain a value.
</summary>
</member>
<member name="P:Deedle.OptionalValue`1.HasValue">
<summary>
 Gets a value indicating whether the current `OptionalValue&lt;T&gt;` has a value
</summary>
</member>
<member name="M:Deedle.OptionalValue`1.ToString">
<summary>
 Prints the value or &quot;&lt;null&gt;&quot; when the value is present, but is `null`
 or &quot;&lt;missing&gt;&quot; when the value is not present (`HasValue = false`).
</summary>
</member>
<member name="M:Deedle.OptionalValue`1.GetHashCode">
<summary>
 Support structural equality      
</summary>
</member>
<member name="M:Deedle.OptionalValue`1.Equals(System.Object)">
<summary>
 Support structural equality      
</summary>
</member>
<member name="M:Deedle.OptionalValue`1.#ctor(`0)">
<summary>
 Creates a new instance of `OptionalValue&lt;T&gt;` that contains  
 the specified `T` value .
</summary>
</member>
<member name="">

</member>
<member name="T:Deedle.OptionalValue`1">
<summary>
 Value type that represents a potentially missing value. This is similar to 
 `System.Nullable&lt;T&gt;`, but does not restrict the contained value to be a value
 type, so it can be used for storing values of any types. When obtained from
 `DataFrame&lt;R, C&gt;` or `Series&lt;K, T&gt;`, the `Value` will never be `Double.NaN` or `null`
 (but this is not, in general, checked when constructing the value).

 The type is only used in C#-friendly API. F# operations generally use expose
 standard F# `option&lt;T&gt;` type instead. However, there the `OptionalValue` module
 contains helper functions for using this type from F# as well as `Missing` and
 `Present` active patterns.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Deedle.Series.vectorBuilder">
<summary>
 Vector &amp; index builders
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.SeriesExtensions.SumLevel``2(Deedle.Series{``0,System.Decimal},System.Func{``0,``1})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the sum of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the sums
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.SumLevel``2(Deedle.Series{``0,System.Int32},System.Func{``0,``1})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the sum of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the sums
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.SumLevel``2(Deedle.Series{``0,System.Single},System.Func{``0,``1})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the sum of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the sums
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.SumLevel``2(Deedle.Series{``0,System.Double},System.Func{``0,``1})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the sum of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the sums
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Sum``1(Deedle.Series{``0,System.Decimal})">
<summary>
 Returns the sum of the elements of the series. 
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Sum``1(Deedle.Series{``0,System.Int32})">
<summary>
 Returns the sum of the elements of the series. 
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Sum``1(Deedle.Series{``0,System.Single})">
<summary>
 Returns the sum of the elements of the series. The operation skips over
 missing values and so the result will never be `NaN`.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Sum``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns the sum of the elements of the series. The operation skips over
 missing values and so the result will never be `NaN`.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.StandardDeviationLevel``2(Deedle.Series{``0,System.Double},System.Func{``0,``1})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the standard deviation of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the standard deviations
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.StandardDeviation``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns the standard deviation of the elements of the series. The operation skips over
 missing values and so the result will never be `NaN`.
 [category:Statistics]
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.SeriesExtensions.SampleInto``1(Deedle.Series{System.DateTimeOffset,``0},System.TimeSpan,Deedle.Direction,System.Func{System.DateTimeOffset,Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{System.DateTimeOffset,``0},System.Object}})">
<summary>
 Performs sampling by time and aggregates chunks obtained by time-sampling into a single
 value using a specified function. The operation generates keys starting at the first
 key in the source series, using the specified `interval` and then obtains chunks based on 
 these keys in a fashion similar to the `Series.resample` function.

 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.
  - `aggregate` - A function that is called to aggregate each chunk into a single value.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.SampleInto``1(Deedle.Series{System.DateTime,``0},System.TimeSpan,Deedle.Direction,System.Func{System.DateTime,Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{System.DateTime,``0},System.Object}})">
<summary>
 Performs sampling by time and aggregates chunks obtained by time-sampling into a single
 value using a specified function. The operation generates keys starting at the first
 key in the source series, using the specified `interval` and then obtains chunks based on 
 these keys in a fashion similar to the `Series.resample` function.

 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.
  - `aggregate` - A function that is called to aggregate each chunk into a single value.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Sample``1(Deedle.Series{System.DateTimeOffset,``0},System.TimeSpan)">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting from the smallest key of the original series, using the specified `interval`
 and then finds nearest smaller values close to such keys. The function generates samples
 at, or just before the end of an interval and at, or after, the end of the series.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Sample``1(Deedle.Series{System.DateTime,``0},System.TimeSpan)">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting from the smallest key of the original series, using the specified `interval`
 and then finds nearest smaller values close to such keys. The function generates samples
 at, or just before the end of an interval and at, or after, the end of the series.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Sample``1(Deedle.Series{System.DateTimeOffset,``0},System.TimeSpan,Deedle.Direction)">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting from the smallest key of the original series, using the specified `interval`
 and then finds nearest smaller values close to such keys according to `dir`.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
  - `dir` - Specifies how the keys should be generated. `Direction.Forward` means that the 
    key is the smallest value of each chunk (and so first key of the series is returned and 
    the last is not, unless it matches exactly _start + k*interval_); `Direction.Backward`
    means that the first key is skipped and sample is generated at, or just before the end 
    of interval and at the end of the series.
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Sample``1(Deedle.Series{System.DateTime,``0},System.TimeSpan,Deedle.Direction)">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting from the smallest key of the original series, using the specified `interval`
 and then finds nearest smaller values close to such keys according to `dir`.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
  - `lookup` - Specifies how the lookup based on keys is performed. `Exact` means that the
    values at exact keys will be returned; `NearestGreater` returns the nearest greater key value
    (starting at the first key) and `NearestSmaller` returns the nearest smaller key value
    (starting at most `interval` after the end of the series)
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Sample``1(Deedle.Series{System.DateTimeOffset,``0},System.DateTimeOffset,System.TimeSpan,Deedle.Direction)">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting at the specified `start` time, using the specified `interval`
 and then finds nearest smaller values close to such keys according to `dir`.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `start` - The initial time to be used for sampling
  - `interval` - The interval between the individual samples 
  - `lookup` - Specifies how the lookup based on keys is performed. `Exact` means that the
    values at exact keys will be returned; `NearestGreater` returns the nearest greater key value
    (starting at the first key) and `NearestSmaller` returns the nearest smaller key value
    (starting at most `interval` after the end of the series)
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Sample``1(Deedle.Series{System.DateTime,``0},System.DateTime,System.TimeSpan,Deedle.Direction)">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting at the specified `start` time, using the specified `interval`
 and then finds nearest smaller values close to such keys according to `dir`.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `start` - The initial time to be used for sampling
  - `interval` - The interval between the individual samples 
  - `lookup` - Specifies how the lookup based on keys is performed. `Exact` means that the
    values at exact keys will be returned; `NearestGreater` returns the nearest greater key value
    (starting at the first key) and `NearestSmaller` returns the nearest smaller key value
    (starting at most `interval` after the end of the series)
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.ResampleUniform``3(Deedle.Series{``0,``1},System.Func{``0,``2},System.Func{``2,``2},Deedle.Lookup)">
<summary>
 Resample the series based on equivalence class on the keys and also generate values 
 for all keys of the target space that are between the minimal and maximal key of the
 specified series (e.g. generate value for all days in the range covered by the series).
 A specified function `keyProj` is used to project keys to another space and `nextKey`
 is used to generate all keys in the range. The last value of each chunk is returned.

 When there are no values for a (generated) key, then the function attempts to get the
 greatest value from the previous smaller chunk (i.e. value for the previous date time).

 ## Parameters
  - `series` - An input series to be resampled
  - `fillMode` - When set to `Lookup.NearestSmaller` or `Lookup.NearestGreater`, 
     the function searches for a nearest available observation in an neighboring chunk.
     Otherwise, the function `f` is called with an empty series as an argument.
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)
  - `nextKey` - A function that gets the next key in the transformed space
    
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.ResampleUniform``3(Deedle.Series{``0,``1},System.Func{``0,``2},System.Func{``2,``2})">
<summary>
 Resample the series based on equivalence class on the keys and also generate values 
 for all keys of the target space that are between the minimal and maximal key of the
 specified series (e.g. generate value for all days in the range covered by the series).
 For each equivalence class (e.g. date), select the latest value (with greatest key).
 A specified function `keyProj` is used to project keys to another space and `nextKey`
 is used to generate all keys in the range. 

 When there are no values for a (generated) key, then the function attempts to get the
 greatest value from the previous smaller chunk (i.e. value for the previous date time).

 ## Parameters
  - `series` - An input series to be resampled
  - `fillMode` - When set to `Lookup.NearestSmaller` or `Lookup.NearestGreater`, 
     the function searches for a nearest available observation in an neighboring chunk.
     Otherwise, the function `f` is called with an empty series as an argument.
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)
  - `nextKey` - A function that gets the next key in the transformed space
    
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.ResampleEquivalence``4(Deedle.Series{``0,``1},System.Func{``0,``2},System.Func{Deedle.Series{``0,``1},``3})">
<summary>
 Resample the series based on equivalence class on the keys. A specified function
 `keyProj` is used to project keys to another space and the observations for which the 
 projected keys are equivalent are grouped into chunks. The chunks are then transformed
 to values using the provided function `f`.

 ## Parameters
  - `series` - An input series to be resampled
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)
  - `aggregate` - A function that is used to collapse a generated chunk into a 
    single value. 

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. For unordered
 series, similar functionality can be implemented using `GroupBy`.
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.ResampleEquivalence``3(Deedle.Series{``0,``1},System.Func{``0,``2})">
<summary>
 Resample the series based on equivalence class on the keys. A specified function
 `keyProj` is used to project keys to another space and the observations for which the 
 projected keys are equivalent are grouped into chunks. The chunks are then returned
 as nested series.

 ## Parameters
  - `series` - An input series to be resampled
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. For unordered
 series, similar functionality can be implemented using `GroupBy`.
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.SeriesExtensions.OrderByKey``2(Deedle.Series{``0,``1})">
<summary>
 Returns a new series whose entries are reordered according to index order

 ## Parameters
  - `series` - An input series to be used

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.MinLevel``2(Deedle.Series{``0,System.Decimal},System.Func{``0,``1})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the smallest element of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the smallest elements
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.MinLevel``2(Deedle.Series{``0,System.Int32},System.Func{``0,``1})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the smallest element of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the smallest elements
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.MinLevel``2(Deedle.Series{``0,System.Single},System.Func{``0,``1})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the smallest element of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the smallest elements
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.MinLevel``2(Deedle.Series{``0,System.Double},System.Func{``0,``1})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the smallest element of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the smallest elements
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Min``1(Deedle.Series{``0,System.Decimal})">
<summary>
 Returns the smallest of all elements of the series. 
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Min``1(Deedle.Series{``0,System.Int32})">
<summary>
 Returns the smallest of all elements of the series. 
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Min``1(Deedle.Series{``0,System.Single})">
<summary>
 Returns the smallest of all elements of the series. The operation 
 skips over missing values and so the result will never be `NaN`.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Min``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns the smallest of all elements of the series. The operation 
 skips over missing values and so the result will never be `NaN`.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.MedianLevel``2(Deedle.Series{``0,System.Double},System.Func{``0,``1})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the median of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the medians
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Median``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns the median of the elements of the series. The operation skips over
 missing values and so the result will never be `NaN`.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.MeanLevel``2(Deedle.Series{``0,System.Decimal},System.Func{``0,``1})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the mean of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the means
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.MeanLevel``2(Deedle.Series{``0,System.Single},System.Func{``0,``1})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the mean of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the means
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.MeanLevel``2(Deedle.Series{``0,System.Double},System.Func{``0,``1})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the mean of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the means
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Mean``1(Deedle.Series{``0,System.Decimal})">
<summary>
 Returns the mean of the elements of the series. 
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Mean``1(Deedle.Series{``0,System.Single})">
<summary>
 Returns the mean of the elements of the series. The operation skips over
 missing values and so the result will never be `NaN`.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Mean``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns the mean of the elements of the series. The operation skips over
 missing values and so the result will never be `NaN`.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.MaxLevel``2(Deedle.Series{``0,System.Decimal},System.Func{``0,``1})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the greatest element of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the greatest elements
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.MaxLevel``2(Deedle.Series{``0,System.Int32},System.Func{``0,``1})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the greatest element of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the greatest elements
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.MaxLevel``2(Deedle.Series{``0,System.Single},System.Func{``0,``1})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the greatest element of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the greatest elements
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.MaxLevel``2(Deedle.Series{``0,System.Double},System.Func{``0,``1})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the greatest element of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the greatest elements
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Max``1(Deedle.Series{``0,System.Decimal})">
<summary>
 Returns the greatest of all elements of the series. 
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Max``1(Deedle.Series{``0,System.Int32})">
<summary>
 Returns the greatest of all elements of the series. 
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Max``1(Deedle.Series{``0,System.Single})">
<summary>
 Returns the greatest of all elements of the series. The operation 
 skips over missing values and so the result will never be `NaN`.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.Max``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns the greatest of all elements of the series. The operation 
 skips over missing values and so the result will never be `NaN`.
 [category:Statistics]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.SeriesExtensions.GetObservations``2(Deedle.Series{``0,``1})">
<summary>
 Return observations with available values. The operation skips over 
 all keys with missing values (such as values created from `null`,
 `Double.NaN`, or those that are missing due to outer join etc.).
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.GetAllObservations``2(Deedle.Series{``0,``1})">
<summary>
 Returns all keys from the sequence, together with the associated (optional)
 values. The values are returned using the `OptionalValue&lt;T&gt;` struct which
 provides `HasValue` for testing if the value is available.
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.SeriesExtensions.FillMissing``2(Deedle.Series{``0,``1},System.Func{``0,``1})">
<summary>
 Fill missing values in the series using the specified function.
 The specified function is called with all keys for which the series
 does not contain value and the result of the call is used in place 
 of the missing value. 

 ## Parameters
  - `series` - An input series that is to be filled
  - `filler` - A function that takes key `K` and generates a value to be
    used in a place where the original series contains a missing value.

 ## Remarks
 This function can be used to implement more complex interpolation.
 For example see [handling missing values in the tutorial](../features.html#missing)

 [category:Missing values]
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.SeriesExtensions.FillMissing``2(Deedle.Series{``0,``1},Deedle.Direction)">
<summary>
 Fill missing values in the series with the nearest available value
 (using the specified direction). The default direction is `Direction.Backward`.
 Note that the series may still contain missing values after call to this 
 function. This operation can only be used on ordered series. 

 ## Example

     let sample = Series.ofValues [ Double.NaN; 1.0; Double.NaN; 3.0 ]

     // Returns a series consisting of [1; 1; 3; 3]
     sample.FillMissing(Direction.Backward)

     // Returns a series consisting of [&lt;missing&gt;; 1; 1; 3]
     sample.FillMissing(Direction.Forward)

 ## Parameters
  - `direction` - Specifies the direction used when searching for 
    the nearest available value. `Backward` means that we want to
    look for the first value with a smaller key while `Forward` searches
    for the nearest greater key.

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.FillMissing``2(Deedle.Series{``0,``1},``1)">
<summary>
 Fill missing values in the series with a constant value.

 ## Parameters
  - `series` - An input series that is to be filled
  - `value` - A constant value that is used to fill all missing values

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.SeriesExtensions.DropMissing``2(Deedle.Series{``0,``1})">
<summary>
 Drop missing values from the specified series. The returned series contains 
 only those keys for which there is a value available in the original one.

 ## Parameters
  - `series` - An input series to be filtered

 ## Example

     let s = series [ 1 =&gt; 1.0; 2 =&gt; Double.NaN ]
     s.DropMissing()
     [fsi:val it : Series&lt;int,float&gt; = series [ 1 =&gt; 1]

 [category:Missing values]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.SeriesExtensions.CountLevel``2(Deedle.Series{``0,System.Decimal},System.Func{``0,``1})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `groupSelector` and then returns a new series containing
 the counts of elements in each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the counts
  - `groupSelector` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Deedle.Deedle.Series`2.valueCount">
<summary>
 Lazy value to hold the number of elements (so that we do not recalculate this all the time)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.Series`2.op_Subtraction(Deedle.Series{`0,System.Double},Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Subtraction(Deedle.Series{`0,System.Int32},Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Subtraction(Deedle.Series{`0,System.Double},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Subtraction(System.Double,Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Subtraction(Deedle.Series{`0,System.Int32},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Subtraction(System.Int32,Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Multiply(Deedle.Series{`0,System.Double},Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Multiply(Deedle.Series{`0,System.Int32},Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Multiply(Deedle.Series{`0,System.Double},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Multiply(System.Double,Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Multiply(Deedle.Series{`0,System.Int32},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Multiply(System.Int32,Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Dynamic``1(Deedle.Series{System.String,``0},System.String)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Division(Deedle.Series{`0,System.Double},Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Division(Deedle.Series{`0,System.Int32},Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Division(Deedle.Series{`0,System.Double},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Division(System.Double,Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Division(Deedle.Series{`0,System.Int32},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Division(System.Int32,Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Addition(Deedle.Series{`0,System.Double},Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Addition(Deedle.Series{`0,System.Int32},Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Addition(Deedle.Series{`0,System.Double},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Addition(System.Double,Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Addition(Deedle.Series{`0,System.Int32},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.op_Addition(System.Int32,Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="P:Deedle.Series`2.VectorBuilder">
<summary>
 Returns the vector builder associated with this series
</summary>
</member>
<member name="">

</member>
<member name="P:Deedle.Series`2.Vector">
<summary>
 Returns the vector associated with this series. This member should not generally
 be accessed directly, because all functionality is exposed through series operations.

 [category:Series data]
</summary>
</member>
<member name="P:Deedle.Series`2.Values">
<summary>
 Returns a collection of values that are available in the series data.
 Note that the length of this sequence does not match the `Keys` sequence
 if there are missing values. To get matching sequence, use the `Observations`
 property or `Series.observation`.

 [category:Series data]
</summary>
</member>
<member name="P:Deedle.Series`2.ValueCount">
<summary>
 Returns the total number of values in the specified series. This excludes
 missing values or not available values (such as values created from `null`,
 `Double.NaN`, or those that are missing due to outer join etc.).

 [category:Series data]
</summary>
</member>
<member name="P:Deedle.Series`2.Observations">
<summary>
 Returns a collection of observations that form this series. Note that this property
 skips over all missing (or NaN) values. Observations are returned as `KeyValuePair&lt;K, V&gt;` 
 objects. For an F# alternative that uses tuples, see `Series.observations`.

 [category:Series data]
</summary>
</member>
<member name="P:Deedle.Series`2.Keys">
<summary>
 Returns a collection of keys that are defined by the index of this series.
 Note that the length of this sequence does not match the `Values` sequence
 if there are missing values. To get matching sequence, use the `Observations`
 property or `Series.observation`.

 [category:Series data]
</summary>
</member>
<member name="P:Deedle.Series`2.KeyRange">
<summary>
 [category:Series data]
</summary>
</member>
<member name="P:Deedle.Series`2.KeyCount">
<summary>
 Returns the total number of keys in the specified series. This returns
 the total length of the series, including keys for which there is no 
 value available.

 [category:Series data]
</summary>
</member>
<member name="P:Deedle.Series`2.Item(Deedle.ICustomLookup{`0})">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:Deedle.Series`2.Item(System.Collections.Generic.IEnumerable{`0})">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:Deedle.Series`2.Item(`0)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:Deedle.Series`2.IsOrdered">
<summary>
 [category:Series data]
</summary>
</member>
<member name="P:Deedle.Series`2.IsEmpty">
<summary>
 [category:Series data]
</summary>
</member>
<member name="P:Deedle.Series`2.IndexBuilder">
<summary>
 Returns the index builder associated with this series
</summary>
</member>
<member name="">

</member>
<member name="P:Deedle.Series`2.Index">
<summary>
 Returns the index associated with this series. This member should not generally
 be accessed directly, because all functionality is exposed through series operations.

 [category:Series data]
</summary>
</member>
<member name="M:Deedle.Series`2.ZipInner``1(Deedle.Series{`0,``0})">
<summary>
 [category:Appending, joining and zipping]
</summary>
</member>
<member name="M:Deedle.Series`2.Zip``1(Deedle.Series{`0,``0},Deedle.JoinKind,Deedle.Lookup)">
<summary>
 [category:Appending, joining and zipping]
</summary>
</member>
<member name="M:Deedle.Series`2.Zip``1(Deedle.Series{`0,``0},Deedle.JoinKind)">
<summary>
 [category:Appending, joining and zipping]
</summary>
</member>
<member name="M:Deedle.Series`2.Zip``1(Deedle.Series{`0,``0})">
<summary>
 [category:Appending, joining and zipping]
</summary>
</member>
<member name="M:Deedle.Series`2.WhereOptional(System.Func{System.Collections.Generic.KeyValuePair{`0,Deedle.OptionalValue{`1}},System.Boolean})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.Series`2.Where(System.Func{System.Collections.Generic.KeyValuePair{`0,`1},System.Boolean})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.Series`2.Where(System.Func{System.Collections.Generic.KeyValuePair{`0,`1},System.Int32,System.Boolean})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.Series`2.Union(Deedle.Series{`0,`1},Deedle.UnionBehavior)">
<summary>
 [category:Appending, joining and zipping]
</summary>
</member>
<member name="M:Deedle.Series`2.Union(Deedle.Series{`0,`1})">
<summary>
 [category:Appending, joining and zipping]
</summary>
</member>
<member name="M:Deedle.Series`2.TryGetObservation(`0)">
<summary>
 Attempts to get a value at the specified &apos;key&apos;

 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.TryGetObservation(`0,Deedle.Lookup)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.Series`2.TryGetAt(System.Int32)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.TryGet(`0)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.TryGet(`0,Deedle.Lookup)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.Truncate(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.Series`2.Tanh(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Tan(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.Series`2.Sqrt(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Sinh(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Sin(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Sign(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.SelectOptional``1(System.Func{System.Collections.Generic.KeyValuePair{`0,Deedle.OptionalValue{`1}},Deedle.OptionalValue{``0}})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.Series`2.SelectKeys``1(System.Func{System.Collections.Generic.KeyValuePair{`0,Deedle.OptionalValue{`1}},``0})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.Series`2.Select``1(System.Func{System.Collections.Generic.KeyValuePair{`0,`1},``0})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.Series`2.Select``1(System.Func{System.Collections.Generic.KeyValuePair{`0,`1},System.Int32,``0})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.Series`2.Round(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Resample(System.Collections.Generic.IEnumerable{`0},Deedle.Direction)">
<summary>
 Resample the series based on a provided collection of keys. The values of the series
 are aggregated into chunks based on the specified keys. Depending on `direction`, the 
 specified key is either used as the smallest or as the greatest key of the chunk (with
 the exception of boundaries that are added to the first/last chunk). The chunks
 are then returned as a nested series. 

 ## Parameters
  - `keys` - A collection of keys to be used for resampling of the series
  - `direction` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered.

 [category:Resampling]
</summary>
</member>
<member name="M:Deedle.Series`2.Resample``1(System.Collections.Generic.IEnumerable{`0},Deedle.Direction,System.Func{`0,Deedle.Series{`0,`1},``0})">
<summary>
 Resample the series based on a provided collection of keys. The values of the series
 are aggregated into chunks based on the specified keys. Depending on `direction`, the 
 specified key is either used as the smallest or as the greatest key of the chunk (with
 the exception of boundaries that are added to the first/last chunk).

 Such chunks are then aggregated using the provided `valueSelector` and `keySelector`
 (an overload that does not take `keySelector` just selects the explicitly provided key).

 ## Parameters
  - `keys` - A collection of keys to be used for resampling of the series
  - `direction` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.
  - `valueSelector` - A function that is used to collapse a generated chunk into a 
    single value. Note that this function may be called with empty series.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered.

 [category:Resampling]
</summary>
</member>
<member name="M:Deedle.Series`2.Resample``2(System.Collections.Generic.IEnumerable{`0},Deedle.Direction,System.Func{``0,Deedle.Series{`0,`1},``1},System.Func{`0,Deedle.Series{`0,`1},``0})">
<summary>
 Resample the series based on a provided collection of keys. The values of the series
 are aggregated into chunks based on the specified keys. Depending on `direction`, the 
 specified key is either used as the smallest or as the greatest key of the chunk (with
 the exception of boundaries that are added to the first/last chunk).

 Such chunks are then aggregated using the provided `valueSelector` and `keySelector`
 (an overload that does not take `keySelector` just selects the explicitly provided key).

 ## Parameters
  - `keys` - A collection of keys to be used for resampling of the series
  - `direction` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.
  - `valueSelector` - A function that is used to collapse a generated chunk into a 
    single value. Note that this function may be called with empty series.
  - `keySelector` - A function that is used to generate a new key for each chunk.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered.

 [category:Resampling]
</summary>
</member>
<member name="M:Deedle.Series`2.Realign(System.Collections.Generic.IEnumerable{`0})">
<summary>
 [category:Indexing]
</summary>
</member>
<member name="M:Deedle.Series`2.Pow(Deedle.Series{`0,System.Double},Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Pow(Deedle.Series{`0,System.Double},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Pow(System.Double,Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Pairwise">
<summary>
 Returns a series containing the predecessor and an element for each input, except
 for the first one. The returned series is one key shorter (it does not contain a 
 value for the first key).

 ## Parameters
  - `series` - The input series to be aggregated.

 ## Example

     let input = series [ 1 =&gt; &apos;a&apos;; 2 =&gt; &apos;b&apos;; 3 =&gt; &apos;c&apos;]
     let res = input.Pairwise()
     res = series [2 =&gt; (&apos;a&apos;, &apos;b&apos;); 3 =&gt; (&apos;b&apos;, &apos;c&apos;) ]

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.Series`2.Pairwise(Deedle.Boundary)">
<summary>
 Returns a series containing an element and its neighbor for each input.
 The returned series is one key shorter (it does not contain a 
 value for the first or last key depending on `boundary`). If `boundary` is 
 other than `Boundary.Skip`, then the key is included in the returned series, 
 but its value is missing.

 ## Parameters
  - `series` - The input series to be aggregated.
  - `boundary` - Specifies the direction in which the series is aggregated and 
    how the corner case is handled. If the value is `Boundary.AtEnding`, then the
    function returns value and its successor, otherwise it returns value and its
    predecessor.

 ## Example

     let input = series [ 1 =&gt; &apos;a&apos;; 2 =&gt; &apos;b&apos;; 3 =&gt; &apos;c&apos;]
     let res = input.Pairwise()
     res = series [2 =&gt; (&apos;a&apos;, &apos;b&apos;); 3 =&gt; (&apos;b&apos;, &apos;c&apos;) ]

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.Series`2.Log10(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Log(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.IndexWith``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 [category:Indexing]
</summary>
</member>
<member name="M:Deedle.Series`2.IndexOrdinally">
<summary>
 Replace the index of the series with ordinarilly generated integers starting from zero.
 The elements of the series are assigned index according to the current order, or in a
 non-deterministic way, if the current index is not ordered.

 [category:Indexing]
</summary>
</member>
<member name="M:Deedle.Series`2.GroupBy``2(System.Func{System.Collections.Generic.KeyValuePair{`0,`1},``0},System.Func{System.Collections.Generic.KeyValuePair{``0,Deedle.Series{`0,`1}},Deedle.OptionalValue{``1}})">
<summary>
 Groups a series (ordered or unordered) using the specified key selector (`keySelector`) 
 and then aggregates each group into a single value, returned in the resulting series,
 using the provided `valueSelector` function.

 ## Parameters
  - `keySelector` - Generates a new key that is used for aggregation, based on the original 
    key and value. The new key must support equality testing.
  - `valueSelector` - A value selector function that is called to aggregate 
    each group of collected elements.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.Series`2.GetSubrange(Microsoft.FSharp.Core.FSharpOption{System.Tuple{`0,Deedle.Indices.BoundaryBehavior}},Microsoft.FSharp.Core.FSharpOption{System.Tuple{`0,Deedle.Indices.BoundaryBehavior}})">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.GetSlice(Microsoft.FSharp.Core.FSharpOption{`0},Microsoft.FSharp.Core.FSharpOption{`0})">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.GetObservation(`0)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.GetObservation(`0,Deedle.Lookup)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.GetKeyAt(System.Int32)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.GetItems(System.Collections.Generic.IEnumerable{`0},Deedle.Lookup)">
<summary>
 Returns a new series with an index containing the specified keys.
 When the key is not found in the current series, the newly returned
 series will contain a missing value. When the second parameter is not
 specified, the keys have to exactly match the keys in the current series
 (`Lookup.Exact`).

 ## Parameters

  * `keys` - A collection of keys in the current series.
  * `lookup` - Specifies the lookup behavior when searching for keys in 
    the current series. `Lookup.NearestGreater` and `Lookup.NearestSmaller`
    can be used when the current series is ordered.

 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.GetItems(System.Collections.Generic.IEnumerable{`0})">
<summary>
 Returns a new series with an index containing the specified keys.
 When the key is not found in the current series, the newly returned
 series will contain a missing value. When the second parameter is not
 specified, the keys have to exactly match the keys in the current series
 (`Lookup.Exact`).

 ## Parameters

  * `keys` - A collection of keys in the current series.

 [category:Accessors and slicing]
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.Series`2.GetByLevel(Deedle.ICustomLookup{`0})">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.GetAt(System.Int32)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.Get(`0)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:Deedle.Series`2.Get(`0,Deedle.Lookup)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.Series`2.Format">
<summary>
 Shows the data frame content in a human-readable format. The resulting string
 shows all columns, but a limited number of rows. The property is used 
 automatically by F# Interactive.
</summary>
</member>
<member name="M:Deedle.Series`2.Floor(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Exp(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.Series`2.Cosh(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Cos(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Ceiling(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.Series`2.Atan(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.Series`2.Asin(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Append(Deedle.Series{`0,`1})">
<summary>
 [category:Appending, joining and zipping]
</summary>
</member>
<member name="M:Deedle.Series`2.Aggregate``2(Deedle.Aggregation{`0},System.Func{Deedle.DataSegment{Deedle.Series{`0,`1}},System.Collections.Generic.KeyValuePair{``0,Deedle.OptionalValue{``1}}})">
<summary>
 Aggregates an ordered series using the method specified by `Aggregation&lt;K&gt;` and then
 applies the provided `observationSelector` on each window or chunk to produce the result
 which is returned as a new series. The selector returns both the key and the value.

 ## Parameters
  - `aggregation` - Specifies the aggregation method using `Aggregation&lt;K&gt;`. This is
    a discriminated union listing various chunking and windowing conditions.
  - `observationSelector` - A function that is called on each chunk to obtain a key and a value.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.Series`2.Aggregate``2(Deedle.Aggregation{`0},System.Func{Deedle.DataSegment{Deedle.Series{`0,`1}},``0},System.Func{Deedle.DataSegment{Deedle.Series{`0,`1}},Deedle.OptionalValue{``1}})">
<summary>
 Aggregates an ordered series using the method specified by `Aggregation&lt;K&gt;` and then
 applies the provided `valueSelector` on each window or chunk to produce the result
 which is returned as a new series. A key for each window or chunk is
 selected using the specified `keySelector`.

 ## Parameters
  - `aggregation` - Specifies the aggregation method using `Aggregation&lt;K&gt;`. This is
    a discriminated union listing various chunking and windowing conditions.
  - `keySelector` - A function that is called on each chunk to obtain a key.
  - `valueSelector` - A value selector function that is called to aggregate each chunk or window.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.Series`2.Acos(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Abs(Deedle.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:Deedle.Series`2.Abs(Deedle.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.Series`2">
<summary>
 The type `Series&lt;K, V&gt;` represents a data series consisting of values `V` indexed by
 keys `K`. The keys of a series may or may not be ordered 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Deedle.TryValue`1.Value">
<summary>
 Returns the value of `TryValue&lt;T&gt;` when the value is present; 
 otherwise, throws an exception that was captured
</summary>
</member>
<member name="P:Deedle.TryValue`1.HasValue">
<summary>
 Returns `true` when the `TryValue&lt;T&gt;` object represents a 
 successfully calculated value 
</summary>
</member>
<member name="P:Deedle.TryValue`1.Exception">
<summary>
 Returns the exception captured by this value. When `HasValue = true`, 
 accessing the property throws `InvalidOperationException`.
</summary>
</member>
<member name="M:Deedle.TryValue`1.ToString">
<summary>
 Returns the string representation of the underlying value or `&lt;error&gt;`
</summary>
</member>
<member name="T:Deedle.TryValue`1">
<summary>
 Represents a value or an exception. This type is used by functions such as
 `Series.tryMap` and `Frame.tryMap` to capture the result of a lambda function,
 which may be either a value or an exception. The type is a discriminated union,
 so it can be processed using F# pattern matching, or using `Value`, `HasValue`
 and `Exception` properties
</summary>
</member>
<member name="F:Deedle.UnionBehavior.Exclusive">
<summary>
 When there are values available in both series that are being unioned, raise an exception.
</summary>
</member>
<member name="F:Deedle.UnionBehavior.PreferRight">
<summary>
 When there are values available in both series that are being unioned, prefer the right value.
</summary>
</member>
<member name="F:Deedle.UnionBehavior.PreferLeft">
<summary>
 When there are values available in both series that are being unioned, prefer the left value.
</summary>
</member>
<member name="">

</member>
<member name="T:Deedle.UnionBehavior">
<summary>
 This enumeration specifeis the behavior of `Union` operation on series when there are
 overlapping keys in two series that are being unioned. The options include prefering values
 from the left/right series or throwing an exception when both values are available.
</summary>
</member>
<member name="T:Deedle.opt`1">
<summary>
 A type alias for the `OptionalValue&lt;T&gt;` type. The type alias can be used
 to make F# type definitions that use optional values directly more succinct.
</summary>
</member>
<member name="T:Deedle.tryval`1">
<summary>
 A type alias for the `TryValue&lt;T&gt;` type. The type alias can be used
 to make F# type declarations that explcitly handle exceptions more succinct.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.Addressing.|IntAddress|(Deedle.Addressing.Address)">
<summary>
 ArrayVectors assume that the address is an integer
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.Addressing.AddressModule">

</member>
<member name="T:Deedle.Addressing">
<summary>
 An `Address` value is used as an interface between vectors and indices. The index maps
 keys of various types to address, which is then used to get a value from the vector.
 
 ## Details

 In the most common case, the address will be `int` (and can represent index in an array),
 but it is possible to imagine other addresses - `int64` could be used with arrays of 
 arrays (to handle very large data). A lazily loaded vector might use something completely
 different (perhaps a date?). In principle this should be generic, but that is hard to do - 
 we want something like:

     Series.Create : \forall &apos;TKey, &apos;TValue. \exists &apos;TAddress. 
       Index&lt;&apos;TKey, &apos;TAddress&gt; * Vector&lt;&apos;TAddress, &apos;TValue&gt; -&gt; Series&lt;&apos;TKey, &apos;TValue&gt;

 The .NET encoding of this is a bit ugly. So instead, we just have `Address` which currently
 supports `Int` and `Int64`, but we keep all operations in the `Address` module, so that
 this can be easily extended.
</summary>
</member>
<member name="M:Deedle.DataSegment.GetKind``1(Deedle.DataSegment{``0})">
<summary>
 Returns the kind property of the specified `DataSegment&lt;T&gt;`
</summary>
</member>
<member name="M:Deedle.DataSegment.GetData``1(Deedle.DataSegment{``0})">
<summary>
 Returns the data property of the specified `DataSegment&lt;T&gt;`
</summary>
</member>
<member name="M:Deedle.DataSegment.|Complete|Incomplete|``1(Deedle.DataSegment{``0})">
<summary>
 Complete active pattern that makes it possible to write functions that behave 
 differently for complete and incomplete segments. For example, the following 
 returns zero for incomplete segments:

     let sumSegmentOrZero = function
       | DataSegment.Complete(value) -&gt; Series.sum value
       | DataSegment.Incomplete _ -&gt; 0.0

</summary>
</member>
<member name="M:Deedle.DataSegment.|Any|``1(Deedle.DataSegment{``0})">
<summary>
 A complete active pattern that extracts the kind and data from a `DataSegment`
 value. This makes it easier to write functions that only need data:

    let sumAny = function DataSegment.Any(_, data) -&gt; Series.sum data

</summary>
</member>
<member name="T:Deedle.DataSegment">
<summary>
 Provides helper functions and active patterns for working with `DataSegment` values
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.Delayed.DelayedIndexBuilder">
<summary>
 Delayed index builder - this is where interesting things happen. Most operations
 are still delegated to LinearIndexBuilder, but the `GetRange` method looks at the
 index and if it is DelayedIndex, then it uses the `Source` to build a new `Source`
 with a restricted range.
</summary>
</member>
<member name="">

</member>
<member name="T:Deedle.Delayed.DelayedIndexFunction`2">
<summary>
 A polymorphic function that is passed to IDelayedIndex.Invoke
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.Delayed.IDelayedIndex`1">
<summary>
 In the DelayedIndexBuilder, we do not know the type of values, so this 
 is a less generic interface that gives us a way for accessing it...
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.Delayed.DelayedIndex`2">
<summary>
 Delayed index that is lnked to a DelayedSource specified during construction
 (This simply delegates all operations to the &apos;source.Keys&apos; index)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.Delayed.DelayedVector`2">
<summary>
 A delayed vector that is linked to a DelayedSource specified during construction
 (This simply delegates all operations to the &apos;source.Values&apos; vector)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.Delayed.DelayedSource`2">
<summary>
 This type represents data source for constructing delayed series. To construct
 a delayed series, use `DelayedSeries.Create` (this creates index and vector 
 linked to this `DelayedSource`).

 The function `loader` is called outside of the `async` (on the calling thread)
 but the returned async computations are invoked on background thread.
</summary>
</member>
<member name="T:Deedle.Delayed.DelayedSourceData`2">
<summary>
 Result that should be returned in response to `DelayedSourceRanges` request
</summary>
</member>
<member name="T:Deedle.Delayed.DelayedSourceRanges`1">
<summary>
 Specifies the ranges for which data need to be provided
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.Delayed.Ranges.flattenRanges``1(``0,``0,System.Collections.Generic.IComparer{``0},Deedle.Delayed.Ranges.Ranges{``0})">
<summary>
 Returns an ordered sequence of exclusive ranges
</summary>
</member>
<member name="M:Deedle.Delayed.Ranges.contains``1(System.Collections.Generic.IComparer{``0},``0,Deedle.Delayed.Ranges.Ranges{``0})">
<summary>
 Test if a range contains the specified value
</summary>
</member>
<member name="M:Deedle.Delayed.Ranges.containsSub``1(System.Collections.Generic.IComparer{``0},``0,``0,Deedle.Delayed.Ranges.Ranges{``0})">
<summary>
 Test if a range contains the specified sub-range
 (the function assumes that the sub-range is smaller than any range in the input)
</summary>
</member>
<member name="">

</member>
<member name="T:Deedle.Delayed.Ranges">
<summary>
 Module that contains functions for working with ranges - most importantly
 it handles flattening of trees constructed by unioning &amp; intersecting ranges
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.FSharpFrameExtensions.Frame`2.SaveCsv``2(Deedle.Frame{``0,``1},System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Save data frame to a CSV file or to a `Stream`. When calling the operation,
 you can specify whether you want to save the row keys or not (and headers for the keys)
 and you can also specify the separator (use `\t` for writing TSV files). When specifying
 file name ending with `.tsv`, the `\t` separator is used automatically.

 ## Parameters
  - `path` - Specifies the output file name where the CSV data should be written
  - `keyNames` - Specifies the CSV headers for row key (or keys, for multi-level index)
  - `separator` - Specify the column separator in the file (the default is `\t` for 
    TSV files and `,` for CSV files)
  - `culture` - Specify the `CultureInfo` object used for formatting numerical data

 [category:Input and output]
</summary>
</member>
<member name="M:Deedle.FSharpFrameExtensions.Frame`2.SaveCsv``2(Deedle.Frame{``0,``1},System.String,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.String}},Microsoft.FSharp.Core.FSharpOption{System.Char},Microsoft.FSharp.Core.FSharpOption{System.Globalization.CultureInfo})">
<summary>
 Save data frame to a CSV file or to a `Stream`. When calling the operation,
 you can specify whether you want to save the row keys or not (and headers for the keys)
 and you can also specify the separator (use `\t` for writing TSV files). When specifying
 file name ending with `.tsv`, the `\t` separator is used automatically.

 ## Parameters
  - `path` - Specifies the output file name where the CSV data should be written
  - `includeRowKeys` - When set to `true`, the row key is also written to the output file
  - `keyNames` - Can be used to specify the CSV headers for row key (or keys, for multi-level index)
  - `separator` - Specify the column separator in the file (the default is `\t` for 
    TSV files and `,` for CSV files)
  - `culture` - Specify the `CultureInfo` object used for formatting numerical data

 [category:Input and output]
</summary>
</member>
<member name="M:Deedle.FSharpFrameExtensions.Frame`2.SaveCsv``2(Deedle.Frame{``0,``1},System.IO.Stream,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.String}},Microsoft.FSharp.Core.FSharpOption{System.Char},Microsoft.FSharp.Core.FSharpOption{System.Globalization.CultureInfo})">
<summary>
 Save data frame to a CSV file or to a `Stream`. When calling the operation,
 you can specify whether you want to save the row keys or not (and headers for the keys)
 and you can also specify the separator (use `\t` for writing TSV files). When specifying
 file name ending with `.tsv`, the `\t` separator is used automatically.

 ## Parameters
  - `stream` - Specifies the output stream where the CSV data should be written
  - `includeRowKeys` - When set to `true`, the row key is also written to the output file
  - `keyNames` - Can be used to specify the CSV headers for row key (or keys, for multi-level index)
  - `separator` - Specify the column separator in the file (the default is `\t` for 
    TSV files and `,` for CSV files)
  - `culture` - Specify the `CultureInfo` object used for formatting numerical data

 [category:Input and output]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.FSharpFrameExtensions.Frame.ofRowsOrdinal.Static``3(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a data frame with ordinal Integer index from a sequence of rows.
 The column indices of individual rows are unioned, so if a row has fewer
 columns, it will be successfully added, but there will be missing values.
</summary>
</member>
<member name="M:Deedle.FSharpFrameExtensions.Frame.ReadCsv.Static(System.IO.Stream,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Load data frame from a CSV file. The operation automatically reads column names from the 
 CSV file (if they are present) and infers the type of values for each column. Columns
 of primitive types (`int`, `float`, etc.) are converted to the right type. Columns of other
 types (such as dates) are not converted automatically.

 ## Parameters

  * `stream` - Specifies the input stream, opened at the beginning of CSV data
  * `hasHeaders` - Specifies whether the input CSV file has header row
  * `inferTypes` - Specifies whether the method should attempt to infer types
    of columns automatically (set this to `false` if you want to specify schema)
  * `inferRows` - If `inferTypes=true`, this parameter specifies the number of
    rows to use for type inference. The default value is 0, meaninig all rows.
  * `schema` - A string that specifies CSV schema. See the documentation for 
    information about the schema format.
  * `separators` - A string that specifies one or more (single character) separators
    that are used to separate columns in the CSV file. Use for example `&quot;;&quot;` to 
    parse semicolon separated files.
  * `culture` - Specifies the name of the culture that is used when parsing 
    values in the CSV file (such as `&quot;en-US&quot;`). The default is invariant culture. 
</summary>
</member>
<member name="M:Deedle.FSharpFrameExtensions.Frame.ReadCsv.Static(System.String,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Load data frame from a CSV file. The operation automatically reads column names from the 
 CSV file (if they are present) and infers the type of values for each column. Columns
 of primitive types (`int`, `float`, etc.) are converted to the right type. Columns of other
 types (such as dates) are not converted automatically.

 ## Parameters

  * `path` - Specifies a file name or an web location of the resource.
  * `hasHeaders` - Specifies whether the input CSV file has header row
  * `inferTypes` - Specifies whether the method should attempt to infer types
    of columns automatically (set this to `false` if you want to specify schema)
  * `inferRows` - If `inferTypes=true`, this parameter specifies the number of
    rows to use for type inference. The default value is 0, meaninig all rows.
  * `schema` - A string that specifies CSV schema. See the documentation for 
    information about the schema format.
  * `separators` - A string that specifies one or more (single character) separators
    that are used to separate columns in the CSV file. Use for example `&quot;;&quot;` to 
    parse semicolon separated files.
  * `culture` - Specifies the name of the culture that is used when parsing 
    values in the CSV file (such as `&quot;en-US&quot;`). The default is invariant culture. 
</summary>
</member>
<member name="M:Deedle.FSharpFrameExtensions.frame``3(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 A function for constructing data frame from a sequence of name - column pairs.
 This provides a nicer syntactic sugar for `Frame.ofColumns`.

 ## Example
 To create a simple frame with two columns, you can write:
 
     frame [ &quot;A&quot; =&gt; series [ 1 =&gt; 30.0; 2 =&gt; 35.0 ]
             &quot;B&quot; =&gt; series [ 1 =&gt; 30.0; 3 =&gt; 40.0 ] ]

</summary>
</member>
<member name="M:Deedle.FSharpFrameExtensions.op_Dollar``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``2,``0})">
<summary>
 Custom operator that can be used for applying fuction to all elements of 
 a series. This provides a nicer syntactic sugar for the `Series.mapValues` 
 function. For example:

     // Given a float series and a function on floats
     let s1 = Series.ofValues [ 1.0 .. 10.0 ]
     let adjust v = max 10.0 v

     // Apply &quot;adjust (v + v)&quot; to all elements
     adjust $ (s1 + s1)

</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.FSharpFrameExtensions.op_EqualsGreater``2(``0,``1)">
<summary>
 Custom operator that can be used when constructing series from observations
 or frames from key-row or key-column pairs. The operator simply returns a 
 tuple, but it provides a more convenient syntax. For example:

     series [ &quot;k1&quot; =&gt; 1; &quot;k2&quot; =&gt; 15 ]

</summary>
</member>
<member name="T:Deedle.FSharpFrameExtensions">

</member>
<member name="M:Deedle.FSharpIndexExtensions.Index.ofUnorderedKeys``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Create an index from a sequence of keys and assume they are not sorted
 (the resulting index is also not sorted).
</summary>
</member>
<member name="M:Deedle.FSharpIndexExtensions.Index.ofKeys``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Create an index from a sequence of keys and check if they are sorted or not
</summary>
</member>
<member name="T:Deedle.FSharpIndexExtensions.Index">
<summary>
 Type that provides a simple access to creating indices represented
 using the built-in `LinearVector` type.
</summary>
</member>
<member name="T:Deedle.FSharpIndexExtensions">
<summary>
 Defines non-generic `Index` type that provides functions for building indices
 (hard-bound to `LinearIndexBuilder` type). In F#, the module is automatically opened
 using `AutoOpen`. The methods are not designed for the use from C#.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.FSharpSeriesExtensions">

</member>
<member name="M:Deedle.FSharpVectorExtensions.Vector.ofValues``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a vector that stores the specified data in an array.
 Values such as `null` and `Double.NaN` are turned into missing values.
</summary>
</member>
<member name="M:Deedle.FSharpVectorExtensions.Vector.ofValues``1(``0[])">
<summary>
 Creates a vector that stores the specified data in an array.
 Values such as `null` and `Double.NaN` are turned into missing values.
</summary>
</member>
<member name="M:Deedle.FSharpVectorExtensions.Vector.ofOptionalValues``1(System.Collections.Generic.IEnumerable{Deedle.OptionalValue{``0}})">
<summary>
 Missing values can be specified explicitly as `OptionalValue.Missing`, but 
 other values such as `null` and `Double.NaN` are turned into missing values too.
</summary>
</member>
<member name="M:Deedle.FSharpVectorExtensions.Vector.ofOptionalValues``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Creates a vector that stores the specified data in an array.
 Missing values can be specified explicitly as `None`, but other values 
 such as `null` and `Double.NaN` are turned into missing values too.
</summary>
</member>
<member name="T:Deedle.FSharpVectorExtensions.Vector">
<summary>
 Type that provides a simple access to creating vectors represented
 using the built-in `ArrayVector` type that stores the data in a 
 continuous block of memory.
</summary>
</member>
<member name="T:Deedle.FSharpVectorExtensions">
<summary>
 Defines non-generic `Vector` type that provides functions for building vectors
 (hard-bound to `ArrayVectorBuilder` type). In F#, the module is automatically opened
 using `AutoOpen`. The methods are not designed for the use from C#.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.FrameBuilder">

</member>
<member name="">

</member>
<member name="M:Deedle.FrameModule.stack``2(Deedle.Frame{``0,``1})">
<summary>
 Implements R-like &apos;stack&apos; (returns frame whose 
 columns are named Row/Column/Value)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.FrameModule.ZipInto``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Deedle.Frame{``3,``4},Deedle.Frame{``3,``4})">
<summary>
 Aligns two data frames using both column index and row index and apply the specified operation
 on values of a specified type that are available in both data frames. This overload uses
 `JoinKind.Outer` for both columns and rows.

 Once aligned, the call `df1.Zip&lt;T&gt;(df2, f)` applies the specifed function `f` on all `T` values
 that are available in corresponding locations in both frames. For values of other types, the 
 value from `df1` is returned.

 ## Parameters
  - `frame1` - First frame to be aligned and zipped with the other instance
  - `frame2` - Other frame to be aligned and zipped with the first  instance
  - `columnKind` - Specifies how to align columns (inner, outer, left or right join)
  - `rowKind` - Specifies how to align rows (inner, outer, left or right join)
  - `lookup` - Specifies how to find matching value for a row (when using left or right join on rows)
  - `op` - A function that is applied to aligned values. The `Zip` operation is generic
    in the type of this function and the type of function is used to determine which 
    values in the frames are zipped and which are left unchanged.

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.FrameModule.ZipAlignInto``5(Deedle.JoinKind,Deedle.JoinKind,Deedle.Lookup,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Deedle.Frame{``3,``4},Deedle.Frame{``3,``4})">
<summary>
 Aligns two data frames using both column index and row index and apply the specified operation
 on values of a specified type that are available in both data frames. The parameters `columnKind`,
 and `rowKind` can be specified to determine how the alginment works (similarly to `Join`).
 Column keys are always matched using `Lookup.Exact`, but `lookup` determines lookup for rows.

 Once aligned, the call `df1.Zip&lt;T&gt;(df2, f)` applies the specifed function `f` on all `T` values
 that are available in corresponding locations in both frames. For values of other types, the 
 value from `df1` is returned.

 ## Parameters
  - `frame1` - First frame to be aligned and zipped with the other instance
  - `frame2` - Other frame to be aligned and zipped with the first  instance
  - `columnKind` - Specifies how to align columns (inner, outer, left or right join)
  - `rowKind` - Specifies how to align rows (inner, outer, left or right join)
  - `lookup` - Specifies how to find matching value for a row (when using left or right join on rows)
  - `op` - A function that is applied to aligned values. The `Zip` operation is generic
    in the type of this function and the type of function is used to determine which 
    values in the frames are zipped and which are left unchanged.

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.FrameModule.Append``2(Deedle.Frame{``0,``1},Deedle.Frame{``0,``1})">
<summary>
 Append two data frames with non-overlapping values. The operation takes the union of columns
 and rows of the source data frames and then unions the values. An exception is thrown when 
 both data frames define value for a column/row location, but the operation succeeds if one
 frame has a missing value at the location.

 Note that the rows are *not* automatically reindexed to avoid overlaps. This means that when
 a frame has rows indexed with ordinal numbers, you may need to explicitly reindex the row
 keys before calling append.

 ## Parameters
  - `otherFrame` - The other frame to be appended (combined) with the current instance

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.FrameModule.JoinAlign``2(Deedle.JoinKind,Deedle.Lookup,Deedle.Frame{``0,``1},Deedle.Frame{``0,``1})">
<summary>
 Join two data frames. The columns of the joined frames must not overlap and their
 rows are aligned and transformed according to the specified join kind.
 When the index of both frames is ordered, it is possible to specify `lookup` 
 in order to align indices from other frame to the indices of the main frame
 (typically, to find the nearest key with available value for a key).

 ## Parameters
  - `frame1` - First data frame (left) to be used in the joining
  - `frame2` - Other frame (right) to be joined with `frame1`
  - `kind` - Specifies the joining behavior on row indices. Use `JoinKind.Outer` and 
    `JoinKind.Inner` to get the union and intersection of the row keys, respectively.
    Use `JoinKind.Left` and `JoinKind.Right` to use the current key of the left/right
    data frame.
  - `lookup` - When `kind` is `Left` or `Right` and the two frames have ordered row index,
    this parameter can be used to specify how to find value for a key when there is no
    exactly matching key or when there are missing values.

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.FrameModule.Join``2(Deedle.JoinKind,Deedle.Frame{``0,``1},Deedle.Frame{``0,``1})">
<summary>
 Join two data frames. The columns of the joined frames must not overlap and their
 rows are aligned and transformed according to the specified join kind.
 For more alignment options on ordered frames, see `joinAlign`.

 ## Parameters
  - `frame1` - First data frame (left) to be used in the joining
  - `frame2` - Other frame (right) to be joined with `frame1`
  - `kind` - Specifies the joining behavior on row indices. Use `JoinKind.Outer` and 
    `JoinKind.Inner` to get the union and intersection of the row keys, respectively.
    Use `JoinKind.Left` and `JoinKind.Right` to use the current key of the left/right
    data frame.

 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.FrameModule.RowsDense``2(Deedle.Frame{``0,``1})">
<summary>
 Returns the rows of the data frame that do not have any missing values. 
 The operation returns a series (indexed by the row keys of the source frame) 
 containing _series_ representing individual row of the frame. This is similar 
 to `Rows`, but it skips rows that contain missing value in _any_ column.

 ## Parameters
  - `frame` - An input data frame containing rows to be filtered

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.FrameModule.ColumnsDense``2(Deedle.Frame{``0,``1})">
<summary>
 Returns the columns of the data frame that do not have any missing values.
 The operation returns a series (indexed by the column keys of the source frame) 
 containing _series_ representing individual columns of the frame. This is similar 
 to `Columns`, but it skips columns that contain missing value in _any_ row.

 ## Parameters
  - `frame` - An input data frame containing columns to be filtered

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.FrameModule.DropSparseColumns``2(Deedle.Frame{``0,``1})">
<summary>
 Creates a new data frame that contains only those columns of the original 
 data frame that are _dense_, meaning that they have a value for each row.
 The resulting data frame has the same number of rows, but may have 
 fewer columns (or no columns at all).

 ## Parameters
  - `frame` - An input data frame that is to be filtered

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.FrameModule.DropSparseRows``2(Deedle.Frame{``0,``1})">
<summary>
 Creates a new data frame that contains only those rows of the original 
 data frame that are _dense_, meaning that they have a value for each column.
 The resulting data frame has the same number of columns, but may have 
 fewer rows (or no rows at all).
 
 ## Parameters
  - `frame` - An input data frame that is to be filtered

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.FrameModule.FillMissingUsing``3(Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Deedle.Frame{``0,``2})">
<summary>
 Fill missing values in the frame using the specified function. The specified
 function is called with all series and keys for which the frame does not 
 contain value and the result of the call is used in place of the missing value.

 The operation is only applied to columns (series) that contain values of the
 same type as the return type of the provided filling function. The operation 
 does not attempt to convert between numeric values (so a series containing 
 `float` will not be converted to a series of `int`).

 ## Parameters
  - `frame` - An input data frame that is to be filled
  - `f` - A function that takes a series `Series&lt;R, T&gt;` together with a key `K` 
    in the series and generates a value to be used in a place where the original 
    series contains a missing value.

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.FrameModule.FillMissing``2(Deedle.Direction,Deedle.Frame{``0,``1})">
<summary>
 Fill missing values in the data frame with the nearest available value
 (using the specified direction). Note that the frame may still contain
 missing values after call to this function (e.g. if the first value is not available
 and we attempt to fill series with previous values). This operation can only be
 used on ordered frames.

 ## Parameters
  - `frame` - An input data frame that is to be filled
  - `direction` - Specifies the direction used when searching for 
    the nearest available value. `Backward` means that we want to
    look for the first value with a smaller key while `Forward` searches
    for the nearest greater key.

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.FrameModule.FillMissingWith``3(``0,Deedle.Frame{``1,``2})">
<summary>
 Fill missing values of a given type in the frame with a constant value.
 The operation is only applied to columns (series) that contain values of the
 same type as the provided filling value. The operation does not attempt to 
 convert between numeric values (so a series containing `float` will not be
 converted to a series of `int`).

 ## Parameters
  - `frame` - An input data frame that is to be filled
  - `value` - A constant value that is used to fill all missing values

 [category:Missing values]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.FrameModule.tryValues``2(Deedle.Frame{``0,``1})">
<summary>
 Unwraps TryValues into regular values.
 Throws `AggregateException` if any TryValues are Failures
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.FrameModule.SelectColumnKeys``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Frame{``2,``0})">
<summary>
 Builds a new data frame whose column keys are the results of applying the
 specified function on the column keys of the original data frame.

 ## Parameters
  - `frame` - Input data frame to be transformed
  - `f` - Function of one argument that defines the column key mapping

 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.FrameModule.SelectColumnValues``4(Microsoft.FSharp.Core.FSharpFunc{Deedle.ObjectSeries{``0},``1},Deedle.Frame{``0,``3})">
<summary>
 Builds a new data frame whose columns are the results of applying the specified
 function on the columns of the input data frame. The function is called
 with an object series that represents the column data (use `mapCols`
 if you need to access the column key).

 ## Parameters
  - `frame` - Input data frame to be transformed
  - `f` - Function of one argument that defines the column mapping

 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.FrameModule.SelectColumns``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Deedle.ObjectSeries{``1},``2}},Deedle.Frame{``1,``0})">
<summary>
 Builds a new data frame whose columns are the results of applying the specified
 function on the columns of the input data frame. The function is called
 with the column key and object series that represents the column data.

 ## Parameters
  - `frame` - Input data frame to be transformed
  - `f` - Function of two arguments that defines the column mapping

 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.FrameModule.WhereColumnValues``2(Microsoft.FSharp.Core.FSharpFunc{Deedle.ObjectSeries{``0},System.Boolean},Deedle.Frame{``0,``1})">
<summary>
 Returns a new data frame containing only the columns of the input frame
 for which the specified predicate returns `true`. The predicate is called
 with an object series that represents the column data (use `filterCols`
 if you need to access the column key).

 ## Parameters
  - `frame` - Input data frame to be transformed
  - `f` - Function of one argument that defines the predicate

 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.FrameModule.WhereColumns``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Deedle.ObjectSeries{``1},System.Boolean}},Deedle.Frame{``1,``0})">
<summary>
 Returns a new data frame containing only the columns of the input frame
 for which the specified predicate returns `true`. The predicate is called
 with the column key and object series that represents the column data.

 ## Parameters
  - `frame` - Input data frame to be transformed
  - `f` - Function of two arguments that defines the predicate

 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.FrameModule.SelectRowKeys``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Frame{``0,``2})">
<summary>
 Builds a new data frame whose row keys are the results of applying the
 specified function on the row keys of the original data frame.

 ## Parameters
  - `frame` - Input data frame to be transformed
  - `f` - Function of one argument that defines the row key mapping

 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.FrameModule.SelectRowValues``3(Microsoft.FSharp.Core.FSharpFunc{Deedle.ObjectSeries{``0},``1},Deedle.Frame{``2,``0})">
<summary>
 Builds a new data frame whose rows are the results of applying the specified
 function on the rows of the input data frame. The function is called
 with an object series that represents the row data (use `mapRows`
 if you need to access the row key).

 ## Parameters
  - `frame` - Input data frame to be transformed
  - `f` - Function of one argument that defines the row mapping

 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.FrameModule.SelectRows``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Deedle.ObjectSeries{``1},``2}},Deedle.Frame{``0,``1})">
<summary>
 Builds a new data frame whose rows are the results of applying the specified
 function on the rows of the input data frame. The function is called
 with the row key and object series that represents the row data.

 ## Parameters
  - `frame` - Input data frame to be transformed
  - `f` - Function of two arguments that defines the row mapping

 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.FrameModule.WhereRowValues``2(Microsoft.FSharp.Core.FSharpFunc{Deedle.ObjectSeries{``0},System.Boolean},Deedle.Frame{``1,``0})">
<summary>
 Returns a new data frame containing only the rows of the input frame
 for which the specified predicate returns `true`. The predicate is called
 with an object series that represents the row data (use `filterRows`
 if you need to access the row key).

 ## Parameters
  - `frame` - Input data frame to be transformed
  - `f` - Function of one argument that defines the predicate

 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.FrameModule.WhereRows``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Deedle.ObjectSeries{``1},System.Boolean}},Deedle.Frame{``0,``1})">
<summary>
 Returns a new data frame containing only the rows of the input frame
 for which the specified predicate returns `true`. The predicate is called
 with the row key and object series that represents the row data.

 ## Parameters
  - `frame` - Input data frame to be transformed
  - `f` - Function of two arguments that defines the predicate

 [category:Projection and filtering]
</summary>
</member>
<member name="M:Deedle.FrameModule.ExpandColumns``1(System.Collections.Generic.IEnumerable{System.String},Deedle.Frame{``0,System.String})">
<summary>
 Creates a new data frame where the specified columns are expanded based on runtime
 structure of the objects they store. A column can be expanded if it is 
 `Series&lt;string, T&gt;` or `IDictionary&lt;K, V&gt;` or if it is any .NET object with readable
 properties. 

 ## Example
 Given a data frame with a series that contains tuples, you can expand the
 tuple members and get a frame with columns `S.Item1` and `S.Item2`:
 
     let df = frame [ &quot;S&quot; =&gt; series [ 1 =&gt; (1, &quot;One&quot;); 2 =&gt; (2, &quot;Two&quot;) ] ]  
     df |&gt; Frame.expandCols [&quot;S&quot;]

 ## Parameters
  - `names` - Names of columns in the original data frame to be expanded
  - `frame` - Input data frame whose columns will be expanded

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.expandAllCols``1(System.Int32,Deedle.Frame{``0,System.String})">
<summary>
 Creates a new data frame where all columns are expanded based on runtime
 structure of the objects they store. The expansion is performed recrusively
 to the specified depth. A column can be expanded if it is `Series&lt;string, T&gt;` 
 or `IDictionary&lt;K, V&gt;` or if it is any .NET object with readable
 properties. 

 ## Parameters
  - `nesting` - The nesting level for expansion. When set to 0, nothing is done.
  - `frame` - Input data frame whose columns will be expanded

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.OrderColumns``2(Deedle.Frame{``0,``1})">
<summary>
 Returns a data frame that contains the same data as the input, 
 but whose columns are an ordered series. This allows using operations that are
 only available on indexed series such as alignment and inexact lookup.

 ## Parameters
  - `frame` - Source data frame to be ordered.
 
 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.OrderRows``2(Deedle.Frame{``0,``1})">
<summary>
 Returns a data frame that contains the same data as the input, 
 but whose rows are an ordered series. This allows using operations that are
 only available on indexed series such as alignment and inexact lookup.

 ## Parameters
  - `frame` - Source data frame to be ordered.
 
 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.Transpose``2(Deedle.Frame{``0,``1})">
<summary>
 Returns a transposed data frame. The rows of the original data frame are used as the
 columns of the new one (and vice versa). Use this operation if you have a data frame
 and you mostly need to access its rows as a series (because accessing columns as a 
 series is more efficient).
 
 ## Parameters
  - `frame` - Source data frame to be transposed.
 
 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.IndexRowsWith``3(System.Collections.Generic.IEnumerable{``0},Deedle.Frame{``1,``2})">
<summary>
 Replace the row index of the frame with the provided sequence of row keys.
 The rows of the frame are assigned keys according to the current order, or in a
 non-deterministic way, if the current row index is not ordered.

 ## Parameters
  - `frame` - Source data frame whose row index are to be replaced.
  - `keys` - A collection of new row keys.

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.IndexColumnsWith``3(System.Collections.Generic.IEnumerable{``0},Deedle.Frame{``1,``2})">
<summary>
 Replace the column index of the frame with the provided sequence of column keys.
 The columns of the frame are assigned keys according to the current order, or in a
 non-deterministic way, if the current column index is not ordered.

 ## Parameters
  - `frame` - Source data frame whose column index are to be replaced.
  - `keys` - A collection of new column keys.

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.IndexRowsByString``2(``0,Deedle.Frame{``1,``0})">
<summary>
 Returns a data frame whose rows are indexed based on the specified column of the original
 data frame. This function casts (or converts) the column key to values of type `string`
 (a generic variant that may require some type annotation is `Frame.indexRows`)

 ## Parameters
  - `frame` - Source data frame whose row index is to be replaced.
  - `column` - The name of a column in the original data frame that will be used for the new
    index. Note that the values in the column need to be unique.

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.IndexRowsByDateTimeOffset``2(``0,Deedle.Frame{``1,``0})">
<summary>
 Returns a data frame whose rows are indexed based on the specified column of the original
 data frame. This function casts (or converts) the column key to values of type `DateTimeOffset`
 (a generic variant that may require some type annotation is `Frame.indexRows`)

 ## Parameters
  - `frame` - Source data frame whose row index is to be replaced.
  - `column` - The name of a column in the original data frame that will be used for the new
    index. Note that the values in the column need to be unique.

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.IndexRowsByDateTime``2(``0,Deedle.Frame{``1,``0})">
<summary>
 Returns a data frame whose rows are indexed based on the specified column of the original
 data frame. This function casts (or converts) the column key to values of type `DateTime`
 (a generic variant that may require some type annotation is `Frame.indexRows`)

 ## Parameters
  - `frame` - Source data frame whose row index is to be replaced.
  - `column` - The name of a column in the original data frame that will be used for the new
    index. Note that the values in the column need to be unique.

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.IndexRowsByInt``2(``0,Deedle.Frame{``1,``0})">
<summary>
 Returns a data frame whose rows are indexed based on the specified column of the original
 data frame. This function casts (or converts) the column key to values of type `int`
 (a generic variant that may require some type annotation is `Frame.indexRows`)

 ## Parameters
  - `frame` - Source data frame whose row index is to be replaced.
  - `column` - The name of a column in the original data frame that will be used for the new
    index. Note that the values in the column need to be unique.

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.IndexRowsByObject``2(``0,Deedle.Frame{``1,``0})">
<summary>
 Returns a data frame whose rows are indexed based on the specified column of the original
 data frame. This function casts (or converts) the column key to values of type `obj`
 (a generic variant that may require some type annotation is `Frame.indexRows`)

 ## Parameters
  - `frame` - Source data frame whose row index is to be replaced.
  - `column` - The name of a column in the original data frame that will be used for the new
    index. Note that the values in the column need to be unique.

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.IndexRows``3(``0,Deedle.Frame{``1,``0})">
<summary>
 Returns a data frame whose rows are indexed based on the specified column of the original
 data frame. The generic type parameter is specifies the type of the values in the required 
 index column (and usually needs to be specified using a type annotation).

 ## Parameters
  - `frame` - Source data frame whose row index is to be replaced.
  - `column` - The name of a column in the original data frame that will be used for the new
    index. Note that the values in the column need to be unique.

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.IndexRowsOrdinally``2(Deedle.Frame{``0,``1})">
<summary>
 Replace the row index of the frame with ordinarilly generated integers starting from zero.
 The rows of the frame are assigned index according to the current order, or in a
 non-deterministic way, if the current row index is not ordered.

 ## Parameters
  - `frame` - Source data frame whose row index are to be replaced.

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.FrameModule.RealignRows``2(System.Collections.Generic.IEnumerable{``0},Deedle.Frame{``0,``1})">
<summary>
 Align the existing data to a specified collection of row keys. Values in the data frame
 that do not match any new key are dropped, new keys (that were not in the original data 
 frame) are assigned missing values.

 ## Parameters
  - `frame` - Source data frame that is to be realigned.
  - `keys` - A sequence of new row keys. The keys must have the same type as the original
    frame keys (because the rows are realigned).

 [category:Data structure manipulation]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.FrameModule.GetSeries``2(``0,Deedle.Frame{``1,``0})">
<summary>
 Returns a specified column from a data frame as a `float` series.
 This function attempts to covnert the column to numeric and throws an exception
 if that is not possible. For non-numeric types, use `getCol` instead.

 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.FrameModule.ReplaceColumn``2(``0,Deedle.ISeries{``1},Deedle.Frame{``1,``0})">
<summary>
 Creates a new data frame where the specified column is repalced
 with a new series. (If the series does not exist, only the new
 series is added.)

 ## Parameters
  - `column` - A key (or name) for the column to be replaced or added
  - `series` - A data series to be used (the row key type has to match)
  - `frame` - Source data frame (which is not mutated by the operation)

 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.FrameModule.DropSeries``2(``0,Deedle.Frame{``1,``0})">
<summary>
 Creates a new data frame that contains all data from the original
 data frame without the specified series (column). The operation throws
 if the column key is not found.

 ## Parameters
  - `column` - The key (or name) to be dropped from the frame
  - `frame` - Source data frame (which is not mutated by the operation)

 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.FrameModule.AddSeries``3(``0,Deedle.Series{``1,``2},Deedle.Frame{``1,``0})">
<summary>
 Creates a new data frame that contains all data from 
 the original data frame, together with an additional series.
 The operation uses left join and aligns new series to the 
 existing frame keys.

 ## Parameters
  - `column` - A key (or name) for the newly added column
  - `series` - A data series to be added (the row key type has to match)
  - `frame` - Source data frame (which is not mutated by the operation)

 [category:Series operations]
</summary>
</member>
<member name="M:Deedle.FrameModule.GetRows``2(System.Collections.Generic.IEnumerable{``0},Deedle.Frame{``0,``1})">
<summary>
 Returns a frame consisting of the specified rows from the original
 data frame. The function uses exact key matching semantics.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.GetColumns``2(System.Collections.Generic.IEnumerable{``0},Deedle.Frame{``1,``0})">
<summary>
 Returns a frame consisting of the specified columns from the original
 data frame. The function uses exact key matching semantics.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.LookupRow``3(``0,Deedle.Lookup,Deedle.Frame{``0,``1})">
<summary>
 Returns a specified row from a data frame. If the data frame has 
 ordered row index, the lookup semantics can be used to get row with 
 nearest greater/smaller key. For exact semantics, you can use `getRow`.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.LookupColumn``3(``0,Deedle.Lookup,Deedle.Frame{``1,``0})">
<summary>
 Returns a specified series (column) from a data frame. If the data frame has 
 ordered column index, the lookup semantics can be used to get series
 with nearest greater/smaller key. For exact semantics, you can use `getCol`.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.GetRow``3(``0,Deedle.Frame{``0,``1})">
<summary>
 Returns a specified row from a data frame. This function uses exact matching 
 semantics on the key. Use `lookupRow` if you want to use inexact matching 
 (e.g. on dates)

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.GetColumn``3(``0,Deedle.Frame{``1,``0})">
<summary>
 Returns a specified column from a data frame. This function uses exact matching 
 semantics on the key. Use `lookupSeries` if you want to use inexact 
 matching (e.g. on dates)

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.Rows``2(Deedle.Frame{``0,``1})">
<summary>
 Returns the rows of the data frame as a series (indexed by 
 the row keys of the source frame) containing untyped series representing
 individual row of the frame.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.Columns``2(Deedle.Frame{``0,``1})">
<summary>
 Returns the columns of the data frame as a series (indexed by 
 the column keys of the source frame) containing untyped series representing
 individual columns of the frame.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.CountColumns``2(Deedle.Frame{``0,``1})">
<summary>
 Returns the total number of column keys in the specified frame. This returns
 the total length of columns, including keys for which there is no 
 data available.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="M:Deedle.FrameModule.CountRows``2(Deedle.Frame{``0,``1})">
<summary>
 Returns the total number of row keys in the specified frame. This returns
 the total length of the row series, including keys for which there is no 
 value available.

 [category:Accessing frame data and lookup]
</summary>
</member>
<member name="T:Deedle.FrameModule">
<summary>
 Frame module comment

 ## Accessing frame data and lookup
 basics

 ## Data structure manipulation
 More documentation here

 ## Joining, zipping and appending
 More info

 ## Missing values
 More documentation here

 ## Projection and filtering
 TBD

</summary>
</member>
<member name="M:Deedle.FrameUtilsModule.expandColumns``1(Microsoft.FSharp.Collections.FSharpSet{System.String},Deedle.Frame{``0,System.String})">
<summary>
 Expand properties of vectors recursively. Nothing is done when `nesting = 0`.
</summary>
</member>
<member name="M:Deedle.FrameUtilsModule.expandVectors``1(System.Int32,System.Boolean,Deedle.Frame{``0,System.String})">
<summary>
 Expand properties of vectors recursively. Nothing is done when `nesting = 0`.
</summary>
</member>
<member name="M:Deedle.FrameUtilsModule.fromValues``4(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2},Microsoft.FSharp.Core.FSharpFunc{``0,``3})">
<summary>
 Create data frame from a sequence of values using
 projections that return column/row keys and the value
</summary>
</member>
<member name="M:Deedle.FrameUtilsModule.readCsv(System.IO.TextReader,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Load data from a CSV file using F# Data API
</summary>
</member>
<member name="M:Deedle.FrameUtilsModule.readReader(System.Data.IDataReader)">
<summary>
 Load data frame from a data reader (and cast the values of columns
 to their actual types to create IVector&lt;T&gt; with the right T)
</summary>
</member>
<member name="M:Deedle.FrameUtilsModule.toDataTable``2(System.Collections.Generic.IEnumerable{System.String},Deedle.Frame{``0,``1})">
<summary>
 Export the specified frame to &apos;DataTable&apos;. Caller needs to specify
 keys (headers) for the row keys (there may be more of them for multi-level index)
</summary>
</member>
<member name="M:Deedle.FrameUtilsModule.writeCsv``2(System.IO.TextWriter,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Char},Microsoft.FSharp.Core.FSharpOption{System.Globalization.CultureInfo},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.String}},Deedle.Frame{``0,``1})">
<summary>
 Store data frame to a CSV file using the specified information
 (use TSV format if file ends with .tsv, when including row keys, the
 caller needs to provide headers)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.FrameUtilsModule">

</member>
<member name="T:Deedle.Indices.AsyncSeriesConstruction`1">
<summary>
 Asynchronous version of `SeriesConstruction&lt;&apos;K&gt;`. Returns a workflow that evaluates
 the index, together with a construction to apply (asynchronously) on vectors
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.Indices.BoundaryBehavior">
<summary>
 Specifies the boundary behavior for the `IIndexBuilder.GetRange` operation
 (whether the boundary elements should be included or not)
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.WithIndex``2(Deedle.Indices.IIndex{``0},Microsoft.FSharp.Core.FSharpFunc{Deedle.Addressing.Address,Deedle.OptionalValue{``1}},Deedle.Vectors.VectorConstruction)">
<summary>
 Create a new index by picking a new key value for each key in the original index
 (used e.g. when we have a frame and want to use specified column as a new index).
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.Union``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction})">
<summary>
 Creates a union of two indices and builds corresponding vector transformations
 for both vectors that match the left and the right index.
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.Resample``3(Deedle.Indices.IIndex{``0},System.Collections.Generic.IEnumerable{``0},Deedle.Direction,Deedle.Vectors.VectorConstruction,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``1,System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction}},Deedle.OptionalValue{``2}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction}},``1})">
<summary>
 Aggregate data into non-overlapping chunks by aligning them to the
 specified keys. The second parameter specifies the direction. If it is
 `Direction.Forward` than the key is the first element of a chunk; for 
 `Direction.Backward`, the key is the last element (note that this does not 
 hold at the boundaries where values before/after the key may also be included)
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.Reindex``1(Deedle.Indices.IIndex{``0},Deedle.Indices.IIndex{``0},Deedle.Lookup,Deedle.Vectors.VectorConstruction,Microsoft.FSharp.Core.FSharpFunc{Deedle.Addressing.Address,System.Boolean})">
<summary>
 Given an old index and a new index, build a vector transformation that reorders
 elements from a vector associated with the old index so that they match the new
 index. When finding element location in the new index, the provided `Lookup` strategy
 is used. This is used, for example, when doing left/right join (to align the new data
 with another index) or when selecting multiple keys (`Series.lookupAll`).

 The proivded `condition` is used when searching for a value in the old index
 (when lookup is not exact). It is called to check that the address contains an
 appropriate value (e.g. when we need to skip over missing values).
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.Project``1(Deedle.Indices.IIndex{``0})">
<summary>
 When we perform some projection on the vector (e.g. `Series.map`), then we may also
 need to perform some transformation on the index (because it will typically turn delayed
 index into an evaluated index). This operation represents that - it should return 
 (evaluated) index with the same keys.
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.OrderIndex``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction})">
<summary>
 Order (possibly unordered) index and return transformation that reorders vector
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.LookupLevel``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},Deedle.ICustomLookup{``0})">
<summary>
 Get items associated with the specified key from the index. This method takes
 `ICustomLookup&lt;K&gt;` which provides an implementation of `ICustomKey&lt;K&gt;`. This 
 is used for custom equality testing (for example, when getting a level of a hierarchical index)
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.Intersect``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction})">
<summary>
 Creates an interesection of two indices and builds corresponding vector transformations
 for both vectors that match the left and the right index.
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.GroupBy``3(Deedle.Indices.IIndex{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Deedle.OptionalValue{``1}},Deedle.Vectors.VectorConstruction,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``1,System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction}},Deedle.OptionalValue{``2}})">
<summary>
 Group a (possibly unordered) index using the specified `keySelector` function.
 The operation builds a new index with the selected keys and a matching vector
 with values produced by the `valueSelector` function.
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.GetRange``1(Deedle.Indices.IIndex{``0},Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,Deedle.Indices.BoundaryBehavior}},Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,Deedle.Indices.BoundaryBehavior}},Deedle.Vectors.VectorConstruction)">
<summary>
 Create a new index that represents sub-range of an existing index. The range is specified
 as a pair of options (when `None`, the original left/right boundary should be used) 
 that contain boundary behavior and the boundary key.
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.DropItem``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},``0)">
<summary>
 Drop an item associated with the specified key from the index. 
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.Create``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Create a new index using the specified keys. Optionally, the caller can specify
 if the index keys are ordered or not. When the value is not set, the construction
 should check and infer this from the data.
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.AsyncMaterialize``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction})">
<summary>
 Given an index and vector construction, return a new index asynchronously
 to allow composing evaluation of lazy series. The command to be applied to
 vectors can be applied asynchronously using `vectorBuilder.AsyncBuild`
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.Append``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},Deedle.Vectors.IVectorValueTransform)">
<summary>
 Append two indices and builds corresponding vector transformations
 for both vectors that match the left and the right index. If the indices
 are ordered, the ordering should be preserved (the keys should be aligned).
 The specified `IVectorValueTransform` defines how to deal with the case when
 a key is defined in both indices (i.e. which value should be in the new vector).
</summary>
</member>
<member name="M:Deedle.Indices.IIndexBuilder.Aggregate``3(Deedle.Indices.IIndex{``0},Deedle.Aggregation{``0},Deedle.Vectors.VectorConstruction,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Deedle.DataSegmentKind,System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction}},System.Tuple{``1,Deedle.OptionalValue{``2}}})">
<summary>
 Aggregate an ordered index into floating windows or chunks. 

 ## Parameters

  - `index` - Specifies the index to be aggregated
  - `aggregation` - Defines the kind of aggregation to apply (the type 
    is a discriminated union with a couple of cases)
  - `source` - Source vector construction to be transformed 
  - `selector` - Given information about window/chunk (including 
    vector construction that can be used to build the data chunk), return
    a new key, together with a new value for the returned vector.
</summary>
</member>
<member name="T:Deedle.Indices.IIndexBuilder">
<summary>
 A builder represents various ways of constructing index, either from keys or from
 other indices. The operations that build a new index from an existing index also 
 build `VectorConstruction` which specifies how to transform vectors aligned with the
 previous index to match the new index. The methods generally take `VectorConstruction`
 as an input, apply necessary transformations to it and return a new `VectorConstruction`.

 ## Example

 For example, given `index`, we can say:

     // Create an index that excludes the value 42
     let newIndex, vectorCmd = indexBuilder.DropItem(index, 42, VectorConstruction.Return(0))

     // Now we can transform multiple vectors (e.g. all frame columns) using &apos;vectorCmd&apos;
     // (the integer &apos;0&apos; in `Return` is an offset in the array of vector arguments)
     let newVector = vectorBuilder.Build(vectorCmd, [| vectorToTransform |])

</summary>
</member>
<member name="P:Deedle.Indices.IIndex`1.Range">
<summary>
 Returns the minimal and maximal address used in the index.
</summary>
</member>
<member name="P:Deedle.Indices.IIndex`1.Mappings">
<summary>
 Returns all key-address mappings in the index
</summary>
</member>
<member name="P:Deedle.Indices.IIndex`1.Keys">
<summary>
 Returns a sequence of all keys in the index.
</summary>
</member>
<member name="P:Deedle.Indices.IIndex`1.KeyRange">
<summary>
 Returns the minimal and maximal key associated with the index.
 (the operation may fail for unordered indices)
</summary>
</member>
<member name="P:Deedle.Indices.IIndex`1.KeyCount">
<summary>
 Returns the number of keys in the index
</summary>
</member>
<member name="P:Deedle.Indices.IIndex`1.IsOrdered">
<summary>
 Returns `true` if the index is ordered and `false` otherwise
</summary>
</member>
<member name="P:Deedle.Indices.IIndex`1.IsEmpty">
<summary>
 Returns whether the specified index is empty. This is equivalent to 
 testing if `Keys` are empty, but it does not have to evaluate delayed index.
</summary>
</member>
<member name="P:Deedle.Indices.IIndex`1.Comparer">
<summary>
 Returns a comparer associated with the values used by the current index.
</summary>
</member>
<member name="P:Deedle.Indices.IIndex`1.Builder">
<summary>
 Returns an index builder that canbe used for constructing new indices of the
 same kind as the current index (e.g. a lazy index returns a lazy index builder)
</summary>
</member>
<member name="M:Deedle.Indices.IIndex`1.Lookup(`0,Deedle.Lookup,Microsoft.FSharp.Core.FSharpFunc{Deedle.Addressing.Address,System.Boolean})">
<summary>
 Find the address associated with the specified key, or with the nearest
 key as specifeid by the `lookup` argument. The `condition` function is called
 when searching for keys to ask the caller whether the address should be returned
 (or whether to continue searching). This is used when searching for previous element
 in a series (where we need to check if a value at the address is available)
</summary>
</member>
<member name="M:Deedle.Indices.IIndex`1.KeyAt(Deedle.Addressing.Address)">
<summary>
 Performs reverse lookup - and returns key for a specified address
</summary>
</member>
<member name="T:Deedle.Indices.IIndex`1">
<summary>
 An interface that represents index mapping keys of some generic type `T` to locations
 of address `Address`. The `IIndex&lt;K&gt;` contains minimal set of operations that have to
 be supported by an index. This type should be only used directly when
 extending the DataFrame library and adding a new way of storing or loading data.
 Values of this type are constructed using the associated `IIndexBuilder` type.
</summary>
</member>
<member name="T:Deedle.Indices.SeriesConstruction`1">
<summary>
 Represents a pair of index and vector construction 
 (many of the index operations take/return an index together with a construction
 command that builds a vector matching with the index, so this type alias
 makes this more obvious)
</summary>
</member>
<member name="">

</member>
<member name="F:Deedle.Indices.Linear.Deedle.Indices.Linear.LinearIndexBuilder.indexBuilder">
<summary>
 Instance of the index builder (specialized to Int32 addresses)
</summary>
</member>
<member name="">

</member>
<member name="P:Deedle.Indices.Linear.LinearIndexBuilder.Instance">
<summary>
 Provides a global access to an instance of LinearIndexBuilder
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-WithIndex``2(Deedle.Indices.IIndex{``0},Microsoft.FSharp.Core.FSharpFunc{Deedle.Addressing.Address,Deedle.OptionalValue{``1}},Deedle.Vectors.VectorConstruction)">
<summary>
 Build a new index by getting a key for each old key using the specified function
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-Union``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction})">
<summary>
 Union the index with another. For sorted indices, this needs to align the keys;
 for unordered, it appends new ones to the end.
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-Resample``3(Deedle.Indices.IIndex{``0},System.Collections.Generic.IEnumerable{``0},Deedle.Direction,Deedle.Vectors.VectorConstruction,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``1,System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction}},Deedle.OptionalValue{``2}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction}},``1})">
<summary>
 Create chunks based on the specified key sequence
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-Reindex``1(Deedle.Indices.IIndex{``0},Deedle.Indices.IIndex{``0},Deedle.Lookup,Deedle.Vectors.VectorConstruction,Microsoft.FSharp.Core.FSharpFunc{Deedle.Addressing.Address,System.Boolean})">
<summary>
 Reorder elements in the index to match with another index ordering
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-Project``1(Deedle.Indices.IIndex{``0})">
<summary>
 Linear index is always fully evaluated - just return it
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-OrderIndex``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction})">
<summary>
 Order index and build vector transformation 
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-Intersect``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction})">
<summary>
 Intersect the index with another. This is the same as
 Union, but we filter &amp; only return keys present in both sequences.
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-GroupBy``3(Deedle.Indices.IIndex{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Deedle.OptionalValue{``1}},Deedle.Vectors.VectorConstruction,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``1,System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction}},Deedle.OptionalValue{``2}})">
<summary>
 Group an (un)ordered index
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-GetRange``1(Deedle.Indices.IIndex{``0},Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,Deedle.Indices.BoundaryBehavior}},Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,Deedle.Indices.BoundaryBehavior}},Deedle.Vectors.VectorConstruction)">
<summary>
 Get a new index representing a sub-index of the current one
 (together with a transformation that should be applied to a vector)
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-DropItem``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},``0)">
<summary>
 Drop the specified item from the index
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-Create``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Create an index from the specified data
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-AsyncMaterialize``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction})">
<summary>
 Linear index is always fully evaluated - just return it asynchronously
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-Append``1(System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction},Deedle.Vectors.IVectorValueTransform)">
<summary>
 Append is similar to union, but it also combines the vectors using the specified
 vector transformation.
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndexBuilder.Deedle-Indices-IIndexBuilder-Aggregate``3(Deedle.Indices.IIndex{``0},Deedle.Aggregation{``0},Deedle.Vectors.VectorConstruction,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Deedle.DataSegmentKind,System.Tuple{Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction}},System.Tuple{``1,Deedle.OptionalValue{``2}}})">
<summary>
 Aggregate ordered index
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.Indices.Linear.LinearIndexBuilder">
<summary>
 Index builder object that is associated with `LinearIndex&lt;K&gt;` type. The builder
 provides operations for manipulating linear indices (and the associated vectors).
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Deedle.Indices.Linear.LinearIndex`1.Range">
<summary>
 Returns the range used by the index
</summary>
</member>
<member name="P:Deedle.Indices.Linear.LinearIndex`1.Mappings">
<summary>
 Returns all mappings of the index (key -&gt; address) 
</summary>
</member>
<member name="P:Deedle.Indices.Linear.LinearIndex`1.KeysArray">
<summary>
 Exposes keys array for use in the index builder
</summary>
</member>
<member name="">

</member>
<member name="P:Deedle.Indices.Linear.LinearIndex`1.KeyRange">
<summary>
 Returns the range of keys - makes sense only for ordered index
</summary>
</member>
<member name="">

</member>
<member name="P:Deedle.Indices.Linear.LinearIndex`1.IsOrdered">
<summary>
 Are the keys of the index ordered?
</summary>
</member>
<member name="P:Deedle.Indices.Linear.LinearIndex`1.IsEmpty">
<summary>
 Returns whether the specified index is empty
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.Indices.Linear.LinearIndex`1.Deedle-Indices-IIndex`1-Lookup(`0,Deedle.Lookup,Microsoft.FSharp.Core.FSharpFunc{Deedle.Addressing.Address,System.Boolean})">
<summary>
 Get the address for the specified key.
 The &apos;semantics&apos; specifies fancy lookup methods.
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndex`1.Deedle-Indices-IIndex`1-KeyAt(Deedle.Addressing.Address)">
<summary>
 Perform reverse lookup and return key for an address
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndex`1.GetHashCode">
<summary>
 Implement structural hashing against another index
</summary>
</member>
<member name="M:Deedle.Indices.Linear.LinearIndex`1.Equals(System.Object)">
<summary>
 Implements structural equality check against another index
</summary>
</member>
<member name="">

</member>
<member name="T:Deedle.Indices.Linear.LinearIndex`1">
<summary>
 An index that maps keys `K` to offsets `Address`. The keys cannot be duplicated.
 The construction checks if the keys are ordered (using the provided or the default
 comparer for `K`) and disallows certain operations on unordered indices.
</summary>
</member>
<member name="">

</member>
<member name="T:Deedle.Internal.IFsiFormattable">
<summary>
 [omit]
 An interface implemented by types that support nice formatting for F# Interactive
 (The `FSharp.DataFrame.fsx` file registers an FSI printer using this interface.)
</summary>
</member>
<member name="">

</member>
<member name="T:Deedle.Internal.ComparisonFailedException">
<summary>
 An internal exception that is used to handle the case when comparison fails
 (even though the type implements IComparable and everything...)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.Internal.DynamicExtensions.WrappedExpression">
<summary>
 A C# expression tree, embedded in a value (in a quotation)
</summary>
</member>
<member name="M:Deedle.Internal.DynamicExtensions.createGetterAndSetterFromFunc``1(System.Linq.Expressions.Expression,``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.String,System.Object}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit}}})">
<summary>
 This can be used when the setter is a simple non-generic function that 
 takes the name as string &amp; argument as object (and returns nothing)
</summary>
</member>
<member name="M:Deedle.Internal.DynamicExtensions.createPropertyMetaObject``1(System.Linq.Expressions.Expression,``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpFunc{System.Type,Microsoft.FSharp.Quotations.FSharpExpr}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpFunc{System.Type,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr}}}})">
<summary>
 This can be used when getter/setter are generic (in some way) - the caller
 is responsible for generating the right expression tree (this cannot easily
 be done using quotations)
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.Internal.DynamicExtensions.asExpr(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Translate simple F# quotation to C# expression &amp; handle wrapped values
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.Internal.DynamicExtensions">
<summary>
 [omit]
 Module that implements various helpers for supporting C# dynamic type.
 (this takes care of some of the complexity around building `DynamicMetaObject`
 and it is used by `SeriesBuilder` and `Frame`)
</summary>
</member>
<member name="M:Deedle.Internal.Convert.changeType``1(System.Object)">
<summary>
 Helper function that converts value to a specified type
 (this aims to be as flexible as possible)
</summary>
</member>
<member name="">

</member>
<member name="T:Deedle.Internal.Convert">
<summary>
 [omit]
</summary>
</member>
<member name="">

</member>
<member name="P:Deedle.Internal.Formatting.EndInlineItemCount">
<summary>
 Maximal number of items to be printed at the end of an inline formatted series/frame
</summary>
</member>
<member name="P:Deedle.Internal.Formatting.StartInlineItemCount">
<summary>
 Maximal number of items to be printed at the beginning of an inline formatted series/frame
</summary>
</member>
<member name="P:Deedle.Internal.Formatting.EndItemCount">
<summary>
 Maximal number of items to be printed at the end of a series/frame
</summary>
</member>
<member name="P:Deedle.Internal.Formatting.StartItemCount">
<summary>
 Maximal number of items to be printed at the beginning of a series/frame
</summary>
</member>
<member name="T:Deedle.Internal.Formatting">
<summary>
 [omit]
 Contains helper functions and configuration constants for pretty printing
</summary>
</member>
<member name="M:Deedle.Internal.Seq.alignWithoutOrdering``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}},System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Align two unordered sequences of `Key * Address` pairs and produce a collection
 that contains three-element tuples consisting of keys, optional address in the
 first sequence &amp; optional address in the second sequence. (See also `alignWithOrdering`)
</summary>
</member>
<member name="M:Deedle.Internal.Seq.alignWithOrdering``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}},System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}},System.Collections.Generic.IComparer{``0})">
<summary>
 Align two ordered sequences of `Key * Address` pairs and produce a 
 collection that contains three-element tuples consisting of: 

   * ordered keys (from one or the ohter sequence)
   * optional address of the key in the first sequence
   * optional address of the key in the second sequence

</summary>
</member>
<member name="M:Deedle.Internal.Seq.tryFirstAndLast``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Returns the first and the last element from a sequence or &apos;None&apos; if the sequence is empty
</summary>
</member>
<member name="M:Deedle.Internal.Seq.isSorted``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
<summary>
 Returns true if the specified sequence is sorted.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.chunkedWithBounds``1(System.Int32,Deedle.Boundary,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Similar to `Seq.windowedWithBounds`, but generates non-overlapping chunks
 rather than floating windows. See that function for detailed documentation.
 The function may iterate over the sequence repeatedly.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.windowedWithBounds``1(System.Int32,Deedle.Boundary,System.Collections.Generic.IEnumerable{``0})">
<summary>
 A version of `Seq.windowed` that allows specifying more complex boundary
 behaviour. The `boundary` argument can specify one of the following options:
 
  * `Boundary.Skip` - only full windows are returned (like `Seq.windowed`)
  * `Boundary.AtBeginning` - incomplete windows (smaller than the required
    size) are returned at the beginning.
  * `Boundary.AtEnding` - incomplete windows are returned at the end.

 The result is a sequence of `DataSegnebt&lt;T&gt;` values, which makes it 
 easy to distinguish between complete and incomplete windows.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.chunkedUsing``1(System.Collections.Generic.Comparer{``0},Deedle.Direction,System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Generate non-overlapping chunks from the input sequence. Chunks are aligned
 to the specified keys. The `dir` parameter specifies the direction. If it is
 `Direction.Forward` than the key is the first element of a chunk; for 
 `Direction.Backward`, the key is the last element (note that this does not hold
 at the boundaries)
</summary>
</member>
<member name="M:Deedle.Internal.Seq.chunkedWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Generate non-verlapping chunks from the input sequence. A chunk is started 
 at the beginning and then immediately after the end of the previous chunk.
 To find the end of the chunk, the function calls the provided argument `f` 
 with the first and the last elements of the chunk as arguments. A chunk 
 ends when `f` returns `false`.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.windowedWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Generate floating windows from the input sequence. New floating window is 
 started for each element. To find the end of the window, the function calls
 the provided argument `f` with the first and the last elements of the window
 as arguments. A window ends when `f` returns `false`.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.startAndEnd``1(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Given a sequence, returns `startCount` number of elements at the beginning 
 of the sequence (wrapped in `Choice1Of3`) followed by one `Choice2Of2()` value
 and then followed by `endCount` number of elements at the end of the sequence
 wrapped in `Choice3Of3`. If the input is shorter than `startCount + endCount`,
 then all values are returned and wrapped in `Choice1Of3`.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.getEnumerator``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Calls the `GetEnumerator` method. Simple function to guide type inference.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.lastFew``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Returns the specified number of elements from the end of the sequence
 Note that this needs to store the specified number of elements in memory
 and it needs to iterate over the entire sequence.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.headOrNone``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 If the input is non empty, returns `Some(head)` where `head` is 
 the first value. Otherwise, returns `None`.
</summary>
</member>
<member name="M:Deedle.Internal.Seq.structuralHash``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Calculate hash code of a sequence, based on the values
</summary>
</member>
<member name="M:Deedle.Internal.Seq.structuralEquals``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Comapre two sequences using the `Equals` method. Returns true
 when all their elements are equal and they have the same size.
</summary>
</member>
<member name="T:Deedle.Internal.Seq">
<summary>
 This module contains additional functions for working with sequences. 
 `Deedle.Internals` is opened, it extends the standard `Seq` module.
</summary>
</member>
<member name="M:Deedle.Internal.Array.choosei``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},``0[])">
<summary>
 Returns a new array containing only the elements for which the specified function returns `Some`.
 The predicate is called with the index in the source array and the element.
</summary>
</member>
<member name="M:Deedle.Internal.Array.binarySearchNearestSmaller``1(``0,System.Collections.Generic.IComparer{``0},``0[])">
<summary>
 Returns the index of &apos;key&apos; or the index of immediately preceeding value.
 If the specified key is smaller than all keys in the array, None is returned.
</summary>
</member>
<member name="M:Deedle.Internal.Array.binarySearchNearestGreater``1(``0,System.Collections.Generic.IComparer{``0},``0[])">
<summary>
 Returns the index of &apos;key&apos; or the index of immediately following value.
 If the specified key is greater than all keys in the array, None is returned.
</summary>
</member>
<member name="M:Deedle.Internal.Array.binarySearch``1(``0,System.Collections.Generic.IComparer{``0},``0[])">
<summary>
 Implementation of binary search
</summary>
</member>
<member name="M:Deedle.Internal.Array.dropRange``1(System.Int32,System.Int32,``0[])">
<summary>
 Drop a specified range from a given array. The operation is inclusive on
 both sides. Given [ 1; 2; 3; 4 ] and indices (1, 2), the result is [ 1; 4 ]
</summary>
</member>
<member name="T:Deedle.Internal.Array">
<summary>
 This module contains additional functions for working with arrays. 
 `Deedle.Internals` is opened, it extends the standard `Array` module.
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.maxOptional``1(System.Collections.ObjectModel.ReadOnlyCollection{Deedle.OptionalValue{``0}})">
<summary>
 Return the greatest element, skipping over missing values
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.minOptional``1(System.Collections.ObjectModel.ReadOnlyCollection{Deedle.OptionalValue{``0}})">
<summary>
 Return the smallest element, skipping over missing values
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.lengthOptional``1(System.Collections.ObjectModel.ReadOnlyCollection{Deedle.OptionalValue{``0}})">
<summary>
 Count elements of the ReadOnlyCollection that are not missing
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.averageOptional``2(System.Collections.ObjectModel.ReadOnlyCollection{Deedle.OptionalValue{``0}})">
<summary>
 Average elements of the ReadOnlyCollection, skipping over missing values
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.reduceOptional``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.ObjectModel.ReadOnlyCollection{Deedle.OptionalValue{``0}})">
<summary>
 Reduce elements of the ReadOnlyCollection, skipping over missing values
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.sumOptional``2(System.Collections.ObjectModel.ReadOnlyCollection{Deedle.OptionalValue{``0}})">
<summary>
 Sum elements of the ReadOnlyCollection, skipping over missing values
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.average``2(System.Collections.ObjectModel.ReadOnlyCollection{``0})">
<summary>
 Average elements of the ReadOnlyCollection
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.length``1(System.Collections.ObjectModel.ReadOnlyCollection{``0})">
<summary>
 Count elements of the ReadOnlyCollection
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.ObjectModel.ReadOnlyCollection{``0})">
<summary>
 Reduce elements of the ReadOnlyCollection
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.max``1(System.Collections.ObjectModel.ReadOnlyCollection{``0})">
<summary>
 Return the greatest element of the ReadOnlyCollection
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.min``1(System.Collections.ObjectModel.ReadOnlyCollection{``0})">
<summary>
 Return the smallest element of the ReadOnlyCollection
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.sum``2(System.Collections.ObjectModel.ReadOnlyCollection{``0})">
<summary>
 Sum elements of the ReadOnlyCollection
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Converts a lazy sequence to fully evaluated ReadOnlyCollection
</summary>
</member>
<member name="M:Deedle.Internal.ReadOnlyCollection.ofArray``1(``0[])">
<summary>
 Converts an array to ReadOnlyCollection. 
</summary>
</member>
<member name="T:Deedle.Internal.ReadOnlyCollection">
<summary>
 Provides helper functions for working with `ReadOnlyCollection&lt;T&gt;` similar to those 
 in the `Array` module. Most importantly, F# 3.0 does not know that array implements
 `IList&lt;T&gt;`.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.Internal.MissingValues">
<summary>
 Utility functions for identifying missing values. The `isNA` function 
 can be used to test whether a value represents a missing value - this includes
 the `null` value, `Nullable&lt;T&gt;` value with `HasValue = false` and 
 `Single.NaN` as well as `Double.NaN`.

 The functions in this module are not intended to be called directly.
</summary>
</member>
<member name="M:Deedle.Internal.ExceptionHelpers.keyNotFound``2(``0)">
<summary>
 Throws `KeyNotFoundException` with a nicely formatted error message for the specified key
</summary>
</member>
<member name="M:Deedle.Internal.ExceptionHelpers.missingVal``2(``0)">
<summary>
 Throws `MissingValueException` with a nicely formatted error message for the specified key
</summary>
</member>
<member name="T:Deedle.Internal.ExceptionHelpers">
<summary>
 Simple helper functions for throwing exceptions
</summary>
</member>
<member name="M:Deedle.JoinHelpers.createJoinTransformation``1(Deedle.Indices.IIndexBuilder,Deedle.JoinKind,Deedle.Lookup,Deedle.Indices.IIndex{``0},Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction,Deedle.Vectors.VectorConstruction)">
<summary>
 Create transformation on indices/vectors representing the join operation
</summary>
</member>
<member name="M:Deedle.JoinHelpers.fillMissing(Deedle.Vectors.VectorConstruction,Deedle.Lookup)">
<summary>
 When using fancy lookup, first fill values in the vector, before doing the join
</summary>
</member>
<member name="M:Deedle.JoinHelpers.restrictToRowIndex``1(Deedle.Lookup,Deedle.Indices.IIndex{``0},Deedle.Indices.IIndex{``0},Deedle.Vectors.VectorConstruction)">
<summary>
 When doing exact join on ordered indices, restrict the new index
 so that we do not have to load all data for lazy indices
</summary>
</member>
<member name="T:Deedle.JoinHelpers">
<summary>
 [omit]
 Implements various helpers that are used by Join operations
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.Keys.SimpleLookup`1.Deedle-ICustomLookup`1-Matches(`0)">
<summary>
 Dynamically tests whether this pattern matches with another key. 
 For example, `[|None, Some 1|]` matches `(42, 1)`, but if the second 
 values differed, then they would not match.
</summary>
</member>
<member name="">

</member>
<member name="T:Deedle.Keys.SimpleLookup`1">
<summary>
 Implements a simple lookup that matches any multi-level key against a specified array of
 optional objects (that represent missing/set parts of a key)
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.Keys.CustomKey.Get(System.Object)">
<summary>
 Returns `ICustomKey` instance for the specified key. If the specified key implements
 `ICustomKey`, then it is just returned; if it is a tuple, we use special key for tuples
 otherwise, it must be a primitive key so we just return it
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.Keys.CustomKey">
<summary>
 Helper type that can be used to get `ICustomKey` for any object (including objects
 that actually implement the interface and tuples)
</summary>
</member>
<member name="P:Deedle.Keys.ICustomKey.Levels">
<summary>
 Returns the number of levels of a hierarchical key. For example, a tuple (1, 42) has 2 levels.
 This is used for pretty printing only.
</summary>
</member>
<member name="M:Deedle.Keys.ICustomKey.GetLevels">
<summary>
 Gets values of the key at all levels
</summary>
</member>
<member name="M:Deedle.Keys.ICustomKey.GetLevel(System.Int32)">
<summary>
 Gets a value at the specified level (the levels are indexed from 1). 
 This is used for pretty printing only. If `Levels=1` then this method is not
 called and the pretty printer invokes `ToString` on the whole object instead.
</summary>
</member>
<member name="T:Deedle.Keys.ICustomKey">
<summary>
 Represents a special hierarchical key. This is mainly used in pretty printing (where we want to 
 get parts of the keys based on levels. `CustomKey.Get` provides a way of getting `ICustomKey`.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.LookupAnyOf4``5(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1},Microsoft.FSharp.Core.FSharpOption{``2},Microsoft.FSharp.Core.FSharpOption{``3})">
<summary>
 Creates an arbitrary lookup key that allows matching on elements
 of a four-level hierarchical index. Specify `None` to ignore a level
 or `Some k` to require match on a given level.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.Lookup4Of4``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 fourth element of a four-level hierarchical key.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.Lookup3Of4``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 third element of a four-level hierarchical key.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.Lookup2Of4``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 second element of a four-level hierarchical key.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.Lookup1Of4``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 first element of a four-level hierarchical key.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.LookupAnyOf3``4(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1},Microsoft.FSharp.Core.FSharpOption{``2})">
<summary>
 Creates an arbitrary lookup key that allows matching on elements
 of a three-level hierarchical index. Specify `None` to ignore a level
 or `Some k` to require match on a given level.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.Lookup3Of3``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 third element of a three-level hierarchical key.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.Lookup2Of3``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 second element of a three-level hierarchical key.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.Lookup1Of3``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 first element of a three-level hierarchical key.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.LookupAnyOf2``3(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Creates an arbitrary lookup key that allows matching on elements
 of a two-level hierarchical index. Specify `None` to ignore a level
 or `Some k` to require match on a given level.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.Lookup2Of2``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 second element of a two-level hierarchical key.
</summary>
</member>
<member name="M:Deedle.MultiKeyExtensions.Lookup1Of2``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 first element of a two-level hierarchical key.
</summary>
</member>
<member name="T:Deedle.MultiKeyExtensions">
<summary>
 F#-friendly functions for creating multi-level keys and lookups
</summary>
</member>
<member name="M:Deedle.OptionalValueModule.get``1(Deedle.OptionalValue{``0})">
<summary>
 Get the value stored in the specified optional value. If a value is not
 available, throws an exception. (This is equivalent to the `Value` property)
</summary>
</member>
<member name="M:Deedle.OptionalValueModule.|Missing|Present|``1(Deedle.OptionalValue{``0})">
<summary>
 Complete active pattern that can be used to pattern match on `OptionalValue&lt;T&gt;`.
 For example:

     let optVal = OptionalValue(42)
     match optVal with
     | OptionalValue.Missing -&gt; printfn &quot;Empty&quot;
     | OptionalValue.Present(v) -&gt; printfn &quot;Contains %d&quot; v

</summary>
</member>
<member name="M:Deedle.OptionalValueModule.ofOption``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Turns a standard F# `option&lt;T&gt;` value into a corresponding `OptionalValue&lt;T&gt;`
</summary>
</member>
<member name="M:Deedle.OptionalValueModule.asOption``1(Deedle.OptionalValue{``0})">
<summary>
 Turns the `OptionalValue&lt;T&gt;` into a corresponding standard F# `option&lt;T&gt;` value
</summary>
</member>
<member name="M:Deedle.OptionalValueModule.OfNullable``1(System.Nullable{``0})">
<summary>
 Creates `OptionalValue&lt;T&gt;` from a .NET `Nullable&lt;T&gt;` type.
</summary>
</member>
<member name="M:Deedle.OptionalValueModule.OfTuple``1(System.Boolean,``0)">
<summary>
 Creates `OptionalValue&lt;T&gt;` from a tuple of type `bool * &apos;T`. This function
 can be used with .NET methods that use `out` arguments. For example:

     Int32.TryParse(&quot;42&quot;) |&gt; OptionalValue.ofTuple

</summary>
</member>
<member name="M:Deedle.OptionalValueModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.OptionalValue{``0})">
<summary>
 If the `OptionalValue&lt;T&gt;` does not contain a value, then returns a new 
 `OptionalValue&lt;R&gt;.Empty`. Otherwise, returns the result `OptionalValue&lt;R&gt;`
 containing the result of applying the function `f` to the value contained 
 in the provided optional value.
</summary>
</member>
<member name="M:Deedle.OptionalValueModule.Bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,Deedle.OptionalValue{``1}},Deedle.OptionalValue{``0})">
<summary>
 If the `OptionalValue&lt;T&gt;` does not contain a value, then returns a new 
 `OptionalValue&lt;R&gt;.Empty`. Otherwise, returns the result of applying the 
 function `f` to the value contained in the provided optional value.
</summary>
</member>
<member name="T:Deedle.OptionalValueModule">
<summary>
 Provides various helper functions for using the `OptionalValue&lt;T&gt;` type from F#
 (The functions are similar to those in the standard `Option` module).
</summary>
</member>
<member name="M:Deedle.Pair.flatten4``4(``0,System.Tuple{``1,System.Tuple{``2,``3}})">
<summary>
 Flatten a two-level nested tuple into a flat tuple of 4 elements
</summary>
</member>
<member name="M:Deedle.Pair.flatten3``3(``0,System.Tuple{``1,``2})">
<summary>
 Flatten a two-level nested tuple into a flat tuple of 3 elements
</summary>
</member>
<member name="M:Deedle.Pair.get4Of4``4(``0,``1,``2,``3)">
<summary>
 Returns the fourth value of a four-level hierarchical tuple
</summary>
</member>
<member name="M:Deedle.Pair.get3Of4``4(``0,``1,``2,``3)">
<summary>
 Returns the third value of a four-level hierarchical tuple
</summary>
</member>
<member name="M:Deedle.Pair.get2Of4``4(``0,``1,``2,``3)">
<summary>
 Returns the second value of a four-level hierarchical tuple
</summary>
</member>
<member name="M:Deedle.Pair.get1Of4``4(``0,``1,``2,``3)">
<summary>
 Returns the first value of a four-level hierarchical tuple
</summary>
</member>
<member name="M:Deedle.Pair.get1And3Of3``3(``0,``1,``2)">
<summary>
 Returns the first and the third value of a three-level hierarchical tuple
</summary>
</member>
<member name="M:Deedle.Pair.get2And3Of3``3(``0,``1,``2)">
<summary>
 Returns the second and the third value of a three-level hierarchical tuple
</summary>
</member>
<member name="M:Deedle.Pair.get1And2Of3``3(``0,``1,``2)">
<summary>
 Returns the first and the second value of a three-level hierarchical tuple
</summary>
</member>
<member name="M:Deedle.Pair.get3Of3``3(``0,``1,``2)">
<summary>
 Returns the third value of a three-level hierarchical tuple
</summary>
</member>
<member name="M:Deedle.Pair.get2Of3``3(``0,``1,``2)">
<summary>
 Returns the second value of a three-level hierarchical tuple
</summary>
</member>
<member name="M:Deedle.Pair.get1Of3``3(``0,``1,``2)">
<summary>
 Returns the first value of a three-level hierarchical tuple
</summary>
</member>
<member name="M:Deedle.Pair.get2Of2``2(``0,``1)">
<summary>
 Returns the second value of a two-level hierarchical tuple
</summary>
</member>
<member name="M:Deedle.Pair.get1Of2``2(``0,``1)">
<summary>
 Returns the first value of a two-level hierarchical tuple
</summary>
</member>
<member name="T:Deedle.Pair">
<summary>
 Module with helper functions for extracting values from hierarchical tuples
</summary>
</member>
<member name="M:Deedle.Reflection.convertRecordSequence``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Convert a sequence of records to a data frame - automatically 
 get the columns based on information available using reflection
</summary>
</member>
<member name="M:Deedle.Reflection.getRecordConvertorExprs(System.Type)">
<summary>
 Given type &apos;T that represents some .NET object, generate an array of 
 functions that take seq&lt;&apos;T&gt; and generate IVector with each column:

     vectorBuilder.Create(&lt;input&gt;.Select(fun (recd:&apos;T) -&gt; 
       recd.&lt;field&gt;).ToArray()) : IVector&lt;&apos;F&gt;

</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.Reflection.expandVector``1(System.Boolean,Deedle.IVector{``0})">
<summary>
 Given a single vector, expand its values into multiple vectors. This may be:
 - `IDictionary` is expanded based on keys/values
 - `ISeries&lt;string&gt;` is expanded 
 - .NET types with readable properties are expanded
</summary>
</member>
<member name="P:Deedle.Reflection.getCachedCompileProjection">
<summary>
 Compile all projections from the type, so that we can run them fast
 and cache the results with Type as the key, so that we don&apos;t have to recompile 
</summary>
</member>
<member name="M:Deedle.Reflection.expandDictionary(System.Object)">
<summary>
 Given value, return names, types and values of all its IDictionary contents (or None)
</summary>
</member>
<member name="M:Deedle.Reflection.getMemberProjections(System.Type)">
<summary>
 Given System.Type for some .NET object, get a sequence of projections
 that return the values of all readonly properties (together with their name &amp; type)
</summary>
</member>
<member name="">

</member>
<member name="P:Deedle.Reflection.createTypedVector">
<summary>
 Helper function used when building frames from data tables
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Deedle.Reflection.customExpanders">
<summary>
 Custom expanders that override default behavior
</summary>
</member>
<member name="P:Deedle.Reflection.nonFlattenedTypes">
<summary>
 Mutable collections of interfaces that we want to ignore 
</summary>
</member>
<member name="P:Deedle.Reflection.additionalPrimitiveTypes">
<summary>
 Mutable collection of additional primitive types that we want to skip
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.Reflection.getDictionaryValues``2(System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Helper function that returns contents of IDictionary&lt;&apos;K, &apos;V&gt;
</summary>
</member>
<member name="M:Deedle.Reflection.createTypedVectorHelper``1(System.Collections.Generic.IEnumerable{Deedle.OptionalValue{System.Object}})">
<summary>
 Helper function that creates IVector&lt;&apos;T&gt; and casts it to IVector
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.Reflection">

</member>
<member name="M:Deedle.SeriesModule.unionUsing``2(Deedle.UnionBehavior,Deedle.Series{``0,``1},Deedle.Series{``0,``1})">
<summary>
 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.SeriesModule.union``2(Deedle.Series{``0,``1},Deedle.Series{``0,``1})">
<summary>
 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.SeriesModule.zipInto``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Deedle.Series{``3,``0},Deedle.Series{``3,``1})">
<summary>
 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.SeriesModule.zipAlignInto``4(Deedle.JoinKind,Deedle.Lookup,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Deedle.Series{``3,``0},Deedle.Series{``3,``1})">
<summary>
 [category:Joining, zipping and appending]
</summary>
</member>
<member name="M:Deedle.SeriesModule.zipInner``3(Deedle.Series{``0,``1},Deedle.Series{``0,``2})">
<summary>
 [category:Appending, joining and zipping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.zip``3(Deedle.Series{``0,``1},Deedle.Series{``0,``2})">
<summary>
 [category:Appending, joining and zipping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.zipAlign``3(Deedle.JoinKind,Deedle.Lookup,Deedle.Series{``0,``1},Deedle.Series{``0,``2})">
<summary>
 [category:Appending, joining and zipping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.append``2(Deedle.Series{``0,``1},Deedle.Series{``0,``1})">
<summary>
 [category:Appending, joining and zipping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.lookupTimeAt``2(``0,System.TimeSpan,Deedle.Direction,Deedle.Lookup,Deedle.Series{``0,``1})">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting at the specified `start` time, using the specified `interval`
 and then finds values close to such keys using the specified `lookup` and `dir`.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `start` - The initial time to be used for sampling
  - `interval` - The interval between the individual samples 
  - `dir` - Specifies how the keys should be generated. `Direction.Forward` means that the 
    key is the smallest value of each chunk (and so first key of the series is returned and 
    the last is not, unless it matches exactly _start + k*interval_); `Direction.Backward`
    means that the first key is skipped and sample is generated at, or just before the end 
    of interval and at the end of the series.
  - `lookup` - Specifies how the lookup based on keys is performed. `Exact` means that the
    values at exact keys will be returned; `NearestGreater` returns the nearest greater key value
    (starting at the first key) and `NearestSmaller` returns the nearest smaller key value
    (starting at most `interval` after the end of the series)
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesModule.lookupTime``2(System.TimeSpan,Deedle.Direction,Deedle.Lookup,Deedle.Series{``0,``1})">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting from the smallest key of the original series, using the specified `interval`
 and then finds values close to such keys using the specified `lookup` and `dir`.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
  - `dir` - Specifies how the keys should be generated. `Direction.Forward` means that the 
    key is the smallest value of each chunk (and so first key of the series is returned and 
    the last is not, unless it matches exactly _start + k*interval_); `Direction.Backward`
    means that the first key is skipped and sample is generated at, or just before the end 
    of interval and at the end of the series.
  - `lookup` - Specifies how the lookup based on keys is performed. `Exact` means that the
    values at exact keys will be returned; `NearestGreater` returns the nearest greater key value
    (starting at the first key) and `NearestSmaller` returns the nearest smaller key value
    (starting at most `interval` after the end of the series)
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesModule.sampleTimeAt``2(``0,System.TimeSpan,Deedle.Direction,Deedle.Series{``0,``1})">
<summary>
 Performs sampling by time and returns chunks obtained by time-sampling as a nested  
 series. The operation generates keys starting at the given `start` time, using the 
 specified `interval` and then obtains chunks based on these
 keys in a fashion similar to the `Series.resample` function.

 ## Parameters
  - `series` - An input series to be resampled
  - `start` - The initial time to be used for sampling
  - `interval` - The interval between the individual samples 
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesModule.sampleTime``2(System.TimeSpan,Deedle.Direction,Deedle.Series{``0,``1})">
<summary>
 Performs sampling by time and returns chunks obtained by time-sampling as a nested  
 series. The operation generates keys starting at the first key in the source series,
 using the specified `interval` and then obtains chunks based on these
 keys in a fashion similar to the `Series.resample` function.

 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesModule.sampleTimeAtInto``3(``0,System.TimeSpan,Deedle.Direction,Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``1},``2},Deedle.Series{``0,``1})">
<summary>
 Performs sampling by time and aggregates chunks obtained by time-sampling into a single
 value using a specified function. The operation generates keys starting at the given
 `start` time, using the specified `interval` and then obtains chunks based on these
 keys in a fashion similar to the `Series.resample` function.

 ## Parameters
  - `series` - An input series to be resampled
  - `start` - The initial time to be used for sampling
  - `interval` - The interval between the individual samples 
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.
  - `f` - A function that is called to aggregate each chunk into a single value.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesModule.sampleTimeInto``3(System.TimeSpan,Deedle.Direction,Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``1},``2},Deedle.Series{``0,``1})">
<summary>
 Performs sampling by time and aggregates chunks obtained by time-sampling into a single
 value using a specified function. The operation generates keys starting at the first
 key in the source series, using the specified `interval` and then obtains chunks based on 
 these keys in a fashion similar to the `Series.resample` function.

 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.
  - `f` - A function that is called to aggregate each chunk into a single value.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesModule.resampleUniform``3(Deedle.Lookup,Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``1},Deedle.Series{``0,``2})">
<summary>
 Resample the series based on equivalence class on the keys and also generate values 
 for all keys of the target space that are between the minimal and maximal key of the
 specified series (e.g. generate value for all days in the range covered by the series).
 A specified function `keyProj` is used to project keys to another space and `nextKey`
 is used to generate all keys in the range. Then return the chunks as nested series.

 When there are no values for a (generated) key, then the function behaves according to
 `fillMode`. It can look at the greatest value of previous chunk or smallest value of the
 next chunk, or it produces an empty series.

 ## Parameters
  - `series` - An input series to be resampled
  - `fillMode` - When set to `Lookup.NearestSmaller` or `Lookup.NearestGreater`, 
     the function searches for a nearest available observation in an neighboring chunk.
     Otherwise, the function `f` is called with an empty series as an argument.
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)
  - `nextKey` - A function that gets the next key in the transformed space
    
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 

 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesModule.resampleUniformInto``4(Deedle.Lookup,Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``1},Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``2},``3},Deedle.Series{``0,``2})">
<summary>
 Resample the series based on equivalence class on the keys and also generate values 
 for all keys of the target space that are between the minimal and maximal key of the
 specified series (e.g. generate value for all days in the range covered by the series).
 A specified function `keyProj` is used to project keys to another space and `nextKey`
 is used to generate all keys in the range. The chunk is then aggregated using `f`.

 When there are no values for a (generated) key, then the function behaves according to
 `fillMode`. It can look at the greatest value of previous chunk or smallest value of the
 next chunk, or it produces an empty series.

 ## Parameters
  - `series` - An input series to be resampled
  - `fillMode` - When set to `Lookup.NearestSmaller` or `Lookup.NearestGreater`, 
     the function searches for a nearest available observation in an neighboring chunk.
     Otherwise, the function `f` is called with an empty series as an argument.
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)
  - `nextKey` - A function that gets the next key in the transformed space
  - `f` - A function that is used to collapse a generated chunk into a 
    single value. The function may be called on empty series when `fillMode` is
    `Lookup.Exact`.
    
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 

 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesModule.resampleEquiv``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``0,``2})">
<summary>
 Resample the series based on equivalence class on the keys. A specified function
 `keyProj` is used to project keys to another space and the observations for which the 
 projected keys are equivalent are grouped into chunks. The chunks are then returned
 as nested series.

 ## Parameters
  - `series` - An input series to be resampled
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)

 ## Remarks
 This function is similar to `Series.chunkBy`, with the exception that it transforms
 keys to a new space.

 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. For unordered
 series, similar functionality can be implemented using `Series.groupBy`.

 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesModule.resampleEquivInto``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``2},``3},Deedle.Series{``0,``2})">
<summary>
 Resample the series based on equivalence class on the keys. A specified function
 `keyProj` is used to project keys to another space and the observations for which the 
 projected keys are equivalent are grouped into chunks. The chunks are then transformed
 to values using the provided function `f`.

 ## Parameters
  - `series` - An input series to be resampled
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)
  - `f` - A function that is used to collapse a generated chunk into a 
    single value. 

 ## Remarks
 This function is similar to `Series.chunkBy`, with the exception that it transforms
 keys to a new space.

 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. For unordered
 series, similar functionality can be implemented using `Series.groupBy`.

 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesModule.resample``2(System.Collections.Generic.IEnumerable{``0},Deedle.Direction,Deedle.Series{``0,``1})">
<summary>
 Resample the series based on a provided collection of keys. The values of the series
 are aggregated into chunks based on the specified keys. Depending on `direction`, the 
 specified key is either used as the smallest or as the greatest key of the chunk (with
 the exception of boundaries that are added to the first/last chunk).
 Such chunks are then returned as nested series.

 ## Parameters
  - `series` - An input series to be resampled
  - `keys` - A collection of keys to be used for resampling of the series
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered.

 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesModule.resampleInto``3(System.Collections.Generic.IEnumerable{``0},Deedle.Direction,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``1},``2}},Deedle.Series{``0,``1})">
<summary>
 Resample the series based on a provided collection of keys. The values of the series
 are aggregated into chunks based on the specified keys. Depending on `direction`, the 
 specified key is either used as the smallest or as the greatest key of the chunk (with
 the exception of boundaries that are added to the first/last chunk).
 Such chunks are then aggregated using the provided function `f`.

 ## Parameters
  - `series` - An input series to be resampled
  - `keys` - A collection of keys to be used for resampling of the series
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.
  - `f` - A function that is used to collapse a generated chunk into a 
    single value. Note that this function may be called with empty series.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered.

 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:Deedle.SeriesModule.orderByKey``2(Deedle.Series{``0,``1})">
<summary>
 Returns a new series whose entries are reordered according to index order

 ## Parameters
  - `series` - An input series to be used

 [category:Data structure manipulation]
</summary>
</member>
<member name="M:Deedle.SeriesModule.fillMissingBetween``2(``0,``0,Deedle.Direction,Deedle.Series{``0,``1})">
<summary>
 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.SeriesModule.fillMissing``2(Deedle.Direction,Deedle.Series{``0,``1})">
<summary>
 Fill missing values in the series with the nearest available value
 (using the specified direction). Note that the series may still contain
 missing values after call to this function. This operation can only be
 used on ordered series.

 ## Parameters
  - `series` - An input series that is to be filled
  - `direction` - Specifies the direction used when searching for 
    the nearest available value. `Backward` means that we want to
    look for the first value with a smaller key while `Forward` searches
    for the nearest greater key.

 ## Example

     let sample = Series.ofValues [ Double.NaN; 1.0; Double.NaN; 3.0 ]

     // Returns a series consisting of [1; 1; 3; 3]
     sample |&gt; Series.fillMissing Direction.Backward

     // Returns a series consisting of [&lt;missing&gt;; 1; 1; 3]
     sample |&gt; Series.fillMissing Direction.Forward 

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.SeriesModule.fillMissingWith``3(``0,Deedle.Series{``1,``2})">
<summary>
 Fill missing values in the series with a constant value.

 ## Parameters
  - `series` - An input series that is to be filled
  - `value` - A constant value that is used to fill all missing values

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.SeriesModule.fillMissingUsing``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``0,``1})">
<summary>
 Fill missing values in the series using the specified function.
 The specified function is called with all keys for which the series
 does not contain value and the result of the call is used in place 
 of the missing value. 

 ## Parameters
  - `series` - An input series that is to be filled
  - `f` - A function that takes key `K` and generates a value to be
    used in a place where the original series contains a missing value.

 ## Remarks
 This function can be used to implement more complex interpolation.
 For example see [handling missing values in the tutorial](../features.html#missing)

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.SeriesModule.dropMissing``2(Deedle.Series{``0,``1})">
<summary>
 Drop missing values from the specified series. The returned series contains 
 only those keys for which there is a value available in the original one.

 ## Parameters
  - `series` - An input series to be filtered

 ## Example

     let s = series [ 1 =&gt; 1.0; 2 =&gt; Double.NaN ]
     s |&gt; Series.dropMissing 
     [fsi:val it : Series&lt;int,float&gt; = series [ 1 =&gt; 1]

 [category:Missing values]
</summary>
</member>
<member name="M:Deedle.SeriesModule.groupBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Deedle.Series{``0,``1})">
<summary>
 Groups a series (ordered or unordered) using the specified key selector (`keySelector`) 
 and then returns a series of (nested) series as the result. The outer series is indexed by
 the newly produced keys, the nested series are indexed with the original keys.

 ## Parameters
  - `keySelector` - Generates a new key that is used for aggregation, based on the original 
    key and value. The new key must support equality testing.
  - `series` - An input series to be grouped. 

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.groupInto``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``1},``3}},Deedle.Series{``0,``1})">
<summary>
 Groups a series (ordered or unordered) using the specified key selector (`keySelector`) 
 and then aggregates each group into a single value, returned in the resulting series,
 using the provided `valueSelector` function.

 ## Parameters
  - `keySelector` - Generates a new key that is used for aggregation, based on the original 
    key and value. The new key must support equality testing.
  - `valueSelector` - A value selector function that is called to aggregate 
    each group of collected elements.
  - `series` - An input series to be grouped. 

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.pairwiseWith``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``1,``1},``2}},Deedle.Series{``0,``1})">
<summary>
 Aggregates the input into pairs containing the predecessor and an element for each input, except
 for the first one. Then calls the specified aggregation function `f` with a tuple and a key.
 The returned series is one key shorter (it does not contain a  value for the first key).

 ## Parameters
  - `f` - A function that is called for each pair to produce result in the final series.
  - `series` - The input series to be aggregated.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.pairwise``2(Deedle.Series{``0,``1})">
<summary>
 Returns a series containing the predecessor and an element for each input, except
 for the first one. The returned series is one key shorter (it does not contain a 
 value for the first key).

 ## Parameters
  - `series` - The input series to be aggregated.

 ## Example

     let input = series [ 1 =&gt; &apos;a&apos;; 2 =&gt; &apos;b&apos;; 3 =&gt; &apos;c&apos;]
     let res = input |&gt; Series.pairwise
     res = series [2 =&gt; (&apos;a&apos;, &apos;b&apos;); 3 =&gt; (&apos;b&apos;, &apos;c&apos;) ]

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.chunk``2(System.Int32,Deedle.Series{``0,``1})">
<summary>
 Aggregates the input into a series of adacent chunks and returns the produced chunks as
 a nested series. The key in the new series is the last key of the chunk. This function
 skips incomplete chunks - you can use `Series.chunkSize` for more options.

 ## Parameters
  - `size` - The size of the chunk.
  - `series` - The input series to be aggregated.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.chunkInto``3(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``1},``2},Deedle.Series{``0,``1})">
<summary>
 Aggregates the input into a series of adacent chunks and then applies the provided 
 value selector `f` on each chunk to produce the result which is returned as a new series. 
 The key in the new series is the last key of the chunk. This function
 skips incomplete chunks - you can use `Series.chunkSizeInto` for more options.

 ## Parameters
  - `size` - The size of the chunk.
  - `series` - The input series to be aggregated.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.window``2(System.Int32,Deedle.Series{``0,``1})">
<summary>
 Creates a sliding window using the specified size and returns the produced windows as 
 a nested series. The key in the new series is the last key of the window. This function
 skips incomplete chunks - you can use `Series.windowSize` for more options.

 ## Parameters
  - `size` - The size of the sliding window.
  - `series` - The input series to be aggregated.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.windowInto``3(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``1},``2},Deedle.Series{``0,``1})">
<summary>
 Creates a sliding window using the specified size and then applies the provided 
 value selector `f` on each window to produce the result which is returned as a new series. 
 This function skips incomplete chunks - you can use `Series.windowSizeInto` for more options.

 ## Parameters
  - `size` - The size of the sliding window.
  - `series` - The input series to be aggregated.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.chunkWhile``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},Deedle.Series{``0,``1})">
<summary>
 Aggregates the input into a series of adacent chunks based on a condition on keys. A chunk is started 
 once the specified `cond` function returns `false` when called on  the first and the last key of the 
 previous chunk. The chunks are then returned as a nested series.
 The key of each chunk is the key of the first element in the chunk.

 ## Parameters
  - `cond` - A function that is called on the first and the last key of a chunk
    to determine when a window should end.
  - `series` - The input series to be aggregated.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.chunkWhileInto``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``1},``2},Deedle.Series{``0,``1})">
<summary>
 Aggregates the input into a series of adacent chunks based on a condition on keys. A chunk is started 
 once the specified `cond` function returns `false` when called on  the first and the last key of the 
 previous chunk. Each chunk is then aggregated into a value using the
 specified function `f`. The key of each chunk is the key of the first element in the chunk.

 ## Parameters
  - `cond` - A function that is called on the first and the last key of a chunk
    to determine when a window should end.
  - `f` - A value selector that is called to aggregate each chunk.
  - `series` - The input series to be aggregated.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.chunkDist``3(``0,Deedle.Series{``1,``2})">
<summary>
 Aggregates the input into a series of adacent chunks. A chunk is started once
 the distance between the first and the last key of a previous chunk is greater
 than the specified `distance`. The chunks are then returned as a nested series.
 The key of each chunk is the key of the first element in the chunk.

 ## Parameters
  - `distance` - The maximal allowed distance between keys of a chunk. Note that this
    is an inline function - there must be `-` operator defined between `distance` and the
    keys of the series.
  - `series` - The input series to be aggregated.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.chunkDistInto``4(``0,Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``1,``2},``3},Deedle.Series{``1,``2})">
<summary>
 Aggregates the input into a series of adacent chunks. A chunk is started once
 the distance between the first and the last key of a previous chunk is greater
 than the specified `distance`. Each chunk is then aggregated into a value using the
 specified function `f`. The key of each chunk is the key of the first element in the chunk.

 ## Parameters
  - `distance` - The maximal allowed distance between keys of a chunk. Note that this
    is an inline function - there must be `-` operator defined between `distance` and the
    keys of the series.
  - `f` - A value selector that is called to aggregate each chunk.
  - `series` - The input series to be aggregated.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.chunkSize``2(System.Int32,Deedle.Boundary,Deedle.Series{``0,``1})">
<summary>
 Aggregates the input into a series of adacent chunks using the specified size and boundary behavior and returns
 the produced chunks as a nested series. The key is the last key of the chunk, unless
 boundary behavior is `Boundary.AtEnding` (in which case it is the first key).

 ## Parameters
  - `bounds` - Specifies the chunk size and bounary behavior. The boundary behavior
    can be `Boundary.Skip` (meaning that no incomplete chunks are produced), 
    `Boundary.AtBeginning` (meaning that incomplete chunks are produced at the beginning)
    or `Boundary.AtEnding` (to produce incomplete chunks at the end of series)
  - `series` - The input series to be aggregated.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.chunkSizeInto``3(System.Int32,Deedle.Boundary,Microsoft.FSharp.Core.FSharpFunc{Deedle.DataSegment{Deedle.Series{``0,``1}},``2},Deedle.Series{``0,``1})">
<summary>
 Aggregates the input into a series of adacent chunks using the specified size and boundary behavior and then
 applies the provided value selector `f` on each chunk to produce the result
 which is returned as a new series. The key is the last key of the chunk, unless
 boundary behavior is `Boundary.AtEnding` (in which case it is the first key).

 ## Parameters
  - `bounds` - Specifies the chunk size and bounary behavior. The boundary behavior
    can be `Boundary.Skip` (meaning that no incomplete chunks are produced), 
    `Boundary.AtBeginning` (meaning that incomplete chunks are produced at the beginning)
    or `Boundary.AtEnding` (to produce incomplete chunks at the end of series)
  - `f` - A value selector that is called to aggregate each chunk.
  - `series` - The input series to be aggregated.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.windowWhile``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},Deedle.Series{``0,``1})">
<summary>
 Creates a sliding window based on a condition on keys. A window is started at each
 input element and ends once the specified `cond` function returns `false` when called on 
 the first and the last key of the window. The windows are then returned as a nested series.
 The key of each window is the key of the first element in the window.

 ## Parameters
  - `cond` - A function that is called on the first and the last key of a window
    to determine when a window should end.
  - `series` - The input series to be aggregated.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.windowWhileInto``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``1},``2},Deedle.Series{``0,``1})">
<summary>
 Creates a sliding window based on a condition on keys. A window is started at each
 input element and ends once the specified `cond` function returns `false` when called on 
 the first and the last key of the window. Each window is then aggregated into a value using the
 specified function `f`. The key of each window is the key of the first element in the window.

 ## Parameters
  - `cond` - A function that is called on the first and the last key of a window
    to determine when a window should end.
  - `f` - A function that is used to aggregate each window into a single value.
  - `series` - The input series to be aggregated.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.windowDist``3(``0,Deedle.Series{``1,``2})">
<summary>
 Creates a sliding window based on distance between keys. A window is started at each
 input element and ends once the distance between the first and the last key is greater
 than the specified `distance`. The windows are then returned as a nested series.
 The key of each window is the key of the first element in the window.

 ## Parameters
  - `distance` - The maximal allowed distance between keys of a window. Note that this
    is an inline function - there must be `-` operator defined between `distance` and the
    keys of the series.
  - `series` - The input series to be aggregated.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.windowDistInto``4(``0,Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``1,``2},``3},Deedle.Series{``1,``2})">
<summary>
 Creates a sliding window based on distance between keys. A window is started at each
 input element and ends once the distance between the first and the last key is greater
 than the specified `distance`. Each window is then aggregated into a value using the
 specified function `f`. The key of each window is the key of the first element in the window.

 ## Parameters
  - `distance` - The maximal allowed distance between keys of a window. Note that this
    is an inline function - there must be `-` operator defined between `distance` and the
    keys of the series.
  - `f` - A function that is used to aggregate each window into a single value.
  - `series` - The input series to be aggregated.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.windowSize``2(System.Int32,Deedle.Boundary,Deedle.Series{``0,``1})">
<summary>
 Creates a sliding window using the specified size and boundary behavior and returns
 the produced windows as a nested series. The key is the last key of the window, unless
 boundary behavior is `Boundary.AtEnding` (in which case it is the first key).

 ## Parameters
  - `bounds` - Specifies the window size and bounary behavior. The boundary behavior
    can be `Boundary.Skip` (meaning that no incomplete windows are produced), 
    `Boundary.AtBeginning` (meaning that incomplete windows are produced at the beginning)
    or `Boundary.AtEnding` (to produce incomplete windows at the end of series)
  - `series` - The input series to be aggregated.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.windowSizeInto``3(System.Int32,Deedle.Boundary,Microsoft.FSharp.Core.FSharpFunc{Deedle.DataSegment{Deedle.Series{``0,``1}},``2},Deedle.Series{``0,``1})">
<summary>
 Creates a sliding window using the specified size and boundary behavior and then
 applies the provided value selector `f` on each window to produce the result
 which is returned as a new series. The key is the last key of the window, unless
 boundary behavior is `Boundary.AtEnding` (in which case it is the first key).

 ## Parameters
  - `bounds` - Specifies the window size and bounary behavior. The boundary behavior
    can be `Boundary.Skip` (meaning that no incomplete windows are produced), 
    `Boundary.AtBeginning` (meaning that incomplete windows are produced at the beginning)
    or `Boundary.AtEnding` (to produce incomplete windows at the end of series)
  - `f` - A value selector that is called to aggregate each window.
  - `series` - The input series to be aggregated.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.aggregateInto``4(Deedle.Aggregation{``0},Microsoft.FSharp.Core.FSharpFunc{Deedle.DataSegment{Deedle.Series{``0,``1}},``2},Microsoft.FSharp.Core.FSharpFunc{Deedle.DataSegment{Deedle.Series{``0,``1}},Deedle.OptionalValue{``3}},Deedle.Series{``0,``1})">
<summary>
 Aggregates an ordered series using the method specified by `Aggregation&lt;K&gt;` and then
 applies the provided value selector `f` on each window or chunk to produce the result
 which is returned as a new series. A key for each window or chunk is
 selected using the specified `keySelector`.

 ## Parameters
  - `aggregation` - Specifies the aggregation method using `Aggregation&lt;K&gt;`. This is
    a discriminated union listing various chunking and windowing conditions.
  - `keySelector` - A function that is called on each chunk to obtain a key.
  - `f` - A value selector function that is called to aggregate each chunk or window.
  - `series` - The input series to be aggregated.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.aggregate``3(Deedle.Aggregation{``0},Microsoft.FSharp.Core.FSharpFunc{Deedle.DataSegment{Deedle.Series{``0,``1}},``2},Deedle.Series{``0,``1})">
<summary>
 Aggregates an ordered series using the method specified by `Aggregation&lt;K&gt;` and 
 returns the windows or chunks as nested series. A key for each window or chunk is
 selected using the specified `keySelector`.

 ## Parameters
  - `aggregation` - Specifies the aggregation method using `Aggregation&lt;K&gt;`. This is
    a discriminated union listing various chunking and windowing conditions.
  - `keySelector` - A function that is called on each chunk to obtain a key.
  - `series` - The input series to be aggregated.

 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:Deedle.SeriesModule.ReduceLevel``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``2,``2}},Deedle.Series{``0,``2})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `level` and then aggregates elements in each group
 using the specified function `op`. The result is a new series containing
 the aggregates of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - An input series to be aggregated
  - `op` - A function that is used to aggregate elements of each group
  - `level` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Reduce``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Deedle.Series{``1,``0})">
<summary>
 Aggregates the values of the specified series using a function that can combine
 individual values. 

 ## Parameters
  - `series` - An input series to be aggregated
  - `op` - A function that is used to aggregate elements of the series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesModule.CountLevel``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``0,``2})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `level` and then returns a new series containing
 the counts of elements in each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the counts
  - `level` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesModule.MaxLevel``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``0,``2})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `level` and then returns a new series containing
 the greatest element of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the greatest elements
  - `level` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesModule.MinLevel``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``0,``2})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `level` and then returns a new series containing
 the greatest element of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the greatest elements
  - `level` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesModule.SumLevel``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``0,``2})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `level` and then returns a new series containing
 the sum of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the sums
  - `level` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesModule.MedianLevel``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``0,System.Double})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `level` and then returns a new series containing
 the median of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the medians
  - `level` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesModule.StandardDeviationLevel``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``0,System.Double})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `level` and then returns a new series containing
 the standard deviation of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the standard deviations
  - `level` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesModule.MeanLevel``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Deedle.Series{``0,``2})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `level` and then returns a new series containing
 the mean of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - A series of values that are used to calculate the means
  - `level` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesModule.ApplyLevel``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``2},``3},Deedle.Series{``0,``2})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `level` and then aggregates series representing each group
 using the specified function `op`. The result is a new series containing
 the aggregates of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - An input series to be aggregated
  - `op` - A function that takes a series and produces an aggregated result
  - `level` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesModule.StatisticsLevel``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``2},``3},Deedle.Series{``0,``2})">
<summary>
 Groups the elements of the input series in groups based on the keys
 produced by `level` and then aggregates elements in each group
 using the specified function `op`. The result is a new series containing
 the aggregates of each group. 

 This operation is designed to be used with [hierarchical indexing](../features.html#indexing).

 ## Parameters
  - `series` - An input series to be aggregated
  - `op` - A function that takes a sequence and produces an aggregated result
  - `level` - A delegate that returns a new group key, based on the key in the input series

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesModule.InternalApplyLevel``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Collections.ObjectModel.ReadOnlyCollection{``2},``3},Microsoft.FSharp.Core.FSharpFunc{System.Collections.ObjectModel.ReadOnlyCollection{Deedle.OptionalValue{``2}},``3},Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``2},``3},Deedle.Series{``0,``2})">
<summary>
 [omit]
 Applies `fastAggregation` to each group produced using the specified `keySelector`
</summary>
</member>
<member name="M:Deedle.SeriesModule.Min``2(Deedle.Series{``0,``1})">
<summary>
 Returns the greatest of all elements of the series. The operation 
 skips over missing values and so the result will never be `NaN`.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Max``2(Deedle.Series{``0,``1})">
<summary>
 Returns the smallest of all elements of the series. The operation 
 skips over missing values and so the result will never be `NaN`.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Median``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns the median of the elements of the series. The operation skips over
 missing values and so the result will never be `NaN`.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesModule.StandardDeviation``1(Deedle.Series{``0,System.Double})">
<summary>
 Returns the standard deviation of the elements of the series. The operation skips over
 missing values and so the result will never be `NaN`.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Mean``2(Deedle.Series{``0,``1})">
<summary>
 Returns the mean of the elements of the series. The operation skips over
 missing values and so the result will never be `NaN`.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Sum``2(Deedle.Series{``0,``1})">
<summary>
 Returns the sum of the elements of the series. The operation skips over
 missing values and so the result will never be `NaN`.
 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesModule.Stat``3(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``0},``1},Deedle.Series{``2,``0})">
<summary>
 Aggregates the values of the specified series using a function that operates on
 sequence (`IEnumerable&lt;T&gt;`). This simply reads all non-missing values and passes
 them to the specified operation.

 ## Parameters
  - `series` - An input series to be aggregated
  - `op` - A function that takes a sequence and produces an aggregated result

 [category:Statistics]
</summary>
</member>
<member name="M:Deedle.SeriesModule.InternalFastAggregation``3(Microsoft.FSharp.Core.FSharpFunc{System.Collections.ObjectModel.ReadOnlyCollection{``0},``1},Microsoft.FSharp.Core.FSharpFunc{System.Collections.ObjectModel.ReadOnlyCollection{Deedle.OptionalValue{``0}},``1},Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``0},``1},Deedle.Series{``2,``0})">
<summary>
 Aggregates non-missing values using the specified functions working 
 on either ReadOnlyCollection&lt;&apos;T&gt;, ReadOnlyCollection&lt;OptionalValue&lt;&apos;T&gt;&gt; or seq&lt;&apos;T&gt;
</summary>
</member>
<member name="M:Deedle.SeriesModule.InternalStreamingAggregation``3(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``0},``1},Deedle.Series{``2,``0})">
<summary>
 Aggregates non-missing values using the specified function working on seq&lt;&apos;T&gt;
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.SeriesModule.FlattenLevel``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``2},``3},Deedle.Series{``0,``2})">
<summary>
 [category:Statistics]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.SeriesModule.countKeys``2(Deedle.Series{``0,``1})">
<summary>
 Returns the total number of keys in the specified series. This returns
 the total length of the series, including keys for which there is no 
 value available.
</summary>
</member>
<member name="M:Deedle.SeriesModule.countValues``2(Deedle.Series{``0,``1})">
<summary>
 Returns the total number of values in the specified series. This excludes
 missing values or not available values (such as values created from `null`,
 `Double.NaN`, or those that are missing due to outer join etc.).
</summary>
</member>
<member name="M:Deedle.SeriesModule.diff``3(System.Int32,Deedle.Series{``0,``1})">
<summary>
 `result[k] = series[k] - series[k - offset]`
</summary>
</member>
<member name="">

</member>
<member name="M:Deedle.SeriesModule.trySuccesses``2(Deedle.Series{``0,Deedle.TryValue{``1}})">
<summary>
 Return a Series of all successful tries 
</summary>
</member>
<member name="M:Deedle.SeriesModule.tryErrors``2(Deedle.Series{``0,Deedle.TryValue{``1}})">
<summary>
 Return a Series of all exceptions 
</summary>
</member>
<member name="M:Deedle.SeriesModule.tryValues``2(Deedle.Series{``0,Deedle.TryValue{``1}})">
<summary>
 Throws `AggregateException` if something goes wrong
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.SeriesModule.get``2(``0,Deedle.Series{``0,``1})">
<summary>
 Get the value for the specified key.
 Uses exact lookup semantics for key lookup - use `lookupAll` for more options
</summary>
</member>
<member name="M:Deedle.SeriesModule.lookup``2(``0,Deedle.Lookup,Deedle.Series{``0,``1})">
<summary>
 Get the value for the specified key.
 Use the specified lookup semantics - for exact matching, use `get`
</summary>
</member>
<member name="M:Deedle.SeriesModule.getAll``2(System.Collections.Generic.IEnumerable{``0},Deedle.Series{``0,``1})">
<summary>
 Create a new series that contains values for all provided keys.
 Uses exact lookup semantics for key lookup - use `lookupAll` for more options
</summary>
</member>
<member name="M:Deedle.SeriesModule.lookupAll``2(System.Collections.Generic.IEnumerable{``0},Deedle.Lookup,Deedle.Series{``0,``1})">
<summary>
 Create a new series that contains values for all provided keys.
 Use the specified lookup semantics - for exact matching, use `getAll`
</summary>
</member>
<member name="M:Deedle.SeriesModule.observationsAll``2(Deedle.Series{``0,``1})">
<summary>
 Returns all keys from the sequence, together with the associated (optional) values. 
</summary>
</member>
<member name="M:Deedle.SeriesModule.observations``2(Deedle.Series{``0,``1})">
<summary>
 Return observations with available values. The operation skips over 
 all keys with missing values (such as values created from `null`,
 `Double.NaN`, or those that are missing due to outer join etc.).
</summary>
</member>
<member name="M:Deedle.SeriesModule.Implementation.lookupTimeInternal``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpOption{``0},``1,Deedle.Direction,Deedle.Lookup,Deedle.Series{``0,``2})">
<summary>
 Given a specified starting time and time span, generates all keys that fit in the
 range of the series (and one additional, if `dir = Backward`) and then performs lookup
 for each key using the specified direction
</summary>
</member>
<member name="M:Deedle.SeriesModule.Implementation.sampleTimeIntoInternal``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpOption{``0},``1,Deedle.Direction,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Deedle.Series{``0,``2},``3}},Deedle.Series{``0,``2})">
<summary>
 Given a specified starting time and time span, generates all keys that fit in the
 range of the series (and one additional, if `dir = Backward`) and then performs
 sampling using `resampleInto`.
</summary>
</member>
<member name="">

</member>
<member name="T:Deedle.SeriesModule.Implementation">
<summary>
 [omit]
 Module that contains an implementation of sampling for `sampleTime` and 
 `sampleTimeInto`. For technical reasons (`inline`) this is public..
</summary>
</member>
<member name="T:Deedle.SeriesModule">
<summary>
 Series module comment..
 
 ## Lookup, resampling and scaling
 More stuff here

 ## Missing values
 More stuff here

 ## Windowing, chunking and grouping
 The functions with name starting with `windowed` take a series and generate floating 
 (overlapping) windows. The `chunk` functions 

 ## Statistics
 Here
</summary>
</member>
<member name="M:Deedle.VectorExtensions.IVector`1.get_DataSequence``1(Deedle.IVector{``0})">
<summary>
 Returns the data of the vector as a lazy sequence. (This preserves the 
 order of elements in the vector and so it also returns missing values.)
</summary>
</member>
<member name="T:Deedle.VectorExtensions">
<summary>
 Module with extensions for generic vector type. Given `vec` of type `IVector&lt;T&gt;`, 
 the extension property `vec.DataSequence` returns all data of the vector converted
 to the &quot;least common denominator&quot; data structure - `IEnumerable&lt;T&gt;`.
</summary>
</member>
<member name="">

</member>
<member name="T:Deedle.VectorHelpers.CreateTypedVectorHelper">
<summary>
 Helper object called by createTypedVector via reflection
</summary>
</member>
<member name="M:Deedle.VectorHelpers.TryValuesHelper.TryValues``1(Deedle.IVector{Deedle.TryValue{``0}})">
<summary>
 Turns IVector&lt;TryValue&lt;&apos;T&gt;&gt; into TryValue&lt;IVector&lt;&apos;T&gt;&gt; by aggregating all exceptions
 (used via reflection by the `tryValues` function below)
</summary>
</member>
<member name="T:Deedle.VectorHelpers.TryValuesHelper">
<summary>
 Helper type that is used via reflection
</summary>
</member>
<member name="P:Deedle.VectorHelpers.VectorValueTransform.RightIfAvailable">
<summary>
 A generic transformation that prefers the left value (if it is not missing)
</summary>
</member>
<member name="P:Deedle.VectorHelpers.VectorValueTransform.LeftOrRight">
<summary>
 A generic transformation that works when at most one value is defined
</summary>
</member>
<member name="P:Deedle.VectorHelpers.VectorValueTransform.LeftIfAvailable">
<summary>
 A generic transformation that prefers the left value (if it is not missing)
</summary>
</member>
<member name="M:Deedle.VectorHelpers.VectorValueTransform.CreateLifted``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}})">
<summary>
 Creates a transformation that applies the specified function on `&apos;T` values 
</summary>
</member>
<member name="M:Deedle.VectorHelpers.VectorValueTransform.Create``1(Microsoft.FSharp.Core.FSharpFunc{Deedle.OptionalValue{``0},Microsoft.FSharp.Core.FSharpFunc{Deedle.OptionalValue{``0},Deedle.OptionalValue{``0}}})">
<summary>
 Creates a transformation that applies the specified function on `&apos;T` values 
</summary>
</member>
<member name="T:Deedle.VectorHelpers.VectorValueTransform">
<summary>
 A type that implements common vector value transformations and 
 a helper method for creating transformation on values of known types
</summary>
</member>
<member name="">

</member>
<member name="T:Deedle.VectorHelpers.VectorCallSite2`1">
<summary>
 Represents a generic function `\forall.&apos;T.(IVector&lt;&apos;T&gt; * IVector&lt;&apos;T&gt; -&gt; &apos;R)`. The function 
 can be generically invoked on a pair of `IVector` values using `createTwoVectorDispatcher`
</summary>
</member>
<member name="">

</member>
<member name="T:Deedle.VectorHelpers.VectorCallSite1`1">
<summary>
 Represents a generic function `\forall.&apos;T.(IVector&lt;&apos;T&gt; -&gt; &apos;R)`. The function can be 
 generically invoked on an argument of type `IVector` using `createVectorDispatcher`
</summary>
</member>
<member name="">

</member>
<member name="T:Deedle.VectorHelpers.ValueCallSite1`1">
<summary>
 Represents a generic function `\forall.&apos;T.(&apos;T -&gt; &apos;R)`. The function can be 
 generically invoked on an argument of type `obj` using `createValueDispatcher`
</summary>
</member>
<member name="M:Deedle.VectorHelpers.substitute(System.Int32,System.Int32)">
<summary>
 Substitute variable hole for another in a vector construction
</summary>
</member>
<member name="M:Deedle.VectorHelpers.createTypedVector(Deedle.Vectors.IVectorBuilder,System.Object[])">
<summary>
 Given object array, create a typed vector of the best possible type
</summary>
</member>
<member name="M:Deedle.VectorHelpers.tryValues(Deedle.IVector)">
<summary>
 Given an IVector, check if the vector contains `&apos;T tryval` values and if it does,
 turn that into a vector of just `&apos;T` values, or return aggregated exception
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.VectorHelpers.createTwoVectorDispatcher``1(Deedle.VectorHelpers.VectorCallSite2{``0})">
<summary>
 Creates a function `IVector * IVector -&gt; &apos;R` that dynamically invokes to 
 a generic `Invoke` method of the provided `VectorCallSite2&lt;&apos;R&gt;`
</summary>
</member>
<member name="M:Deedle.VectorHelpers.createVectorDispatcher``1(Deedle.VectorHelpers.VectorCallSite1{``0})">
<summary>
 Creates a function `IVector -&gt; &apos;R` that dynamically invokes to 
 a generic `Invoke` method of the provided `VectorCallSite1&lt;&apos;R&gt;`
</summary>
</member>
<member name="M:Deedle.VectorHelpers.createValueDispatcher``1(Deedle.VectorHelpers.ValueCallSite1{``0})">
<summary>
 Creates a function `obj -&gt; &apos;R` that dynamically invokes to 
 a generic `Invoke` method of the provided `ValueCallSite1&lt;&apos;R&gt;`
</summary>
</member>
<member name="P:Deedle.VectorHelpers.stringCode">
<summary>
 Type code of the `string` type for efficient type equality test
</summary>
</member>
<member name="P:Deedle.VectorHelpers.intCode">
<summary>
 Type code of the `int` type for efficient type equality test
</summary>
</member>
<member name="P:Deedle.VectorHelpers.doubleCode">
<summary>
 Type code of the `float` type for efficient type equality test
</summary>
</member>
<member name="M:Deedle.VectorHelpers.delegatedVector``1(Microsoft.FSharp.Core.FSharpRef{Deedle.IVector{``0}})">
<summary>
 Create a new vector that delegates all functionality to a ref vector
</summary>
</member>
<member name="M:Deedle.VectorHelpers.prettyPrintVector``1(Deedle.IVector{``0})">
<summary>
 Pretty printer for vectors. This uses the &apos;Data&apos; property
</summary>
</member>
<member name="M:Deedle.VectorHelpers.Inference.commonSupertype(System.Type,System.Type)">
<summary>
 Given two types, find their common supertype
</summary>
</member>
<member name="P:Deedle.VectorHelpers.Inference.Top">
<summary>
 System.Type representing top
</summary>
</member>
<member name="P:Deedle.VectorHelpers.Inference.Bottom">
<summary>
 System.Type representing bottom
</summary>
</member>
<member name="M:Deedle.VectorHelpers.Inference.|Top|Bottom|String|Int|Float|(System.Type)">
<summary>
 Classsify type as one of the supported primitives
</summary>
</member>
<member name="T:Deedle.VectorHelpers.Inference">
<summary>
 Helper functions and active patterns for type inference
</summary>
</member>
<member name="T:Deedle.VectorHelpers">
<summary>
 A module with various utilities for working with vectors. 
</summary>
</member>
<member name="M:Deedle.Vectors.IVectorBuilder.CreateMissing``1(Deedle.OptionalValue{``0}[])">
<summary>
 Create a vector from an array containing values that may be missing. 
 Even if a value is passed, it may be a missing value such as `Double.NaN`
 or `null`. The vector builder should hanlde this.
</summary>
</member>
<member name="M:Deedle.Vectors.IVectorBuilder.Create``1(``0[])">
<summary>
 Create a vector from an array containing values. The values may 
 still represent missing values and the vector should handle this.
 For example `Double.NaN` or `null` should be turned into a missing
 value in the returned vector.
</summary>
</member>
<member name="M:Deedle.Vectors.IVectorBuilder.Build``1(Deedle.Vectors.VectorConstruction,Deedle.IVector{``0}[])">
<summary>
 Apply a vector construction to a given vector. The second parameter
 is an array of arguments (&quot;variables&quot;) that may be referenced from the
 `VectorConstruction` using the `Return 0` construct.
</summary>
</member>
<member name="M:Deedle.Vectors.IVectorBuilder.AsyncBuild``1(Deedle.Vectors.VectorConstruction,Deedle.IVector{``0}[])">
<summary>
 Asynchronous version of `Build` operation. This is mainly used for 
 `AsyncMaterialize` and it does not handle fully general vector constructions (yet)
</summary>
</member>
<member name="T:Deedle.Vectors.IVectorBuilder">
<summary>
 Represents an object that can construct vector values by processing 
 the &quot;mini-DSL&quot; representation `VectorConstruction`.
</summary>
</member>
<member name="M:Deedle.Vectors.IVectorValueTransform.GetFunction``1">
<summary>
 Returns a function that combines two values stored in vectors into a new vector value.
 Although generic, this function will only be called with the `T` set to the
 type of vector that is being built. Since `VectorConstruction` is not generic,
 the type cannot be statically propagated.
</summary>
</member>
<member name="T:Deedle.Vectors.IVectorValueTransform">
<summary>
 Represent a transformation that is applied when combining two vectors
 (because we are combining untyped `IVector` values, the transformation
 is also untyped)
</summary>
</member>
<member name="M:Deedle.Vectors.Vector.CreateMissing``1(System.Collections.Generic.IEnumerable{System.Nullable{``0}})">
<summary>
 Creates a vector that stores the specified data in an array.
 Values such as `null` and `Double.NaN` are turned into missing values.
</summary>
</member>
<member name="M:Deedle.Vectors.Vector.CreateMissing``1(System.Collections.Generic.IEnumerable{Deedle.OptionalValue{``0}})">
<summary>
 Creates a vector that stores the specified data in an array.
 Values such as `null` and `Double.NaN` are turned into missing values.
</summary>
</member>
<member name="M:Deedle.Vectors.Vector.Create``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a vector that stores the specified data in an array.
 Values such as `null` and `Double.NaN` are turned into missing values.
</summary>
</member>
<member name="M:Deedle.Vectors.Vector.Create``1(``0[])">
<summary>
 Creates a vector that stores the specified data in an array.
 Values such as `null` and `Double.NaN` are turned into missing values.
</summary>
</member>
<member name="T:Deedle.Vectors.Vector">
<summary>
 Type that provides access to creating vectors (represented as arrays)
</summary>
</member>
<member name="T:Deedle.Vectors.VectorConstruction.AsyncCustomCommand">
<summary>
 Same as `CustomCommand` with the difference that the resulting vector is returned
 asynchronously (this is useful for lazy loading and it is used by `AsyncBuild`).
</summary>
</member>
<member name="T:Deedle.Vectors.VectorConstruction.CustomCommand">
<summary>
 Apply a custom command to a vector - this can be used by special indices (e.g. index
 for a lazy vector) to provide a custom operations to be used. The first parameter
 is a list of sub-vectors to be combined (if as in e.g. `Append`) and the
 second argument is a function that will be called with evaluated vectors and is
 supposed to create the new vector.
</summary>
</member>
<member name="T:Deedle.Vectors.VectorConstruction.FillMissing">
<summary>
 Create a vector that has missing values filled using the specified direction
 (forward means that n-th value will contain (n-i)-th value where (n-i) is the
 first index that contains a value).
</summary>
</member>
<member name="T:Deedle.Vectors.VectorConstruction.Combine">
<summary>
 Combine two aligned vectors. The `IVectorValueTransform` object
 specifies how to merge values (in case there is a value at a given address
 in both of the vectors).
</summary>
</member>
<member name="T:Deedle.Vectors.VectorConstruction.Append">
<summary>
 Append two vectors after each other
</summary>
</member>
<member name="T:Deedle.Vectors.VectorConstruction.GetRange">
<summary>
 Get the specified range of addresses from the vector and return it as a new vector
</summary>
</member>
<member name="T:Deedle.Vectors.VectorConstruction.DropRange">
<summary>
 Drop the specified range of addresses from the vector 
 and return a new vector that excludes the range
</summary>
</member>
<member name="T:Deedle.Vectors.VectorConstruction.Relocate">
<summary>
 Reorders elements of the vector. Carries a new required vector range and a list
 of relocations (each pair of addresses specifies that an element at a new address 
 should be filled with an element from an old address). THe addresses may be out of range!
</summary>
</member>
<member name="T:Deedle.Vectors.VectorConstruction.Empty">
<summary>
 Creates an empty vector of the requested type
</summary>
</member>
<member name="T:Deedle.Vectors.VectorConstruction.Return">
<summary>
 When constructing vectors, we get an array of vectors to be used as &quot;variables&quot;
 - this element represent getting one of the variables.
</summary>
</member>
<member name="T:Deedle.Vectors.VectorConstruction">
<summary>
 A &quot;mini-DSL&quot; that describes construction of a vector. Vector can be constructed
 from various range operations (relocate, drop, slicing, appending), by combination
 of two vectors or by taking a vector from a list of variables.

 Notably, vectors can only be constructed from other vectors of the same type 
 (the `Combine` operation requires this - even though that one could be made more general).
 This is an intentional choice to make the representation simpler.

 Logically, when we apply some index operation, we should get back a polymorphic vector
 construction (`\forall T. VectorConstruction&lt;T&gt;`) that can be applied to variuous 
 different vector types. That would mean adding some more types, so we just model vector
 construction as an untyped operation and the typing is resquired by the `Build` method
 of the vector builder.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.Vectors.VectorData`1">
<summary>
 Provides a way to get the data of an arbitrary vector. This is a concrete type used 
 by functions that operate on vectors (like `Series.sum`, etc.). The vector may choose
 to return the data as `ReadOnlyCollection` (with or without N/A values) which is more
 efficient to use or as a lazy sequence (slower, but more general).
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.Vectors.VectorFillMissing">
<summary>
 Specifies how to fill missing values in a vector (when using the 
 `VectorConstruction.FillMissing` command). This can only fill missing
 values using strategy that does not require access to index keys - 
 either using constant or by propagating values.
</summary>
</member>
<member name="T:Deedle.Vectors.VectorHole">
<summary>
 Representes a &quot;variable&quot; in the mini-DSL below
</summary>
</member>
<member name="T:Deedle.Vectors.VectorRange">
<summary>
 Represents a range inside a vector
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.Vectors.ArrayVector.ArrayVector`1">
<summary>
 --------------------------------------------------------------------------------------
 Vector that stores data in an array. The data is stored using the
 `ArrayVectorData&lt;&apos;T&gt;` type (discriminated union)
</summary>
</member>
<member name="">

</member>
<member name="F:Deedle.Vectors.ArrayVector.Deedle.Vectors.ArrayVector.ArrayVectorBuilder.vectorBuilder">
<summary>
 Instance of the vector builder
</summary>
</member>
<member name="P:Deedle.Vectors.ArrayVector.ArrayVectorBuilder.Instance">
<summary>
 Provides a global access to an instance of the `ArrayVectorBuilder`
</summary>
</member>
<member name="M:Deedle.Vectors.ArrayVector.ArrayVectorBuilder.buildArrayVector``1(Deedle.Vectors.VectorConstruction,Deedle.IVector{``0}[])">
<summary>
 Builds a vector using the specified commands, ensures that the
 returned vector is ArrayVector (if no, it converts it) and then
 returns the internal representation of the vector
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Deedle.Vectors.ArrayVector.ArrayVectorBuilder.Deedle-Vectors-IVectorBuilder-Build``1(Deedle.Vectors.VectorConstruction,Deedle.IVector{``0}[])">
<summary>
 Given a vector construction command(s) produces a new IVector
 (the result is typically ArrayVector, but this is not guaranteed)
</summary>
</member>
<member name="M:Deedle.Vectors.ArrayVector.ArrayVectorBuilder.Deedle-Vectors-IVectorBuilder-AsyncBuild``1(Deedle.Vectors.VectorConstruction,Deedle.IVector{``0}[])">
<summary>
 Asynchronous version - limited implementation for AsyncMaterialize
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.Vectors.ArrayVector.ArrayVectorBuilder">
<summary>
 Implements a builder object (`IVectorBuilder`) for creating
 vectors of type `ArrayVector&lt;&apos;T&gt;`. This includes operations such as
 appending, relocating values, creating vectors from arrays etc.
 The vector builder automatically switches between the two possible
 representations of the vector - when a missing value is present, it
 uses `ArrayVectorData.VectorOptional`, otherwise it uses 
 `ArrayVectorData.VectorNonOptional`.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Deedle.Vectors.ArrayVector.ArrayVectorData`1">
<summary>
 --------------------------------------------------------------------------------------
 ArrayVector - stores data of the vector in a continuous memory block. If the vector
 contains missing values, then uses `OptionalValue&lt;&apos;T&gt;[]`, otherwise uses just `&apos;T[]`.
 --------------------------------------------------------------------------------------
 Internal representation of the ArrayVector. To make this more 
 efficient, we distinguish between &quot;sparse&quot; vectors that have missing 
 values and &quot;dense&quot; vectors without N/As.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:ExtCore.Collections.ExtCore.Collections.LazyList`1.undefinedValue">
<summary>
 The status for undefined values.
</summary>
</member>
<member name="">

</member>
<member name="M:ExtCore.Collections.LazyList`1.op_PlusPlus(ExtCore.Collections.LazyList{`0},ExtCore.Collections.LazyList{`0})">
<summary>
 Appends the second LazyList to the end of the first.
</summary>
</member>
<member name="">

</member>
<member name="P:ExtCore.Collections.LazyList`1.IsEmpty">
<summary>
 Test if a list is empty.
 Forces the evaluation of the first element of the stream if it is not already evaluated.
</summary>
</member>
<member name="P:ExtCore.Collections.LazyList`1.Empty">
<summary>
 The empty LazyList.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyList`1.TryHeadTail">
<summary>
 Get the first cell of the list.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyList`1.ToSeq">
<summary>
 Creates a sequence which enumerates the values in the LazyList.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyList`1.Tail">
<summary>
 Return the list corresponding to the remaining items in the sequence.
 Forces the evaluation of the first cell of the list if it is not already evaluated.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyList`1.Head">
<summary>
 Return the first element of the list.
 Forces the evaluation of the first cell of the list if it is not already evaluated.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:ExtCore.Collections.LazyList`1.Delayed(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,ExtCore.Collections.LazyList{`0}})">
<summary>
 Return a list that is -- in effect -- the list returned by the given computation.
 The given computation is not executed until the first element on the list is consumed.
</summary>
</member>
<member name="">

</member>
<member name="M:ExtCore.Collections.LazyList`1.ConsDelayed(`0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,ExtCore.Collections.LazyList{`0}})">
<summary>
 Return a new list which on consumption contains the given item 
 followed by the list returned by the given computation.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyList`1.Cons(`0,ExtCore.Collections.LazyList{`0})">
<summary>
 Return a new list which contains the given item followed by the given list.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:ExtCore.Collections.LazyList`1">
<summary>
 LazyLists are possibly-infinite, cached sequences.  See also IEnumerable/Seq for
 uncached sequences. LazyLists normally involve delayed computations without 
 side-effects.  The results of these computations are cached and evaluations will be 
 performed only once for each element of the lazy list.  In contrast, for sequences 
 (IEnumerable) recomputation happens each time an enumerator is created and the sequence 
 traversed.

 LazyLists can represent cached, potentially-infinite computations.  Because they are 
 cached they may cause memory leaks if some active code or data structure maintains a 
 live reference to the head of an infinite or very large lazy list while iterating it, 
 or if a reference is maintained after the list is no longer required.

 Lazy lists may be matched using the LazyList.Cons and LazyList.Nil active patterns. 
 These may force the computation of elements of the list.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:ExtCore.Collections.LazyListPatterns">
<summary>
 Active patterns for deconstructing lazy lists.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.ToArray``1(ExtCore.Collections.LazyList{``0})">
<summary>
 Build an array from the given LazyList. This function will eagerly
 evaluate the entire list (and thus may not terminate).
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.ToList``1(ExtCore.Collections.LazyList{``0})">
<summary>
 Build a non-lazy list from the given collection. This function will eagerly
 evaluate the entire list (and thus may not terminate).
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.ToSeq``1(ExtCore.Collections.LazyList{``0})">
<summary>
 Return a view of the collection as an enumerable object.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.OfArray``1(``0[])">
<summary>
 Create a LazyList containing the elements of the given array.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.copyFrom``1(System.Int32,``0[])">
<summary>
 Creates a LazyList from an array by copying elements from the array into the LazyList.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Create a LazyList containing the elements of the given list.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.OfSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Build a LazyList from the given sequence of elements.
</summary>
</member>
<member name="">

</member>
<member name="M:ExtCore.Collections.LazyListModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},ExtCore.Collections.LazyList{``0})">
<summary>
 Apply the given function to each element of the collection.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Skip``1(System.Int32,ExtCore.Collections.LazyList{``0})">
<summary>
 Return the list which on consumption will skip the first &apos;count&apos; elements of the input list.
</summary>
</member>
<member name="">

</member>
<member name="M:ExtCore.Collections.LazyListModule.Take``1(System.Int32,ExtCore.Collections.LazyList{``0})">
<summary>
 Return the list which on consumption will consist of
 at most &apos;count&apos; elements of the input list.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,ExtCore.Collections.LazyList{``1})">
<summary>
 Return a new list consisting of the results of applying the
 given accumulating function to successive elements of the list.
</summary>
</member>
<member name="">

</member>
<member name="M:ExtCore.Collections.LazyListModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.Collections.LazyList{``0})">
<summary>
 Return a new collection which on consumption will consist of only the
 elements of the collection for which the given predicate returns &quot;true&quot;.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Zip``1(ExtCore.Collections.LazyList{``0},ExtCore.Collections.LazyList{``0})">
<summary>
 Return the list which contains on demand the pair of elements of the first and second list.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},ExtCore.Collections.LazyList{``0},ExtCore.Collections.LazyList{``1})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},ExtCore.Collections.LazyList{``0})">
<summary>
 Build a new collection whose elements are the results of applying
 the given function to each of the elements of the collection.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Unfold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``1,``0}}},``0)">
<summary>
 Return a list that contains the elements returned by the given computation.
 The given computation is not executed until the first element on the list is
 consumed.  The given argument is passed to the computation.  Subsequent elements
 in the list are generated by again applying the residual &apos;b to the computation.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.Collections.LazyList{``0})">
<summary>
 Return the first element for which the given function returns &lt;c&gt;true&lt;/c&gt;.
 Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.Collections.LazyList{``0})">
<summary>
 Apply the given function to successive elements of the list, returning the first
 result where function returns &lt;c&gt;Some(x)&lt;/c&gt; for some x.
 If the function never returns true, &apos;None&apos; is returned.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Concat``1(ExtCore.Collections.LazyList{ExtCore.Collections.LazyList{``0}})">
<summary>
 Return the list which contains on demand the list of elements of the list of lazy lists.
</summary>
</member>
<member name="">

</member>
<member name="M:ExtCore.Collections.LazyListModule.Append``1(ExtCore.Collections.LazyList{``0},ExtCore.Collections.LazyList{``0})">
<summary>
 Return the list which contains on demand the elements of the
 first list followed by the elements of the second list.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Repeat``1(``0)">
<summary>
 Return the list which on consumption will consist of an
 infinite sequence of the given item.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Length``1(ExtCore.Collections.LazyList{``0})">
<summary>
 Return the length of the list.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.lzy``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,ExtCore.Collections.LazyListCell{``0}})">
<summary>
 Alias for LazyList.CreateLazy.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.consCell``1(``0,ExtCore.Collections.LazyList{``0})">
<summary>
 Returns a new LazyListCell created by adding a value to the end of the given LazyList.
 This is simply a curried form of the Cons constructor.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Singleton``1(``0)">
<summary>
 Creates a LazyList containing the given value.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Delayed``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,ExtCore.Collections.LazyList{``0}})">
<summary>
 Return a list that is -- in effect -- the list returned by the given computation.
 The given computation is not executed until the first element on the list is consumed.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.ConsDelayed``1(``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,ExtCore.Collections.LazyList{``0}})">
<summary>
 Return a new list which on consumption contains the given item
 followed by the list returned by the given computation.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Cons``1(``0,ExtCore.Collections.LazyList{``0})">
<summary>
 Return a new list which contains the given item followed by the given list.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.IsEmpty``1(ExtCore.Collections.LazyList{``0})">
<summary>
 Test if a list is empty.
 Forces the evaluation of the first element of the stream if it is not already evaluated.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Tail``1(ExtCore.Collections.LazyList{``0})">
<summary>
 Return the list corresponding to the remaining items in the sequence.
 Forces the evaluation of the first cell of the list if it is not already evaluated.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Head``1(ExtCore.Collections.LazyList{``0})">
<summary>
 Return the first element of the list.
 Forces the evaluation of the first cell of the list if it is not already evaluated.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.TryGet``1(ExtCore.Collections.LazyList{``0})">
<summary>
 Get the first cell of the list.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Empty``1">
<summary>
 The empty LazyList.
</summary>
</member>
<member name="T:ExtCore.Collections.LazyListModule">
<summary>
 Functional operators on LazyLists.
</summary>
</member>
<member name="M:ExtCore.Collections.ExtCoreExtensions.RaiseArgumentOutOfRangeException``1(System.String,System.String)">
<summary>
 Raises a System.ArgumentOutOfRangeException.
</summary>
</member>
<member name="M:ExtCore.Collections.ExtCoreExtensions.CheckNonNull``1(System.String,``0)">
<summary>
 Determines if a reference is a null reference, and if it is, throws an ArgumentNullException.
</summary>
</member>
<member name="M:ExtCore.Collections.ExtCoreExtensions.IsNull``1(``0)">
<summary>
 Determines if a reference is a null reference.
</summary>
</member>
<member name="T:ExtCore.Collections.ExtCoreExtensions">

</member>
<member name="">

</member>
<member name="T:System.AssemblyVersionInformation">

</member>
</members>
</doc>
